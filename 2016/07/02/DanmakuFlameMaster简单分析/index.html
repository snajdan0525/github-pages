<!DOCTYPE html>
<html >
<head>
  
    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

  <meta charset="utf-8">
  <meta name="baidu-site-verification" content="zzKGwrFJYw" />
  
  <title>弹幕框架DanmakuFlameMaster简单分析 | April is your lie</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="&amp;#160; &amp;#160; &amp;#160; &amp;#160;随着B站逐渐崛起，其开源弹幕项目DanmakuFlameMaster应用场景也越来越多。我也是在一次偶然机会下发现了这个项目，被其惊艳的效果震撼。以前我就对弹幕技术很感兴趣，可能是因为B站动漫看多，几乎每一部番都是漫天的弹幕乱飞，如果哪部剧没有弹幕反而觉得不适应；久而久之就愈发倾向钻研其原理。&amp;#160; &amp;#160; &amp;#160; &amp;#16">
<meta property="og:type" content="article">
<meta property="og:title" content="弹幕框架DanmakuFlameMaster简单分析">
<meta property="og:url" content="http://windrunnerlihuan.com/2016/07/02/DanmakuFlameMaster简单分析/index.html">
<meta property="og:site_name" content="April is your lie">
<meta property="og:description" content="&amp;#160; &amp;#160; &amp;#160; &amp;#160;随着B站逐渐崛起，其开源弹幕项目DanmakuFlameMaster应用场景也越来越多。我也是在一次偶然机会下发现了这个项目，被其惊艳的效果震撼。以前我就对弹幕技术很感兴趣，可能是因为B站动漫看多，几乎每一部番都是漫天的弹幕乱飞，如果哪部剧没有弹幕反而觉得不适应；久而久之就愈发倾向钻研其原理。&amp;#160; &amp;#160; &amp;#160; &amp;#16">
<meta property="og:image" content="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/DanmakuFlameMaster%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/meizi.jpg">
<meta property="og:image" content="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/DanmakuFlameMaster%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/wakeng.jpg">
<meta property="og:updated_time" content="2016-07-06T22:27:30.222Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="弹幕框架DanmakuFlameMaster简单分析">
<meta name="twitter:description" content="&amp;#160; &amp;#160; &amp;#160; &amp;#160;随着B站逐渐崛起，其开源弹幕项目DanmakuFlameMaster应用场景也越来越多。我也是在一次偶然机会下发现了这个项目，被其惊艳的效果震撼。以前我就对弹幕技术很感兴趣，可能是因为B站动漫看多，几乎每一部番都是漫天的弹幕乱飞，如果哪部剧没有弹幕反而觉得不适应；久而久之就愈发倾向钻研其原理。&amp;#160; &amp;#160; &amp;#160; &amp;#16">
<meta name="twitter:image" content="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/DanmakuFlameMaster%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/meizi.jpg">
  
    <link rel="alternative" href="/atom.xml" title="April is your lie" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.png">
  
  
      <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">
  
  
      <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
      <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">
  
  <link rel="stylesheet" href="/css/style.css">
  
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <link rel="apple-touch-icon" href="/img/apple-touch-icon.png">
  
  
      <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">
  
  <script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
  <script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>
  <script>
      var yiliaConfig = {
          fancybox: true,
          animate: true,
          isHome: false,
          isPost: true,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false,
          fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
          scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
          search: true
      }
  </script>

  
      <script>
          yiliaConfig.jquery_ui = [true, "//cdn.bootcss.com/jqueryui/1.10.4/jquery-ui.min.js", "//cdn.bootcss.com/jqueryui/1.10.4/css/jquery-ui.min.css"];
      </script>
  

  
      <script>
          yiliaConfig.rootUrl = "/";
      </script>
  

  
  
  <!-- 自动推送工具代码 start -->
  <script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<!-- 自动推送工具代码 end -->
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/avatar.jpg" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">windrunnerlihuan</a></h1>
        </hgroup>

        
        <p class="header-subtitle">四月是你的谎言</p>
        

        
            <form id="search-form">
            <input type="text" id="local-search-input" name="q" results="0" placeholder="search..." class="search form-control" autocomplete="off" autocorrect="off" searchonload="undefined" />
            <i class="fa fa-times" onclick="resetSearch()"></i>
            </form>
            <div id="local-search-result"></div>
            <p class='no-result'>No results found <i class='fa fa-spinner fa-pulse'></i></p>
        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">时间轴</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="mailto:937874128@qq.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="https://github.com/windrunnerlihuan" title="GitHub"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Binder/">Binder</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Bitmap/">Bitmap</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IPC/">IPC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SO库/">SO库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/博客搭建/">博客搭建</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/属性动画/">属性动画</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/开始/">开始</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/弹幕/">弹幕</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/插件开发/">插件开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/智能指针/">智能指针</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/消息/">消息</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/移动直播/">移动直播</a></li></ul>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://gank.io/">干货集中营</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.jcodecraeer.com/">泡在网上的日子</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://trinea.cn/">Trinea</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">windrunnerlihuan，开发小菜一枚，坐标位于上海。</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">windrunnerlihuan</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/avatar.jpg" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">windrunnerlihuan</a></h1>
            </hgroup>
            
            <p class="header-subtitle">四月是你的谎言</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">时间轴</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="mailto:937874128@qq.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="https://github.com/windrunnerlihuan" title="GitHub"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap"><article id="post-DanmakuFlameMaster简单分析" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/07/02/DanmakuFlameMaster简单分析/" class="article-date">
      <time datetime="2016-07-02T12:13:04.000Z" itemprop="datePublished">2016-07-02</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      弹幕框架DanmakuFlameMaster简单分析
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Android技术点/">Android技术点</a>
    </div>


        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/弹幕/">弹幕</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <hr>
<p>&#160; &#160; &#160; &#160;随着B站逐渐崛起，其开源弹幕项目<a href="https://github.com/Bilibili/DanmakuFlameMaster" target="_blank" rel="external">DanmakuFlameMaster</a>应用场景也越来越多。我也是在一次偶然机会下发现了这个项目，被其惊艳的效果震撼。以前我就对弹幕技术很感兴趣，可能是因为B站动漫看多，几乎每一部番都是漫天的弹幕乱飞，如果哪部剧没有弹幕反而觉得不适应；久而久之就愈发倾向钻研其原理。<br>&#160; &#160; &#160; &#160;看到效果后，我猜想<strong>绘制原理</strong>应该是创建一个定时器作为全部弹幕的时间参考，然后每条弹幕出现的位置都以这个定时器去计算x、y值，然后定时任务定期postInvalidate，弹幕画布重新绘制onDraw；弹幕如此之多，应该有<strong>缓存机制</strong>，也许建立了一个弹幕池让出现过的弹幕缓存起来，新弹幕可以复用旧弹幕item。<br>&#160; &#160; &#160; &#160;先这么假设吧，然后验证我们的猜想，看看有哪些坑。<br><a id="more"></a></p>
<hr>
<h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><p>&#160; &#160; &#160; &#160;首先是添加控件，项目里提供了三个控件：DanmakuSurfaceView、DanmakuTextureView和DanmakuView，使用其中三个任意一个都可以。我们选个DanmakuView方便分析。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">FrameLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span><br><span class="line">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span><br><span class="line">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span><br><span class="line">    <span class="attr">tools:context</span>=<span class="string">".MainActivity"</span>&gt;</span>	</span><br><span class="line">    </span><br><span class="line">	省略一些布局...</span><br><span class="line">	</span><br><span class="line">    <span class="tag">&lt;<span class="name">master.flame.danmaku.ui.widget.DanmakuView</span></span><br><span class="line">        <span class="attr">android:id</span>=<span class="string">"@+id/sv_danmaku"</span></span><br><span class="line">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span><br><span class="line">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span> /&gt;</span></span><br><span class="line">        </span><br><span class="line">    省略一些布局...  </span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">FrameLayout</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;然后是代码配置，先看一下初始化相关：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">      setContentView(R.layout.activity_main);</span><br><span class="line">      findViews();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">findViews</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">省略一些代码...</span><br><span class="line"></span><br><span class="line">      <span class="comment">// DanmakuView</span></span><br><span class="line">mDanmakuView = (IDanmakuView) findViewById(R.id.sv_danmaku);</span><br><span class="line">      <span class="comment">// 设置最大显示行数</span></span><br><span class="line">      HashMap&lt;Integer, Integer&gt; maxLinesPair = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">      maxLinesPair.put(BaseDanmaku.TYPE_SCROLL_RL, <span class="number">5</span>); <span class="comment">// 滚动弹幕最大显示5行</span></span><br><span class="line">      <span class="comment">// 设置是否禁止重叠</span></span><br><span class="line">      HashMap&lt;Integer, Boolean&gt; overlappingEnablePair = <span class="keyword">new</span> HashMap&lt;Integer, Boolean&gt;();</span><br><span class="line">      overlappingEnablePair.put(BaseDanmaku.TYPE_SCROLL_RL, <span class="keyword">true</span>);</span><br><span class="line">      overlappingEnablePair.put(BaseDanmaku.TYPE_FIX_TOP, <span class="keyword">true</span>);</span><br><span class="line">   <span class="comment">//创建弹幕控件上下文，类似Context，里面可以进行一系列配置</span></span><br><span class="line">      mContext = DanmakuContext.create();</span><br><span class="line">mContext.setDanmakuStyle(IDisplayer.DANMAKU_STYLE_STROKEN, <span class="number">3</span>)<span class="comment">//设置描边样式</span></span><br><span class="line">.setDuplicateMergingEnabled(<span class="keyword">false</span>) <span class="comment">//设置不合并相同内容弹幕</span></span><br><span class="line">.setScrollSpeedFactor(<span class="number">1.2f</span>) <span class="comment">//设置弹幕滚动速度缩放比例，越大速度越慢</span></span><br><span class="line">.setScaleTextSize(<span class="number">1.2f</span>) <span class="comment">//设置字体缩放比例</span></span><br><span class="line">   .setCacheStuffer(<span class="keyword">new</span> SpannedCacheStuffer(), mCacheStufferAdapter) <span class="comment">// 图文混排使用SpannedCacheStuffer  </span></span><br><span class="line"><span class="comment">//.setCacheStuffer(new BackgroundCacheStuffer())  // 绘制背景使用BackgroundCacheStuffer</span></span><br><span class="line">      .setMaximumLines(maxLinesPair) <span class="comment">//设置最大行数策略</span></span><br><span class="line">      .preventOverlapping(overlappingEnablePair); <span class="comment">//设置禁止重叠策略</span></span><br><span class="line">      	       </span><br><span class="line">省略一些代码...</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;DanmakuContext设置setCacheStuffer(CacheStuffer, Proxy)时，如果不设置此方法，则CacheStuffer默认为SimpleTextCacheStuffer，proxy默认为null；第一个参数，项目例子中提供了BackgroundCacheStuffer和SpannedCacheStuffer，其实也可以自己扩展，第二个参数例子中也写了一个mCacheStufferAdapter，同理也可以自己扩展。这个sample中注释也写得比较明确，我们往下分析原理时会解释。<br>&#160; &#160; &#160; &#160;然后设置数据源：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">			<span class="comment">//替换为A站弹幕数据源，因为A站弹幕数据是json，B站是xml，为了方便分析因此替换为A站源</span></span><br><span class="line">            <span class="comment">//mParser = createParser(this.getResources().openRawResource(R.raw.comments));</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mParser = createParser(<span class="keyword">this</span>.getAssets().open(<span class="string">"comment.json"</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> BaseDanmakuParser <span class="title">createParser</span><span class="params">(InputStream stream)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (stream == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> BaseDanmakuParser() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> Danmakus <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> Danmakus();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        ILoader loader = DanmakuLoaderFactory.create(DanmakuLoaderFactory.TAG_BILI);</span></span><br><span class="line">        ILoader loader = DanmakuLoaderFactory.create(DanmakuLoaderFactory.TAG_ACFUN);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            loader.load(stream);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalDataException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        BaseDanmakuParser parser = new BiliDanmukuParser();</span></span><br><span class="line">        BaseDanmakuParser parser = <span class="keyword">new</span> AcFunDanmakuParser();</span><br><span class="line">        IDataSource&lt;?&gt; dataSource = loader.getDataSource();</span><br><span class="line">        parser.load(dataSource);</span><br><span class="line">        <span class="keyword">return</span> parser;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;最后启动弹幕：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置弹幕view相关回调</span></span><br><span class="line">mDanmakuView.setCallback(<span class="keyword">new</span> DrawHandler.Callback() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateTimer</span><span class="params">(DanmakuTimer timer)</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawingFinished</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">danmakuShown</span><span class="params">(BaseDanmaku danmaku)</span> </span>&#123;</span><br><span class="line">         <span class="comment">//Log.d("DFM", "danmakuShown(): text=" + danmaku.text);</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Log.d(<span class="string">"DFM"</span>, <span class="string">"MainActivity inline callback's method prepared"</span>);</span><br><span class="line">            mDanmakuView.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    mDanmakuView.prepare(mParser, mContext);</span><br><span class="line">    mDanmakuView.showFPS(<span class="keyword">true</span>);</span><br><span class="line">    mDanmakuView.enableDanmakuDrawingCache(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;基本使用在项目的例子中都写的很清楚，这些应该难度不大。接下来应该是分析流程了。</p>
<h1 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h1><p>&#160; &#160; &#160; &#160;DanmakuFlameMaster流程确实十分复杂，因为变量实在太多了，所以分析时推荐先整体看个大概，然后一步一步打断点确认细节。</p>
<h2 id="初始配置"><a href="#初始配置" class="headerlink" title="初始配置"></a>初始配置</h2><p>&#160; &#160; &#160; &#160;上面写基本使用法，第一步是初始配置，我们看看到底初始化了哪些参数。对比上面的调用顺序，首先进入DanmakuContext看看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">		<span class="comment">//相关配置如下，主要初始化一下变量</span></span><br><span class="line">		mContext.setDanmakuStyle(IDisplayer.DANMAKU_STYLE_STROKEN, <span class="number">3</span>)<span class="comment">//设置描边样式</span></span><br><span class="line">		.setDuplicateMergingEnabled(<span class="keyword">false</span>) <span class="comment">//设置不合并相同内容弹幕</span></span><br><span class="line">		.setScrollSpeedFactor(<span class="number">1.2f</span>) <span class="comment">//设置弹幕滚动速度缩放比例，越大速度越慢</span></span><br><span class="line">		.setScaleTextSize(<span class="number">1.2f</span>) <span class="comment">//设置字体缩放比例</span></span><br><span class="line">	    .setCacheStuffer(<span class="keyword">new</span> SpannedCacheStuffer(), mCacheStufferAdapter) <span class="comment">// 图文混排使用SpannedCacheStuffer  </span></span><br><span class="line">		<span class="comment">//.setCacheStuffer(new BackgroundCacheStuffer())  // 绘制背景使用BackgroundCacheStuffer</span></span><br><span class="line">        .setMaximumLines(maxLinesPair) <span class="comment">//设置最大行数策略</span></span><br><span class="line">        .preventOverlapping(overlappingEnablePair); <span class="comment">//设置禁止重叠策略</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//DanmakuContext 类重要方法</span></span><br><span class="line">		<span class="comment">/*------------DanmakuContext STAET-----------*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AbsDisplayer mDisplayer = <span class="keyword">new</span> AndroidDisplayer();<span class="comment">//创建DanmakuContext 对象时直接new了个mDisplayer 全局变量</span></span><br><span class="line">	 <span class="comment">/**</span><br><span class="line">     * 设置缓存绘制填充器，默认使用SimpleTextCacheStuffer只支持纯文字显示, 如果需要图文混排请设置SpannedCacheStuffer </span><br><span class="line">     * 如果需要定制其他样式请扩展SimpleTextCacheStuffer或者SpannedCacheStuffer</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DanmakuContext <span class="title">setCacheStuffer</span><span class="params">(BaseCacheStuffer cacheStuffer, BaseCacheStuffer.Proxy cacheStufferAdapter)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mCacheStuffer = cacheStuffer;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.mCacheStuffer != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.mCacheStuffer.setProxy(cacheStufferAdapter);</span><br><span class="line">            mDisplayer.setCacheStuffer(<span class="keyword">this</span>.mCacheStuffer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*------------DanmakuContext END-----------*/</span></span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;以上配置主要配置一些常规参数，记不住也没关系，我们可以打断点一一查看。</p>
<h2 id="加载资源"><a href="#加载资源" class="headerlink" title="加载资源"></a>加载资源</h2><p>&#160; &#160; &#160; &#160;然后就是加载弹幕源：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> BaseDanmakuParser <span class="title">createParser</span><span class="params">(InputStream stream)</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建A站弹幕加载器</span></span><br><span class="line">      ILoader loader = DanmakuLoaderFactory.create(DanmakuLoaderFactory.TAG_ACFUN);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">//将数据流载入加载器里</span></span><br><span class="line">          loader.load(stream);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IllegalDataException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//创建弹幕解析器</span></span><br><span class="line">      BaseDanmakuParser parser = <span class="keyword">new</span> AcFunDanmakuParser();</span><br><span class="line">      <span class="comment">//取出数据源</span></span><br><span class="line">      IDataSource&lt;?&gt; dataSource = loader.getDataSource();</span><br><span class="line">      <span class="comment">//解析器放入数据源</span></span><br><span class="line">      parser.load(dataSource);</span><br><span class="line">      <span class="keyword">return</span> parser;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;我们一步一步来，先创建A站弹幕加载器：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据不同标签创建不同加载器，可以根据不同业务自己扩展定制</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ILoader <span class="title">create</span><span class="params">(String tag)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (TAG_BILI.equalsIgnoreCase(tag)) &#123;</span><br><span class="line">           <span class="keyword">return</span> BiliDanmakuLoader.instance();</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span>(TAG_ACFUN.equalsIgnoreCase(tag))<span class="comment">//我们到了这里</span></span><br><span class="line">       	<span class="keyword">return</span> AcFunDanmakuLoader.instance();</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;载入数据流：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">(InputStream in)</span> <span class="keyword">throws</span> IllegalDataException </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		dataSource = <span class="keyword">new</span> JSONSource(in);<span class="comment">//这里创建了一个JSONSource</span></span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalDataException(e);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//JSONSource构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">JSONSource</span><span class="params">(InputStream in)</span> <span class="keyword">throws</span> JSONException</span>&#123;</span><br><span class="line">	init(in);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(InputStream in)</span> <span class="keyword">throws</span> JSONException </span>&#123;</span><br><span class="line">	......</span><br><span class="line">	mInput = in;</span><br><span class="line">	String json = IOUtils.getString(mInput);<span class="comment">//将流转成字符串</span></span><br><span class="line">	init(json);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(String json)</span> <span class="keyword">throws</span> JSONException </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!TextUtils.isEmpty(json))&#123;</span><br><span class="line">		mJSONArray = <span class="keyword">new</span> JSONArray(json);<span class="comment">//将json字符串保存到一个JSONArray全局变量</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//取出JSONSource</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> JSONSource <span class="title">getDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> dataSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;载入数据流就是读取弹幕数据文件流，然后转成字符串，最后保存到一个JSONArray变量里存起来。<br>&#160; &#160; &#160; &#160;继续往下分析创建弹幕解析器、取出数据源、解析器放入数据源：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AcFunDanmakuParser的load方法，将上一步得到的JSONSource放入到AcFunDanmakuParser中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BaseDanmakuParser <span class="title">load</span><span class="params">(IDataSource&lt;?&gt; source)</span> </span>&#123;</span><br><span class="line">      mDataSource = source;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;到这里数据就载入到解析器里了，parser里有弹幕源数据了。</p>
<h2 id="启动弹幕"><a href="#启动弹幕" class="headerlink" title="启动弹幕"></a>启动弹幕</h2><p>&#160; &#160; &#160; &#160;启动弹幕重要的就是这一句：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mDanmakuView.prepare(mParser, mContext);</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;此时mParser和mContext都已经初始化完成。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(BaseDanmakuParser parser, DanmakuContext config)</span> </span>&#123;</span><br><span class="line">     prepare();<span class="comment">///创建一个 DrawHandler</span></span><br><span class="line">     handler.setConfig(config);</span><br><span class="line">     handler.setParser(parser);</span><br><span class="line">     handler.setCallback(mCallback);</span><br><span class="line">     handler.prepare();<span class="comment">//然后调用DrawHandler的prepare方法</span></span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//创建一个 DrawHandler</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (handler == <span class="keyword">null</span>)</span><br><span class="line">         handler = <span class="keyword">new</span> DrawHandler(getLooper(mDrawingThreadType), <span class="keyword">this</span>, mDanmakuVisible);<span class="comment">//mDanmakuVisible为true</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;设置一些全局变量后，会调用DrawHandler的prepare方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sendEmptyMessage(DrawHandler.PREPARE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> what = msg.what;</span><br><span class="line">    <span class="keyword">switch</span> (what) &#123;</span><br><span class="line">        <span class="keyword">case</span> PREPARE:</span><br><span class="line">            mTimeBase = SystemClock.uptimeMillis();</span><br><span class="line">            <span class="keyword">if</span> (mParser == <span class="keyword">null</span> || !mDanmakuView.isViewReady()) &#123;<span class="comment">// false || false</span></span><br><span class="line">                sendEmptyMessageDelayed(PREPARE, <span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                prepare(<span class="keyword">new</span> Runnable() &#123;<span class="comment">//会继续调用prepare重载方法</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        pausedPosition = <span class="number">0</span>;</span><br><span class="line">                        mReady = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            mCallback.prepared();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            ......</span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> DanmakuTimer timer = <span class="keyword">new</span> DanmakuTimer();<span class="comment">//已经初始化timer</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">final</span> Runnable runnable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (drawTask == <span class="keyword">null</span>) &#123;<span class="comment">//会继续调用createDrawTask方法</span></span><br><span class="line">        drawTask = createDrawTask(mDanmakuView.isDanmakuDrawingCacheEnabled(), timer,</span><br><span class="line">                mDanmakuView.getContext(), mDanmakuView.getWidth(), mDanmakuView.getHeight(),</span><br><span class="line">                mDanmakuView.isHardwareAccelerated(), <span class="keyword">new</span> IDrawTask.TaskListener() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ready</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        initRenderingConfigs();</span><br><span class="line">                        runnable.run();</span><br><span class="line">                    &#125;</span><br><span class="line">		......</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        runnable.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继续调用createDrawTask(true, timer, context, width, height, true, listener)方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> IDrawTask <span class="title">createDrawTask</span><span class="params">(<span class="keyword">boolean</span> useDrwaingCache, DanmakuTimer timer,</span><br><span class="line">                                 Context context,</span><br><span class="line">                                 <span class="keyword">int</span> width, <span class="keyword">int</span> height,</span><br><span class="line">                                 <span class="keyword">boolean</span> isHardwareAccelerated,</span><br><span class="line">                                 IDrawTask.TaskListener taskListener)</span> </span>&#123;</span><br><span class="line">    mDisp = mContext.getDisplayer();<span class="comment">//AndroidDisplayer赋给它，顾名思义，Displayer就是显示器</span></span><br><span class="line">    mDisp.setSize(width, height);<span class="comment">//设置弹幕视图宽高</span></span><br><span class="line">    DisplayMetrics displayMetrics = context.getResources().getDisplayMetrics();</span><br><span class="line">    mDisp.setDensities(displayMetrics.density, displayMetrics.densityDpi,</span><br><span class="line">            displayMetrics.scaledDensity);<span class="comment">//设置密度先关</span></span><br><span class="line">    mDisp.resetSlopPixel(mContext.scaleTextSize);<span class="comment">//设置字体缩放比例，之前设过了1.2</span></span><br><span class="line">    mDisp.setHardwareAccelerated(isHardwareAccelerated);<span class="comment">//硬件加速，true</span></span><br><span class="line">    <span class="comment">//useDrwaingCache 为true</span></span><br><span class="line">    IDrawTask task = useDrwaingCache ?</span><br><span class="line">            <span class="keyword">new</span> CacheManagingDrawTask(timer, mContext, taskListener, <span class="number">1024</span> * <span class="number">1024</span> * AndroidUtils.getMemoryClass(context) / <span class="number">3</span>)</span><br><span class="line">            : <span class="keyword">new</span> DrawTask(timer, mContext, taskListener);</span><br><span class="line">    task.setParser(mParser);<span class="comment">//把存放数据源的mParser放入CacheManagingDrawTask中</span></span><br><span class="line">    task.prepare();<span class="comment">//这个才是重点，调用CacheManagingDrawTask的prepare方法</span></span><br><span class="line">    obtainMessage(NOTIFY_DISP_SIZE_CHANGED, <span class="keyword">false</span>).sendToTarget();</span><br><span class="line">    <span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;上述过程最后一个调用了createDrawTask方法，这里先初始化了一下AndroidDisplayer配置，就把他当做显示器吧，我猜<code>ctiao</code>当初设计时也是这么比喻的吧。<br>&#160; &#160; &#160; &#160;设置好弹幕显示相关的参数，然后就是创建绘制任务IDrawTask 了。这里有两个选择，如果使用缓存就创建CacheManagingDrawTask，不使用就创建DrawTask。不过CacheManagingDrawTask比DrawTask复杂很多。</p>
<h3 id="CacheManagingDrawTask绘制任务"><a href="#CacheManagingDrawTask绘制任务" class="headerlink" title="CacheManagingDrawTask绘制任务"></a>CacheManagingDrawTask绘制任务</h3><p>&#160; &#160; &#160; &#160;我们的useDrwaingCache为true（<code>其实把它改为false也没关系，并且这样就用不上那些so库了</code>），则创建CacheManagingDrawTask绘制任务，然后调用prepare方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CacheManagingDrawTask</span><span class="params">(DanmakuTimer timer, DanmakuContext config, TaskListener taskListener, <span class="keyword">int</span> maxCacheSize)</span> </span>&#123;<span class="comment">//传入定时器timer，config，listener，还有三分一应用分配内存大小的maxCacheSize</span></span><br><span class="line">      <span class="keyword">super</span>(timer, config, taskListener);<span class="comment">//会调用父类DrawTask的构造方法</span></span><br><span class="line">      NativeBitmapFactory.loadLibs();<span class="comment">//加载so库，用于创建bitmap，同时测试时候加载成功</span></span><br><span class="line">      mMaxCacheSize = maxCacheSize;</span><br><span class="line">      <span class="keyword">if</span> (NativeBitmapFactory.isInNativeAlloc()) &#123;<span class="comment">//true,将最大内存扩大到2倍</span></span><br><span class="line">          mMaxCacheSize = maxCacheSize * <span class="number">2</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      mCacheManager = <span class="keyword">new</span> CacheManager(maxCacheSize, MAX_CACHE_SCREEN_SIZE);</span><br><span class="line">      mRenderer.setCacheManager(mCacheManager);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//看看父类的构造方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DrawTask</span><span class="params">(DanmakuTimer timer, DanmakuContext context,</span><br><span class="line">          TaskListener taskListener)</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line">      mContext = context;</span><br><span class="line">      mDisp = context.getDisplayer();</span><br><span class="line">      mTaskListener = taskListener;</span><br><span class="line">      mRenderer = <span class="keyword">new</span> DanmakuRenderer(context);</span><br><span class="line">......</span><br><span class="line">      initTimer(timer);<span class="comment">//初始化相关定时器</span></span><br><span class="line">......</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initTimer</span><span class="params">(DanmakuTimer timer)</span> </span>&#123;</span><br><span class="line">      mTimer = timer;</span><br><span class="line">      mCacheTimer = <span class="keyword">new</span> DanmakuTimer();</span><br><span class="line">      mCacheTimer.update(timer.currMillisecond);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;CacheManagingDrawTask的构造方法设置了一些变量。其中NativeBitmapFactory.loadLibs()加载了用于创建bitmap的so文件，就是用skia图形处理库直接创建bitmap，Android对2D图形处理采用的就是skia，3D图形处理用的是OpenGL ES。这样通过native层创建bitmap直接跳过Dalvik，毕竟java层内存用多了很容易oom。因为以前我就对native层比较感兴趣，所以我要任性的跟一遍源码 ^O.O^。为了怕跟完后自己晕了，找不到现在分析的地方了，所以在这里打个标签，mark一下。如不感兴趣，可以跳过= 。=<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/DanmakuFlameMaster%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/meizi.jpg" alt="标签"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//NativeBitmapFactory</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadLibs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		......</span><br><span class="line">        System.loadLibrary(<span class="string">"ndkbitmap"</span>);<span class="comment">//载入so</span></span><br><span class="line">		......</span><br><span class="line">        <span class="comment">//测试功能</span></span><br><span class="line">        <span class="keyword">if</span> (nativeLibLoaded) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> libInit = init();<span class="comment">//这是一个native方法</span></span><br><span class="line">            <span class="keyword">if</span> (!libInit) &#123;</span><br><span class="line">                release();</span><br><span class="line">                notLoadAgain = <span class="keyword">true</span>;</span><br><span class="line">                nativeLibLoaded = <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//初始化成功后</span></span><br><span class="line">                initField();<span class="comment">//反射Bitmap.Config的nativeInt字段</span></span><br><span class="line">                <span class="keyword">boolean</span> confirm = testLib();<span class="comment">//测试例子</span></span><br><span class="line">  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Log.e(<span class="string">"NativeBitmapFactory"</span>, <span class="string">"loaded"</span> + nativeLibLoaded);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//反射Bitmap.Config的nativeInt字段</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initField</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            nativeIntField = Bitmap.Config.class.getDeclaredField(<span class="string">"nativeInt"</span>);</span><br><span class="line">            nativeIntField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">            nativeIntField = <span class="keyword">null</span>;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">init</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这里会调用测试方法testLib：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">testLib</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (nativeIntField == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     Bitmap bitmap = <span class="keyword">null</span>;</span><br><span class="line">     Canvas canvas = <span class="keyword">null</span>;</span><br><span class="line">     ......</span><br><span class="line">      <span class="comment">//用native方法创建一个bitmap</span></span><br><span class="line">         bitmap = createNativeBitmap(<span class="number">2</span>, <span class="number">2</span>, Bitmap.Config.ARGB_8888, <span class="keyword">true</span>);</span><br><span class="line">         <span class="keyword">boolean</span> result = (bitmap != <span class="keyword">null</span> &amp;&amp; bitmap.getWidth() == <span class="number">2</span> &amp;&amp; bitmap.getHeight() == <span class="number">2</span>);</span><br><span class="line">......</span><br><span class="line">             canvas = <span class="keyword">new</span> Canvas(bitmap);</span><br><span class="line">             Paint paint = <span class="keyword">new</span> Paint();</span><br><span class="line">             paint.setColor(Color.RED);</span><br><span class="line">             paint.setTextSize(<span class="number">20f</span>);</span><br><span class="line">             canvas.drawRect(<span class="number">0f</span>, <span class="number">0f</span>, (<span class="keyword">float</span>) bitmap.getWidth(), (<span class="keyword">float</span>) bitmap.getHeight(),</span><br><span class="line">                     paint);</span><br><span class="line">             canvas.drawText(<span class="string">"TestLib"</span>, <span class="number">0</span>, <span class="number">0</span>, paint);</span><br><span class="line"></span><br><span class="line">   ......</span><br><span class="line">         <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Bitmap <span class="title">createNativeBitmap</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height, Config config, <span class="keyword">boolean</span> hasAlpha)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> nativeConfig = getNativeConfig(config);<span class="comment">//反射设置Bitmap.Config.ARGB_8888</span></span><br><span class="line">     <span class="keyword">return</span> android.os.Build.VERSION.SDK_INT == <span class="number">19</span> ? createBitmap19(width, height,</span><br><span class="line">             nativeConfig, hasAlpha) : createBitmap(width, height, nativeConfig, hasAlpha);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNativeConfig</span><span class="params">(Bitmap.Config config)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (nativeIntField == <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> nativeIntField.getInt(config);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">     &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> Bitmap <span class="title">createBitmap</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height, <span class="keyword">int</span> nativeConfig,</span><br><span class="line">         <span class="keyword">boolean</span> hasAlpha)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> Bitmap <span class="title">createBitmap19</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height, <span class="keyword">int</span> nativeConfig,</span><br><span class="line">         <span class="keyword">boolean</span> hasAlpha)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;上述最终用native方法创建bitmap，C++文件地址为 <a href="https://github.com/Bilibili/NativeBitmapFactory" target="_blank" rel="external">https://github.com/Bilibili/NativeBitmapFactory</a> ，接着继续查看native方法具体实现NativeBitmapFactory.cpp。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先看java层init方法对应的本地方法</span></span><br><span class="line"><span class="function">jboolean <span class="title">Java_tv_cjump_jni_NativeBitmapFactory_init</span><span class="params">(JNIEnv *env)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	......</span><br><span class="line">	<span class="comment">//继续看Start方法</span></span><br><span class="line">    <span class="keyword">int</span> r = Start();</span><br><span class="line">    <span class="keyword">return</span> r == SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Start</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">//创建一个类型为ndkbitmap_obj 的结构体指针</span></span><br><span class="line">    ndkbitmap_obj = (<span class="keyword">ndkbitmap_object_t</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*ndkbitmap_obj));</span><br><span class="line">    <span class="keyword">int</span> r = Open(ndkbitmap_obj);</span><br><span class="line">	......</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Open</span><span class="params">(<span class="keyword">ndkbitmap_object_t</span> *obj)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">//创建一个类型为skbitmap_sys_t 的结构体指针</span></span><br><span class="line">    <span class="keyword">skbitmap_sys_t</span> *sys = (<span class="keyword">skbitmap_sys_t</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (*sys));</span><br><span class="line">	......</span><br><span class="line">	<span class="comment">//打开libskia.so动态链接库，初始化一些参数并返回动态链接库的句柄</span></span><br><span class="line">    sys-&gt;libskia = InitLibrary(sys);</span><br><span class="line">	......</span><br><span class="line">	<span class="comment">//打开libandroid_runtime.so动态链接库，初始化一些参数并返回动态链接库的句柄</span></span><br><span class="line">    sys-&gt;libjnigraphics = InitLibrary2(sys);</span><br><span class="line">	......</span><br><span class="line">	<span class="comment">//将初始化过后的结构指针sys赋给结构体obj的sys成员</span></span><br><span class="line">    obj-&gt;sys = sys;</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;init方法主要是打开和skia相关的动态链接库，并初始化一些配置。(InitLibrary和InitLibrary2方法的细节我没有贴，里面实现需要一些专业知识，有兴趣的可以找资料钻研)然后就是createBitmap：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">jobject <span class="title">Java_tv_cjump_jni_NativeBitmapFactory_createBitmap</span><span class="params">(JNIEnv *env , jobject  obj, jint w, jint h, jint config, jboolean hasAlpha)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> createBitmap(env, obj, w, h, config, hasAlpha, <span class="keyword">true</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">jobject <span class="title">Java_tv_cjump_jni_NativeBitmapFactory_createBitmap19</span><span class="params">(JNIEnv *env , jobject  obj, jint w, jint h, jint config, jboolean hasAlpha)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> createBitmap(env, obj, w, h, config, hasAlpha, <span class="number">0x3</span>, <span class="number">19</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">jobject <span class="title">createBitmap</span><span class="params">(JNIEnv *env , jobject  obj, jint w, jint h, jint config, jboolean hasAlpha, <span class="keyword">int</span> isMuttable, <span class="keyword">int</span> api)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *bm = createSkBitmap(ndkbitmap_obj, config, w, h);<span class="comment">//调用重载方法创建bitmap指针</span></span><br><span class="line">    <span class="keyword">if</span> (bm == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    jobject result = NULL;</span><br><span class="line">    skbitmap_sys_t *p_sys = ndkbitmap_obj-&gt;sys;</span><br><span class="line">    <span class="keyword">if</span>(p_sys-&gt;libjnigraphics) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p_sys-&gt;gjni_createBitmap) </span><br><span class="line">        &#123;<span class="comment">//SDK版本小于19</span></span><br><span class="line">	        <span class="comment">//通过这个函数指针把JNI层bitmap的转换对象return给java层</span></span><br><span class="line">            result = p_sys-&gt;gjni_createBitmap(env, bm, isMuttable, NULL, -<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(p_sys-&gt;gjni_createBitmap_19later) &#123;<span class="comment">//SDK版本19以后返回值</span></span><br><span class="line">            result = p_sys-&gt;gjni_createBitmap_19later(env, bm, NULL, isMuttable, NULL, NULL, -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建bitmap指针，并通过相关指针函数设置bitmap参数</span></span><br><span class="line">inline <span class="keyword">void</span> *createSkBitmap(ndkbitmap_object_t *obj, <span class="keyword">int</span> config, <span class="keyword">int</span> w, <span class="keyword">int</span> h)</span><br><span class="line">&#123;</span><br><span class="line">    skbitmap_sys_t *p_sys = obj-&gt;sys;</span><br><span class="line">    <span class="keyword">if</span> (p_sys == NULL || p_sys-&gt;libskia == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//申请内存，创建skBitmap 指针</span></span><br><span class="line">    <span class="keyword">void</span> *skBitmap = malloc(SIZE_OF_SKBITMAP);</span><br><span class="line">    <span class="keyword">if</span> (!skBitmap)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    *((uint32_t *) ((uint32_t)skBitmap + SIZE_OF_SKBITMAP - <span class="number">4</span>)) = <span class="number">0xbaadbaad</span>;</span><br><span class="line">    <span class="comment">//ctor   </span></span><br><span class="line">    p_sys-&gt;sk_ctor(skBitmap);</span><br><span class="line">    <span class="keyword">if</span> (p_sys-&gt;sk_setConfig)</span><br><span class="line">    &#123;</span><br><span class="line">        p_sys-&gt;sk_setConfig(skBitmap, config, w, h, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (p_sys-&gt;sk_setConfig_19later)</span><br><span class="line">    &#123;</span><br><span class="line">        p_sys-&gt;sk_setConfig_19later(skBitmap, config, w, h, <span class="number">0</span>, (uint8_t)kPremul_SkAlphaType);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p_sys-&gt;sk_setInfo) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> imageInfo[<span class="number">4</span>] = &#123;w, h, SkBitmapConfigToColorType(config), kPremul_SkAlphaType&#125;;</span><br><span class="line">        p_sys-&gt;sk_setInfo(skBitmap, imageInfo, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    p_sys-&gt;sk_allocPixels(skBitmap, NULL, NULL);</span><br><span class="line">    p_sys-&gt;sk_eraseARGB(skBitmap, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(*((uint32_t *) ((uint32_t)skBitmap + SIZE_OF_SKBITMAP - <span class="number">4</span>)) == <span class="number">0xbaadbaad</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">        free(skBitmap);</span><br><span class="line">        <span class="keyword">return</span> NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> skBitmap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;通过skia图形库创建bitmap流程大概就是这些，其实skia的东西也是巨多无比，如果是从事这一方面工作应该都轻车熟路，我是完全的小白，能力有限，只能先到这儿。</p>
<p>&#160; &#160; &#160; &#160;好了，继续回到上次打标签的地方。接着该调用CacheManagingDrawTask的prepare方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> (mParser != <span class="keyword">null</span>);</span><br><span class="line">    loadDanmakus(mParser);</span><br><span class="line">    mCacheManager.begin();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;先调用loadDanmakus方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> IDanmakus danmakuList;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadDanmakus</span><span class="params">(BaseDanmakuParser parser)</span> </span>&#123;</span><br><span class="line">        danmakuList = parser.setConfig(mContext)</span><br><span class="line">                            .setDisplayer(mDisp)</span><br><span class="line">                            .setTimer(mTimer)</span><br><span class="line">                            .getDanmakus();<span class="comment">//从parser中取出弹幕数据,做出相关处理</span></span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(danmakuList != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mLastDanmaku = danmakuList.last();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;parser设置完DanmakuContext，AndroidDisplayer，DanmakuTimer之后，再调用getDanmakus取出弹幕信息：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> IDanmakus <span class="title">getDanmakus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mDanmakus != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> mDanmakus;</span><br><span class="line">    mContext.mDanmakuFactory.resetDurationsData();<span class="comment">//重庆内置一些变量为null</span></span><br><span class="line">    mDanmakus = parse();<span class="comment">//解析弹幕</span></span><br><span class="line">    releaseDataSource();<span class="comment">//关闭JSONSource</span></span><br><span class="line">    mContext.mDanmakuFactory.updateMaxDanmakuDuration();<span class="comment">//修正弹幕最大时长</span></span><br><span class="line">    <span class="keyword">return</span> mDanmakus;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;进入AcFunDanmakuParser的parse方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> Danmakus <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mDataSource != <span class="keyword">null</span> &amp;&amp; mDataSource <span class="keyword">instanceof</span> JSONSource) &#123;</span><br><span class="line">            JSONSource jsonSource = (JSONSource) mDataSource;</span><br><span class="line">            <span class="keyword">return</span> doParse(jsonSource.data());<span class="comment">//go on</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Danmakus();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Danmakus <span class="title">doParse</span><span class="params">(JSONArray danmakuListData)</span> </span>&#123;</span><br><span class="line">        Danmakus danmakus = <span class="keyword">new</span> Danmakus();</span><br><span class="line">        <span class="keyword">if</span> (danmakuListData == <span class="keyword">null</span> || danmakuListData.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> danmakus;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; danmakuListData.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                JSONObject danmakuArray = danmakuListData.getJSONObject(i);</span><br><span class="line">                <span class="keyword">if</span> (danmakuArray != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    danmakus = _parse(danmakuArray, danmakus);<span class="comment">//解析每一条弹幕</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (JSONException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> danmakus;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">/**</span><br><span class="line">     * &#123;"c":"19.408,16777215,1,25,178252,1376325904","m":"金刚如来！"&#125;</span><br><span class="line">     // 0:时间(弹幕出现时间)</span><br><span class="line">     // 1:颜色</span><br><span class="line">     // 2:类型(1从右往左滚动弹幕|6从右至左滚动弹幕|5顶端固定弹幕|4底端固定弹幕|7高级弹幕|8脚本弹幕)</span><br><span class="line">     // 3:字号</span><br><span class="line">     // 4:用户id ?</span><br><span class="line">     // 5:时间戳 ?</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Danmakus <span class="title">_parse</span><span class="params">(JSONObject jsonObject, Danmakus danmakus)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (danmakus == <span class="keyword">null</span>) &#123;</span><br><span class="line">            danmakus = <span class="keyword">new</span> Danmakus();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (jsonObject == <span class="keyword">null</span> || jsonObject.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> danmakus;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; jsonObject.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                JSONObject obj = jsonObject;</span><br><span class="line">                String c = obj.getString(<span class="string">"c"</span>);<span class="comment">//弹幕配置信息</span></span><br><span class="line">                String[] values = c.split(<span class="string">","</span>);</span><br><span class="line">                <span class="keyword">if</span> (values.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> type = Integer.parseInt(values[<span class="number">2</span>]); <span class="comment">// 弹幕类型</span></span><br><span class="line">                    <span class="keyword">if</span> (type == <span class="number">7</span>)</span><br><span class="line">                        <span class="comment">// FIXME : hard code</span></span><br><span class="line">                        <span class="comment">// TODO : parse advance danmaku json</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">long</span> time = (<span class="keyword">long</span>) (Float.parseFloat(values[<span class="number">0</span>]) * <span class="number">1000</span>); <span class="comment">// 出现时间</span></span><br><span class="line">                    <span class="keyword">int</span> color = Integer.parseInt(values[<span class="number">1</span>]) | <span class="number">0xFF000000</span>; <span class="comment">// 颜色</span></span><br><span class="line">                    <span class="keyword">float</span> textSize = Float.parseFloat(values[<span class="number">3</span>]); <span class="comment">// 字体大小</span></span><br><span class="line">                    <span class="comment">//使用弹幕工厂创建一条弹幕</span></span><br><span class="line">                    BaseDanmaku item = mContext.mDanmakuFactory.createDanmaku(type, mContext);</span><br><span class="line">                    <span class="keyword">if</span> (item != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        item.time = time;</span><br><span class="line">                        item.textSize = textSize * (mDispDensity - <span class="number">0.6f</span>);</span><br><span class="line">                        item.textColor = color;</span><br><span class="line">                        item.textShadowColor = color &lt;= Color.BLACK ? Color.WHITE : Color.BLACK;</span><br><span class="line">                        <span class="comment">//弹幕文字内容，如果多行文本会拆分内容</span></span><br><span class="line">                        DanmakuUtils.fillText(item, obj.optString(<span class="string">"m"</span>, <span class="string">"...."</span>));</span><br><span class="line">                        item.index = i;</span><br><span class="line">                        item.setTimer(mTimer);<span class="comment">//将定时器设置给每一条弹幕</span></span><br><span class="line">                        danmakus.addItem(item);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (JSONException e) &#123;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> danmakus;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//DanmakuUtilsdefillText方法，多行文本会拆分</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fillText</span><span class="params">(BaseDanmaku danmaku, CharSequence text)</span> </span>&#123;</span><br><span class="line">        danmaku.text = text;</span><br><span class="line">        <span class="comment">//如果文本没有换行符则不用拆分</span></span><br><span class="line">        <span class="keyword">if</span> (TextUtils.isEmpty(text) || !text.toString().contains(BaseDanmaku.DANMAKU_BR_CHAR)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//如果有换行符则拆分，然后将拆分的数组付给lines 属性</span></span><br><span class="line">        String[] lines = String.valueOf(danmaku.text).split(BaseDanmaku.DANMAKU_BR_CHAR, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (lines.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            danmaku.lines = lines;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;从JSONSource里解析每一条弹幕，接着我们看看弹幕工厂DanmakuFactory创建弹幕的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> BaseDanmaku <span class="title">createDanmaku</span><span class="params">(<span class="keyword">int</span> type, DanmakuContext context)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (context == <span class="keyword">null</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      sLastConfig = context;</span><br><span class="line">      sLastDisp = context.getDisplayer();</span><br><span class="line">      <span class="keyword">return</span> createDanmaku(type, sLastDisp.getWidth(), sLastDisp.getHeight(), CURRENT_DISP_SIZE_FACTOR, context.scrollSpeedFactor);<span class="comment">// go on overload method</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> BaseDanmaku <span class="title">createDanmaku</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">int</span> viewportWidth, <span class="keyword">int</span> viewportHeight,</span><br><span class="line">          <span class="keyword">float</span> viewportScale, <span class="keyword">float</span> scrollSpeedFactor)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> createDanmaku(type, (<span class="keyword">float</span>) viewportWidth, (<span class="keyword">float</span>) viewportHeight, viewportScale, scrollSpeedFactor);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> BaseDanmaku <span class="title">createDanmaku</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">float</span> viewportWidth, <span class="keyword">float</span> viewportHeight,</span><br><span class="line">          <span class="keyword">float</span> viewportSizeFactor, <span class="keyword">float</span> scrollSpeedFactor)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> oldDispWidth = CURRENT_DISP_WIDTH; <span class="comment">// 默认是0</span></span><br><span class="line">      <span class="keyword">int</span> oldDispHeight = CURRENT_DISP_HEIGHT; <span class="comment">// 默认是0</span></span><br><span class="line">      <span class="comment">//修正试图宽高，缩放比，弹幕时长</span></span><br><span class="line">      <span class="keyword">boolean</span> sizeChanged = updateViewportState(viewportWidth, viewportHeight, viewportSizeFactor);</span><br><span class="line">      <span class="comment">//滚动弹幕的Duration赋值</span></span><br><span class="line">      <span class="keyword">if</span> (MAX_Duration_Scroll_Danmaku == <span class="keyword">null</span>) &#123;</span><br><span class="line">          MAX_Duration_Scroll_Danmaku = <span class="keyword">new</span> Duration(REAL_DANMAKU_DURATION);</span><br><span class="line">          MAX_Duration_Scroll_Danmaku.setFactor(scrollSpeedFactor);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sizeChanged) &#123;</span><br><span class="line">          MAX_Duration_Scroll_Danmaku.setValue(REAL_DANMAKU_DURATION);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//固定位置弹幕的Duration赋值</span></span><br><span class="line">      <span class="keyword">if</span> (MAX_Duration_Fix_Danmaku == <span class="keyword">null</span>) &#123;</span><br><span class="line">          MAX_Duration_Fix_Danmaku = <span class="keyword">new</span> Duration(COMMON_DANMAKU_DURATION);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (sizeChanged &amp;&amp; viewportWidth &gt; <span class="number">0</span>) &#123;<span class="comment">// true &amp;&amp; true</span></span><br><span class="line">          updateMaxDanmakuDuration();<span class="comment">// 修正弹幕最长时长</span></span><br><span class="line">	......</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      BaseDanmaku instance = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// 从右往左滚动</span></span><br><span class="line">              instance = <span class="keyword">new</span> R2LDanmaku(MAX_Duration_Scroll_Danmaku);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">4</span>: <span class="comment">// 底端固定</span></span><br><span class="line">              instance = <span class="keyword">new</span> FBDanmaku(MAX_Duration_Fix_Danmaku);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">5</span>: <span class="comment">// 顶端固定</span></span><br><span class="line">              instance = <span class="keyword">new</span> FTDanmaku(MAX_Duration_Fix_Danmaku);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">6</span>: <span class="comment">// 从左往右滚动</span></span><br><span class="line">              instance = <span class="keyword">new</span> L2RDanmaku(MAX_Duration_Scroll_Danmaku);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">7</span>: <span class="comment">// 特殊弹幕</span></span><br><span class="line">              instance = <span class="keyword">new</span> SpecialDanmaku();</span><br><span class="line">              sSpecialDanmakus.addItem(instance);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//修正试图宽高，缩放比，弹幕时长</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">updateViewportState</span><span class="params">(<span class="keyword">float</span> viewportWidth, <span class="keyword">float</span> viewportHeight,</span><br><span class="line">          <span class="keyword">float</span> viewportSizeFactor)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">boolean</span> sizeChanged = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">if</span> (CURRENT_DISP_WIDTH != (<span class="keyword">int</span>) viewportWidth</span><br><span class="line">              || CURRENT_DISP_HEIGHT != (<span class="keyword">int</span>) viewportHeight</span><br><span class="line">              || CURRENT_DISP_SIZE_FACTOR != viewportSizeFactor) &#123;</span><br><span class="line">          sizeChanged = <span class="keyword">true</span>;</span><br><span class="line">          <span class="comment">//弹幕时长 t = 3800 * (1.2 * 视图宽 / 682)</span></span><br><span class="line">          REAL_DANMAKU_DURATION = (<span class="keyword">long</span>) (COMMON_DANMAKU_DURATION * (viewportSizeFactor</span><br><span class="line">                  * viewportWidth / BILI_PLAYER_WIDTH));</span><br><span class="line">          <span class="comment">// t = min(t, 9000)</span></span><br><span class="line">          REAL_DANMAKU_DURATION = Math.min(MAX_DANMAKU_DURATION_HIGH_DENSITY,</span><br><span class="line">                  REAL_DANMAKU_DURATION);</span><br><span class="line">          <span class="comment">// t = max(t, 4000)        </span></span><br><span class="line">          REAL_DANMAKU_DURATION = Math.max(MIN_DANMAKU_DURATION, REAL_DANMAKU_DURATION);</span><br><span class="line">          </span><br><span class="line">          CURRENT_DISP_WIDTH = (<span class="keyword">int</span>) viewportWidth;</span><br><span class="line">          CURRENT_DISP_HEIGHT = (<span class="keyword">int</span>) viewportHeight;</span><br><span class="line">          CURRENT_DISP_SIZE_FACTOR = viewportSizeFactor;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> sizeChanged;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//修正弹幕最长时长</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateMaxDanmakuDuration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">long</span> maxScrollDuration = (MAX_Duration_Scroll_Danmaku == <span class="keyword">null</span> ? <span class="number">0</span>: MAX_Duration_Scroll_Danmaku.value), </span><br><span class="line">            maxFixDuration = (MAX_Duration_Fix_Danmaku == <span class="keyword">null</span> ? <span class="number">0</span> : MAX_Duration_Fix_Danmaku.value), </span><br><span class="line">            maxSpecialDuration = (MAX_Duration_Special_Danmaku == <span class="keyword">null</span> ? <span class="number">0</span>: MAX_Duration_Special_Danmaku.value);</span><br><span class="line"></span><br><span class="line">      MAX_DANMAKU_DURATION = Math.max(maxScrollDuration, maxFixDuration);</span><br><span class="line">      MAX_DANMAKU_DURATION = Math.max(MAX_DANMAKU_DURATION, maxSpecialDuration);</span><br><span class="line"></span><br><span class="line">      MAX_DANMAKU_DURATION = Math.max(COMMON_DANMAKU_DURATION, MAX_DANMAKU_DURATION);</span><br><span class="line">      MAX_DANMAKU_DURATION = Math.max(REAL_DANMAKU_DURATION, MAX_DANMAKU_DURATION);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;DanmakuFactory创建弹幕主要是计算了弹幕时长，然后根据不同类型创建不同的弹幕。</p>
<p>&#160; &#160; &#160; &#160;到此CacheManagingDrawTask的loadDanmakus方法走完了。loadDanmakus方法主要从 mParser里的JSONSource解析弹幕数据源，根据不同类型的type用DanmakuFactory创建不同的Danmaku，分别计算Duration，最后存放到一个Danmakus对象里。</p>
<p>&#160; &#160; &#160; &#160; 继续回到刚才的prepare方法，往下继续执行:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">assert</span> (mParser != <span class="keyword">null</span>);</span><br><span class="line">     loadDanmakus(mParser);<span class="comment">//走完了</span></span><br><span class="line">     mCacheManager.begin();<span class="comment">//走这个</span></span><br><span class="line"> &#125;</span><br><span class="line">  <span class="comment">//CacheManager的方法</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         mEndFlag = <span class="keyword">false</span>;</span><br><span class="line">         <span class="comment">//创建一个HandlerThread用于在工作线程处理事务</span></span><br><span class="line">         <span class="keyword">if</span> (mThread == <span class="keyword">null</span>) &#123;</span><br><span class="line">             mThread = <span class="keyword">new</span> HandlerThread(<span class="string">"DFM Cache-Building Thread"</span>);</span><br><span class="line">             mThread.start();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//创建一个Handler和HandlerThread搭配用</span></span><br><span class="line">         <span class="keyword">if</span> (mHandler == <span class="keyword">null</span>)</span><br><span class="line">             mHandler = <span class="keyword">new</span> CacheHandler(mThread.getLooper());</span><br><span class="line">         mHandler.begin();<span class="comment">// 走到这里</span></span><br><span class="line">     &#125;</span><br><span class="line"><span class="comment">//HandlerThread的begin方法 </span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             sendEmptyMessage(PREPARE);</span><br><span class="line">	......</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;我们可以看到创建了一个HandlerThread，然后创建了一个CacheHandler，所以CacheHandler发送消息后，处理消息内容都是在子线程。<br>&#160; &#160; &#160; &#160;然后发送了PREPARE消息，然后就是回调handleMessage方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">     DrawingCachePoolManager mCachePoolManager = <span class="keyword">new</span> DrawingCachePoolManager();</span><br><span class="line">     <span class="comment">//创建一个缓存个数上限为800的FinitePool池</span></span><br><span class="line">        Pool&lt;DrawingCache&gt; mCachePool = Pools.finitePool(mCachePoolManager, <span class="number">800</span>);</span><br><span class="line">        <span class="comment">//Pools的finitePool方法</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Poolable&lt;T&gt;&gt; <span class="function">Pool&lt;T&gt; <span class="title">finitePool</span><span class="params">(PoolableManager&lt;T&gt; manager, <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FinitePool&lt;T&gt;(manager, limit);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//CacheHandler的handleMessage方法</span></span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">               <span class="keyword">int</span> what = msg.what;</span><br><span class="line">               <span class="keyword">switch</span> (what) &#123;</span><br><span class="line">                   <span class="keyword">case</span> PREPARE:</span><br><span class="line">                       evictAllNotInScreen();<span class="comment">//清除所有不在屏幕内的缓存，此时还没有缓存</span></span><br><span class="line">                       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">300</span>; i++) &#123;<span class="comment">//在池里放300个预留缓存，以链式存储方式存放</span></span><br><span class="line">                           mCachePool.release(<span class="keyword">new</span> DrawingCache());</span><br><span class="line">                       &#125;</span><br><span class="line"></span><br><span class="line">			......</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//FinitePool的release方法：回收缓存对象，并且用头插法，以链式存储（类似链表）	</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(T element)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (!element.isPooled()) &#123;</span><br><span class="line">           <span class="keyword">if</span> (mInfinite || mPoolCount &lt; mLimit) &#123;</span><br><span class="line">               mPoolCount++;</span><br><span class="line">               element.setNextPoolable(mRoot);</span><br><span class="line">               element.setPooled(<span class="keyword">true</span>);</span><br><span class="line">               mRoot = element;</span><br><span class="line">           &#125;</span><br><span class="line">           mManager.onReleased(element);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           System.out.print(<span class="string">"[FinitePool] Element is already in pool: "</span> + element);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;处理完PREPARE消息后，会继续进入DISPATCH_ACTIONS逻辑处理中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">	......</span><br><span class="line">          <span class="keyword">case</span> DISPATCH_ACTIONS:</span><br><span class="line">              <span class="keyword">long</span> delayed = dispatchAction();<span class="comment">//走到这里</span></span><br><span class="line">              <span class="keyword">if</span> (delayed &lt;= <span class="number">0</span>) &#123;<span class="comment">// true</span></span><br><span class="line">               <span class="comment">//会没隔半条弹幕时间发送一次DISPATCH_ACTIONS消息</span></span><br><span class="line">                  delayed = mContext.mDanmakuFactory.MAX_DANMAKU_DURATION / <span class="number">2</span>;</span><br><span class="line">              &#125;</span><br><span class="line">           sendEmptyMessageDelayed(DISPATCH_ACTIONS, delayed);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          ......</span><br><span class="line">    <span class="comment">/*----------dispatchAction方法START----------*/</span>        </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">dispatchAction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">...省略一些第一次不会执行的逻辑...</span><br><span class="line">            </span><br><span class="line">            removeMessages(BUILD_CACHES);</span><br><span class="line">            sendEmptyMessage(BUILD_CACHES);<span class="comment">//发送BUILD_CACHES消息</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*----------dispatchAction方法END----------*/</span></span><br><span class="line">          ......</span><br><span class="line">                <span class="keyword">case</span> BUILD_CACHES:</span><br><span class="line">                    removeMessages(BUILD_CACHES);</span><br><span class="line">                    <span class="keyword">boolean</span> repositioned = ((mTaskListener != <span class="keyword">null</span> </span><br><span class="line">                    &amp;&amp; mReadyState == <span class="keyword">false</span>) || mSeekedFlag);<span class="comment">// 为true</span></span><br><span class="line">                    prepareCaches(repositioned);<span class="comment">//调用prepareCaches方法</span></span><br><span class="line">                    <span class="keyword">if</span> (repositioned)</span><br><span class="line">                        mSeekedFlag = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (mTaskListener != <span class="keyword">null</span> &amp;&amp; mReadyState == <span class="keyword">false</span>) &#123;</span><br><span class="line">                        mTaskListener.ready();<span class="comment">//然后回到mTaskListener监听ready方法</span></span><br><span class="line">                        mReadyState = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                ......</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;我们发现，处理接着处理DISPATCH_ACTIONS消息时，会每隔半条弹幕时间发送一次DISPATCH_ACTIONS消息。<br>&#160; &#160; &#160; &#160;处理DISPATCH_ACTIONS消息内会执行dispatchAction方法，这个方法内逻辑情况比较多，我们先挖个坑，先把刚开始时会走的逻辑执行了，其他逻辑以后用时会填上。（挖坑 ^O_O^）<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/DanmakuFlameMaster%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/wakeng.jpg" alt="挖坑"><br>&#160; &#160; &#160; &#160;首次调用dispatchAction方法内发送了BUILD_CACHES消息消息，会先调用prepareCaches(true)方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">prepareCaches</span><span class="params">(<span class="keyword">boolean</span> repositioned)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">long</span> curr = mCacheTimer.currMillisecond;<span class="comment">// 0</span></span><br><span class="line">                <span class="comment">//3条弹幕时间</span></span><br><span class="line">                <span class="keyword">long</span> end = curr + mContext.mDanmakuFactory.MAX_DANMAKU_DURATION * mScreenSize;</span><br><span class="line">                <span class="keyword">if</span> (end &lt; mTimer.currMillisecond) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">long</span> startTime = SystemClock.uptimeMillis();</span><br><span class="line">                IDanmakus danmakus = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">int</span> tryCount = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">boolean</span> hasException = <span class="keyword">false</span>;</span><br><span class="line">                do &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">	                    <span class="comment">//截取三条弹幕时间中所有的弹幕</span></span><br><span class="line">                        danmakus = danmakuList.subnew(curr, end);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        hasException = <span class="keyword">true</span>;</span><br><span class="line">                        SystemClock.sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">while</span> (++tryCount &lt; <span class="number">3</span> &amp;&amp; danmakus == <span class="keyword">null</span> &amp;&amp; hasException);<span class="comment">//截取成功后跳出循环</span></span><br><span class="line">                <span class="keyword">if</span> (danmakus == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mCacheTimer.update(end);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">				......</span><br><span class="line">                IDanmakuIterator itr = danmakus.iterator();</span><br><span class="line">                BaseDanmaku item = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">int</span> sizeInScreen = danmakus.size();</span><br><span class="line">                <span class="keyword">while</span> (!mPause &amp;&amp; !mCancelFlag) &#123;<span class="comment">//</span></span><br><span class="line">                    <span class="keyword">boolean</span> hasNext = itr.hasNext();</span><br><span class="line">                    <span class="keyword">if</span> (!hasNext) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    item = itr.next();</span><br><span class="line"></span><br><span class="line">					 ......</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// build cache ，省略了一些障眼法,这才是重点，建立缓存</span></span><br><span class="line">                    <span class="keyword">if</span> (buildCache(item, <span class="keyword">false</span>) == RESULT_FAILED) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">					......</span><br><span class="line">                &#125;</span><br><span class="line">                ......</span><br><span class="line">                <span class="keyword">if</span> (item != <span class="keyword">null</span>) &#123;<span class="comment">//截取的最后一条弹幕,更新缓存定时器时间</span></span><br><span class="line">                    mCacheTimer.update(item.time);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mCacheTimer.update(end);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> consumingTime;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;为截取的每一条弹幕建立缓存会调用buildCache(item, false)方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">       <span class="function"><span class="keyword">private</span> <span class="keyword">byte</span> <span class="title">buildCache</span><span class="params">(BaseDanmaku item, <span class="keyword">boolean</span> forceInsert)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// measure ,先测量每一条弹幕的宽高</span></span><br><span class="line">           <span class="keyword">if</span> (!item.isMeasured()) &#123;</span><br><span class="line">               item.measure(mDisp, <span class="keyword">true</span>);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           DrawingCache cache = <span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// try to find reuseable cache, 在mCaches缓存的20条内查找和目标弹幕样式完全一样的弹幕(文字、大小、边框、下划线、颜色完全相同)</span></span><br><span class="line">               BaseDanmaku danmaku = findReuseableCache(item, <span class="keyword">true</span>, <span class="number">20</span>);</span><br><span class="line">               <span class="keyword">if</span> (danmaku != <span class="keyword">null</span>) &#123;<span class="comment">//如果查找出了这样的弹幕</span></span><br><span class="line">                   cache = (DrawingCache) danmaku.cache;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;<span class="comment">//如果找到的弹幕有缓存</span></span><br><span class="line">                   cache.increaseReference();<span class="comment">//则将引用计数 +1</span></span><br><span class="line">                   item.cache = cache;<span class="comment">//将目标弹幕缓存的引用指向查找出来的弹幕缓存，即多个引用指向同一个对象</span></span><br><span class="line">                   <span class="comment">//将这个目标弹幕的引用放入缓存Danmakus中(mCaches)，同时更新已使用大小mRealSize</span></span><br><span class="line">                   mCacheManager.push(item, <span class="number">0</span>, forceInsert);</span><br><span class="line">                   <span class="keyword">return</span> RESULT_SUCCESS;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// try to find reuseable cache from timeout || no-refrerence caches</span></span><br><span class="line">               <span class="comment">//如果上述的查找样式完全相同的弹幕没有找到，则在前50条缓存中查找对比当前时间已经过时的</span></span><br><span class="line">               <span class="comment">//，没有被重复引用的(只有上面那种情况才会增加引用计数，其他情况都不会)</span></span><br><span class="line">               <span class="comment">//，而且宽高和目标弹幕差值在规定范围内的弹幕</span></span><br><span class="line">               danmaku = findReuseableCache(item, <span class="keyword">false</span>, <span class="number">50</span>);</span><br><span class="line">               <span class="keyword">if</span> (danmaku != <span class="keyword">null</span>) &#123;<span class="comment">// 如果找到了这样的弹幕</span></span><br><span class="line">                   cache = (DrawingCache) danmaku.cache;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;<span class="comment">//如果找到的弹幕有缓存</span></span><br><span class="line">                   danmaku.cache = <span class="keyword">null</span>;<span class="comment">//先清除过时弹幕的缓存</span></span><br><span class="line">                   <span class="comment">//再根据目标弹幕样式，重新设置缓存(为每条弹幕创建一个bitmap和canvas，然后画出边框、下划线、文字等等)</span></span><br><span class="line">                   cache = DanmakuUtils.buildDanmakuDrawingCache(item, mDisp, cache);  <span class="comment">//redraw</span></span><br><span class="line">                   item.cache = cache;<span class="comment">//将缓存应用赋给目标弹幕</span></span><br><span class="line">                   mCacheManager.push(item, <span class="number">0</span>, forceInsert);<span class="comment">//将这个目标弹幕的引用放入缓存Danmakus中(mCaches)，同时更新已使用大小mRealSize</span></span><br><span class="line">                   <span class="keyword">return</span> RESULT_SUCCESS;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果上述两次查找缓存都没找到，则进入下面逻辑</span></span><br><span class="line">               <span class="comment">// guess cache size</span></span><br><span class="line">               <span class="keyword">if</span> (!forceInsert) &#123;<span class="comment">//如果forceInsert为false，则表示不检测内存超出</span></span><br><span class="line">                <span class="comment">//计算此弹幕bitmap的大小，width * height * 4</span></span><br><span class="line">                <span class="comment">//(因为用native创建的Bitmap的Config为ARGB_8888，所以一个像素占4个字节)</span></span><br><span class="line">                   <span class="keyword">int</span> cacheSize = DanmakuUtils.getCacheSize((<span class="keyword">int</span>) item.paintWidth,</span><br><span class="line">                           (<span class="keyword">int</span>) item.paintHeight);</span><br><span class="line">                   <span class="comment">//如果当前已经使用大小 + 此弹幕缓存大小 &gt; 设置的最大内存（2/3 应用内存）        </span></span><br><span class="line">                   <span class="keyword">if</span> (mRealSize + cacheSize &gt; mMaxSize) &#123;<span class="comment">//没有超</span></span><br><span class="line">                       <span class="keyword">return</span> RESULT_FAILED;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"><span class="comment">//从FinitePool中的300个DrawingCache对象中取出来一个</span></span><br><span class="line">               cache = mCachePool.acquire();</span><br><span class="line">               <span class="comment">//如果从上面的FinitePool取完了，则会直接new一个DrawingCache，配置DrawingCache</span></span><br><span class="line">               cache = DanmakuUtils.buildDanmakuDrawingCache(item, mDisp, cache);</span><br><span class="line">               item.cache = cache;</span><br><span class="line">               <span class="comment">//将item存入mCaches缓存，同时更新已使用大小mRealSize</span></span><br><span class="line">               <span class="keyword">boolean</span> pushed = mCacheManager.push(item, sizeOf(item), forceInsert);</span><br><span class="line">               <span class="keyword">if</span> (!pushed) &#123;<span class="comment">//如果item存放失败(使用内存超出规定大小)</span></span><br><span class="line">                   releaseDanmakuCache(item, cache);<span class="comment">//释放DrawingCache</span></span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">return</span> pushed ? RESULT_SUCCESS : RESULT_FAILED;</span><br><span class="line"></span><br><span class="line">           &#125; <span class="keyword">catch</span> (OutOfMemoryError e) &#123;</span><br><span class="line">               releaseDanmakuCache(item, cache);</span><br><span class="line">               <span class="keyword">return</span> RESULT_FAILED;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">               releaseDanmakuCache(item, cache);</span><br><span class="line">               <span class="keyword">return</span> RESULT_FAILED;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;buildCache(item, false)为每一条弹幕建立缓存，其中有几处：</p>
<ul>
<li>先测量弹幕的宽高</li>
<li>在mCaches缓存的20条内查找和目标弹幕样式完全一样的弹幕(文字、大小、边框、下划线、颜色完全相同)</li>
<li>如果上述的查找样式完全相同的弹幕没有找到，则在前50条缓存中查找对比当前时间已经过时的 ，没有被重复引用的(只有上面那种情况才会增加引用计数，其他情况都不会)，而且宽高和目标弹幕差值在规定范围内的弹幕，再根据目标弹幕样式，重新设置缓存(为每条弹幕创建一个bitmap和canvas，然后画出边框、下划线、文字等等)</li>
<li>如果上述两次查找缓存都没找到，则从FinitePool中取出一个，没有就new一个，然后同上配置DrawingCache</li>
</ul>
<p>&#160; &#160; &#160; &#160;1）我们一个一个来，先测量：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//弹幕的基类都是BaseDanmaku,只有子类R2LDanmaku重写了measure方法</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//R2LDanmaku的measure方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">measure</span><span class="params">(IDisplayer displayer, <span class="keyword">boolean</span> fromWorkerThread)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.measure(displayer, fromWorkerThread);<span class="comment">//调用了父类的方法</span></span><br><span class="line">        mDistance = (<span class="keyword">int</span>) (displayer.getWidth() + paintWidth);<span class="comment">//滚动弹幕的距离都是 视图宽度+弹幕宽度，很好理解</span></span><br><span class="line">        mStepX = mDistance / (<span class="keyword">float</span>) duration.value; <span class="comment">//每秒步长就是总滚动距离除以弹幕时长</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//父类BaseDanmaku的measure方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">measure</span><span class="params">(IDisplayer displayer, <span class="keyword">boolean</span> fromWorkerThread)</span> </span>&#123;</span><br><span class="line">        displayer.measure(<span class="keyword">this</span>, fromWorkerThread);<span class="comment">//AndroidDisplayer的measure方法</span></span><br><span class="line">        <span class="keyword">this</span>.measureResetFlag = flags.MEASURE_RESET_FLAG;<span class="comment">//设置已经测量过了的标签</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;接着会调用AndroidDisplayer的measure方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">measure</span><span class="params">(BaseDanmaku danmaku, <span class="keyword">boolean</span> fromWorkerThread)</span> </span>&#123;</span><br><span class="line">	...设置画笔style,color,alpha,省略...</span><br><span class="line">       calcPaintWH(danmaku, paint, fromWorkerThread);<span class="comment">//计算宽高</span></span><br><span class="line">	...设置画笔style,color,alpha,省略...</span><br><span class="line">   &#125;</span><br><span class="line"><span class="keyword">private</span> BaseCacheStuffer sStuffer = <span class="keyword">new</span> SimpleTextCacheStuffer();<span class="comment">//默认是SimpleTextCacheStuffer</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">calcPaintWH</span><span class="params">(BaseDanmaku danmaku, TextPaint paint, <span class="keyword">boolean</span> fromWorkerThread)</span> </span>&#123;</span><br><span class="line">       sStuffer.measure(danmaku, paint, fromWorkerThread);<span class="comment">//sStuffer就是我们在MainActivity里配置DanmakuContext时设置的，默认是SimpleTextCacheStuffer</span></span><br><span class="line">       </span><br><span class="line">       ...加上描边，padding等额外值，省略...</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;还记得在MainActivity里配置DanmakuContext吗？当时是这么写的：<br>                .setCacheStuffer(new SpannedCacheStuffer(), mCacheStufferAdapter) // 图文混排使用SpannedCacheStuffer<br>//              .setCacheStuffer(new BackgroundCacheStuffer())  // 绘制背景使用BackgroundCacheStuffer</p>
<p>&#160; &#160; &#160; &#160;比如SpannedCacheStuffer的measure方法是这样的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span><span class="comment">//SpannedCacheStuffer的measure方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">measure</span><span class="params">(BaseDanmaku danmaku, TextPaint paint, <span class="keyword">boolean</span> fromWorkerThread)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (danmaku.text <span class="keyword">instanceof</span> Spanned) &#123;</span><br><span class="line">          CharSequence text = danmaku.text;</span><br><span class="line">          <span class="keyword">if</span> (text != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">//可看到将弹幕的宽高，文字等信息包在了一个StaticLayout对象中，然后付给danmaku的obj对象</span></span><br><span class="line">              StaticLayout staticLayout = <span class="keyword">new</span> StaticLayout(text, paint, (<span class="keyword">int</span>) Math.ceil(StaticLayout.getDesiredWidth(danmaku.text, paint)), Layout.Alignment.ALIGN_NORMAL, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="keyword">true</span>);</span><br><span class="line">              danmaku.paintWidth = staticLayout.getWidth();</span><br><span class="line">              danmaku.paintHeight = staticLayout.getHeight();</span><br><span class="line">              danmaku.obj = <span class="keyword">new</span> SoftReference&lt;&gt;(staticLayout);</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">super</span>.measure(danmaku, paint, fromWorkerThread);<span class="comment">//如果不是图文混排类型，则调用父类SimpleTextCacheStuffer的方法</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;<strong>可以看到measure方法创建了一个StaticLayout对象，并将它的软引用赋给了danmaku的obj属性；如果是图文混排类型弹幕，则danmaku.obj不为空；如果是普通弹幕则danmaku.obj为空</strong>。<br>&#160; &#160; &#160; &#160;BackgroundCacheStuffer也差不多，都是对弹幕样式的一些改造。</p>
<p>&#160; &#160; &#160; &#160;然后我们看SimpleTextCacheStuffer的measure方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SimpleTextCacheStuffer的measure方法   </span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">measure</span><span class="params">(BaseDanmaku danmaku, TextPaint paint, <span class="keyword">boolean</span> fromWorkerThread)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (mProxy != <span class="keyword">null</span>) &#123;<span class="comment">//这个mProxy 是BaseCacheStuffer.Proxy类型的对象，也是初始化DanmakuContext调用setCacheStuffer(cacheStuffer, proxy)时设置的</span></span><br><span class="line">           mProxy.prepareDrawing(danmaku, fromWorkerThread);<span class="comment">//根据你的条件检查是否需要需要更新弹幕</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">float</span> w = <span class="number">0</span>;</span><br><span class="line">       Float textHeight = <span class="number">0f</span>;</span><br><span class="line">       <span class="keyword">if</span> (danmaku.lines == <span class="keyword">null</span>) &#123;<span class="comment">//不是多行文本</span></span><br><span class="line">           <span class="keyword">if</span> (danmaku.text == <span class="keyword">null</span>) &#123;</span><br><span class="line">               w = <span class="number">0</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               w = paint.measureText(danmaku.text.toString());<span class="comment">//测量出文字宽度</span></span><br><span class="line">               textHeight = getCacheHeight(danmaku, paint);<span class="comment">//计算出文字高度</span></span><br><span class="line">           &#125;</span><br><span class="line">           danmaku.paintWidth = w;</span><br><span class="line">           danmaku.paintHeight = textHeight;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果是多行文本</span></span><br><span class="line">           textHeight = getCacheHeight(danmaku, paint);<span class="comment">//计算出单行文字高度</span></span><br><span class="line">           <span class="keyword">for</span> (String tempStr : danmaku.lines) &#123;<span class="comment">//计算出多行文本总宽高</span></span><br><span class="line">               <span class="keyword">if</span> (tempStr.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                   <span class="keyword">float</span> tr = paint.measureText(tempStr);</span><br><span class="line">                   w = Math.max(tr, w);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           danmaku.paintWidth = w;</span><br><span class="line">           danmaku.paintHeight = danmaku.lines.length * textHeight;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Map&lt;Float, Float&gt; sTextHeightCache = <span class="keyword">new</span> HashMap&lt;Float, Float&gt;();<span class="comment">//key是字号大小，value是字体高度</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> Float <span class="title">getCacheHeight</span><span class="params">(BaseDanmaku danmaku, Paint paint)</span> </span>&#123;</span><br><span class="line">       Float textSize = paint.getTextSize();</span><br><span class="line">       Float textHeight = sTextHeightCache.get(textSize);</span><br><span class="line">       <span class="keyword">if</span> (textHeight == <span class="keyword">null</span>) &#123;</span><br><span class="line">           Paint.FontMetrics fontMetrics = paint.getFontMetrics();</span><br><span class="line">           <span class="comment">//Android对文字绘制有些特殊，基准点是baseline，也就是例如canvas.drawText(text, baseX, baseY, textPaint)中写入的baseY大小</span></span><br><span class="line">           <span class="comment">//Ascent是baseline之上字符最高处的y值；</span></span><br><span class="line">		<span class="comment">//Descent是baseline之下字符最低处的y值；</span></span><br><span class="line">		<span class="comment">//Leading其实是上一行字符的descent到下一行的ascent之间的距离。</span></span><br><span class="line">		<span class="comment">//所以文本高度就是descent - ascent + leading </span></span><br><span class="line">           textHeight = fontMetrics.descent - fontMetrics.ascent + fontMetrics.leading;</span><br><span class="line">           sTextHeightCache.put(textSize, textHeight);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> textHeight;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这样就计算完了每一条弹幕的宽高，完成了测量。</p>
<p>&#160; &#160; &#160; &#160;2） 在mCaches缓存的20条内查找和目标弹幕样式完全一样的弹幕(文字、大小、边框、下划线、颜色完全相同)：<br>&#160; &#160; &#160; &#160;先回到buildCache方法中这个位置。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">byte</span> <span class="title">buildCache</span><span class="params">(BaseDanmaku item, <span class="keyword">boolean</span> forceInsert)</span> </span>&#123;<span class="comment">//item, false</span></span><br><span class="line"></span><br><span class="line">	...测量已经完成...</span><br><span class="line">             DrawingCache cache = <span class="keyword">null</span>;</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 <span class="comment">// try to find reuseable cache, 在mCaches缓存的20条内查找和目标弹幕样式完全一样的弹幕(文字、大小、边框、下划线、颜色完全相同)</span></span><br><span class="line">                 BaseDanmaku danmaku = findReuseableCache(item, <span class="keyword">true</span>, <span class="number">20</span>);</span><br><span class="line">                 <span class="keyword">if</span> (danmaku != <span class="keyword">null</span>) &#123;<span class="comment">//如果查找出了这样的弹幕</span></span><br><span class="line">                     cache = (DrawingCache) danmaku.cache;</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;<span class="comment">//如果找到的弹幕有缓存</span></span><br><span class="line">                     cache.increaseReference();<span class="comment">//则将引用计数 +1</span></span><br><span class="line">                     item.cache = cache;<span class="comment">//将目标弹幕缓存的引用指向查找出来的弹幕缓存，即多个引用指向同一个对象</span></span><br><span class="line">                     <span class="comment">//将这个目标弹幕的引用放入缓存Danmakus中(mCaches)，同时更新已使用大小mRealSize</span></span><br><span class="line">                     mCacheManager.push(item, <span class="number">0</span>, forceInsert);</span><br><span class="line">                     <span class="keyword">return</span> RESULT_SUCCESS;</span><br><span class="line">                 &#125;</span><br><span class="line">             ......    </span><br><span class="line">   &#125; </span><br><span class="line">     <span class="comment">//在mCaches缓存的20条内查找和目标弹幕样式完全一样的弹幕(文字、大小、边框、下划线、颜色完全相同)             </span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> BaseDanmaku <span class="title">findReuseableCache</span><span class="params">(BaseDanmaku refDanmaku,</span><br><span class="line">                                            <span class="keyword">boolean</span> strictMode,</span><br><span class="line">                                            <span class="keyword">int</span> maximumTimes)</span> </span>&#123;<span class="comment">//item， true， 20</span></span><br><span class="line">         IDanmakuIterator it = mCaches.iterator();</span><br><span class="line">......</span><br><span class="line">         <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">while</span> (it.hasNext() &amp;&amp; count++ &lt; maximumTimes) &#123;  <span class="comment">// limit maximum times 20</span></span><br><span class="line">             BaseDanmaku danmaku = it.next();</span><br><span class="line">             IDrawingCache&lt;?&gt; cache = danmaku.getDrawingCache();</span><br><span class="line">             <span class="keyword">if</span> (cache == <span class="keyword">null</span> || cache.get() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                 <span class="keyword">continue</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">//对比mCaches中的弹幕和目标的内幕文字、大小、边框、下划线、颜色是否完全相同</span></span><br><span class="line">             <span class="keyword">if</span> (danmaku.paintWidth == refDanmaku.paintWidth</span><br><span class="line">                     &amp;&amp; danmaku.paintHeight == refDanmaku.paintHeight</span><br><span class="line">                     &amp;&amp; danmaku.underlineColor == refDanmaku.underlineColor</span><br><span class="line">                     &amp;&amp; danmaku.borderColor == refDanmaku.borderColor</span><br><span class="line">                     &amp;&amp; danmaku.textColor == refDanmaku.textColor</span><br><span class="line">                     &amp;&amp; danmaku.text.equals(refDanmaku.text)) &#123;</span><br><span class="line">                 <span class="keyword">return</span> danmaku;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span> (strictMode) &#123;<span class="comment">//true</span></span><br><span class="line">                 <span class="keyword">continue</span>;</span><br><span class="line">             &#125;</span><br><span class="line">	......</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//CacheManagingDrawTask.CacheManager的push方法</span></span><br><span class="line">     <span class="comment">//将这个目标弹幕的引用放入缓存Danmakus中(mCaches)，同时更新已使用大小mRealSize</span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">push</span><span class="params">(BaseDanmaku item, <span class="keyword">int</span> itemSize, <span class="keyword">boolean</span> forcePush)</span> </span>&#123;<span class="comment">//item，0，false</span></span><br><span class="line">         <span class="keyword">int</span> size = itemSize; <span class="comment">//0</span></span><br><span class="line">......</span><br><span class="line"><span class="comment">//这里注意mCaches是Danmakus类型，addItem方法里面实现其实是类型为TreeSet的集合去添加，如果是同一个对象，则不会添加</span></span><br><span class="line">         <span class="keyword">this</span>.mCaches.addItem(item);</span><br><span class="line">         mRealSize += size;<span class="comment">//因为已经存在相同的缓存，因此已经使用缓存总大小不再增加</span></span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> <span class="comment">//Danmakus的addItem方法</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addItem</span><span class="params">(BaseDanmaku item)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (items != <span class="keyword">null</span>) &#123;<span class="comment">//items 类型为TreeSet</span></span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="keyword">if</span> (items.add(item)) &#123;<span class="comment">//如果是相同对象，则返回false，mSize个数不会增加</span></span><br><span class="line">                 mSize++;</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;上述情况仅仅在相同样式，大小，颜色等都相同的弹幕第二次和以后的才会进入这段逻辑。对于不同的弹幕不会进入这个逻辑。（<strong>而且即使是相同弹幕，mCaches也只会存一个对象的，因为内部TreeSet的特性</strong>）<br>&#160; &#160; &#160; &#160;所以我们继续看下一种逻辑。</p>
<p>&#160; &#160; &#160; &#160;3）在前50条缓存中查找对比当前时间已经过时的 ，没有被重复引用的(只有上面那种情况才会增加引用计数，其他情况都不会)，而且宽高和目标弹幕差值在规定范围内的弹幕，再根据目标弹幕样式，重新设置缓存(为每条弹幕创建一个bitmap和canvas，然后画出边框、下划线、文字等等)：<br>&#160; &#160; &#160; &#160;继续回到buildCache方法这个位置：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">byte</span> <span class="title">buildCache</span><span class="params">(BaseDanmaku item, <span class="keyword">boolean</span> forceInsert)</span> </span>&#123;<span class="comment">//item, false</span></span><br><span class="line">		...测量过了...</span><br><span class="line">		...第一策略已经pass...</span><br><span class="line">			<span class="comment">// try to find reuseable cache from timeout || no-refrerence caches</span></span><br><span class="line">                  <span class="comment">//如果上述的查找样式完全相同的弹幕没有找到，则在前50条缓存中查找对比当前时间已经过时的</span></span><br><span class="line">                  <span class="comment">//，没有被重复引用的(只有上面那种情况才会增加引用计数，其他情况都不会)</span></span><br><span class="line">                  <span class="comment">//，而且宽高和目标弹幕差值在规定范围内的弹幕</span></span><br><span class="line">                  danmaku = findReuseableCache(item, <span class="keyword">false</span>, <span class="number">50</span>);</span><br><span class="line">                  <span class="keyword">if</span> (danmaku != <span class="keyword">null</span>) &#123;<span class="comment">// 如果找到了这样的弹幕</span></span><br><span class="line">                      cache = (DrawingCache) danmaku.cache;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;<span class="comment">//如果找到的弹幕有缓存</span></span><br><span class="line">                      danmaku.cache = <span class="keyword">null</span>;<span class="comment">//先清除过时弹幕的缓存</span></span><br><span class="line">                      <span class="comment">//再根据目标弹幕样式，重新设置缓存(为每条弹幕创建一个bitmap和canvas，然后画出边框、下划线、文字等等)</span></span><br><span class="line">                      cache = DanmakuUtils.buildDanmakuDrawingCache(item, mDisp, cache);  <span class="comment">//redraw</span></span><br><span class="line">                      item.cache = cache;<span class="comment">//将缓存应用赋给目标弹幕</span></span><br><span class="line">                      mCacheManager.push(item, <span class="number">0</span>, forceInsert);<span class="comment">//将这个目标弹幕的引用放入缓存Danmakus中(mCaches)，同时更新已使用大小mRealSize</span></span><br><span class="line">                      <span class="keyword">return</span> RESULT_SUCCESS;</span><br><span class="line">                  &#125;</span><br><span class="line">              ......    </span><br><span class="line">&#125;</span><br><span class="line">      <span class="function"><span class="keyword">private</span> BaseDanmaku <span class="title">findReuseableCache</span><span class="params">(BaseDanmaku refDanmaku,</span><br><span class="line">                                             <span class="keyword">boolean</span> strictMode,</span><br><span class="line">                                             <span class="keyword">int</span> maximumTimes)</span> </span>&#123;<span class="comment">//item,false,50</span></span><br><span class="line">          IDanmakuIterator it = mCaches.iterator();</span><br><span class="line">          <span class="keyword">int</span> slopPixel = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">if</span> (!strictMode) &#123;<span class="comment">//进入逻辑，非严苛模式</span></span><br><span class="line">              slopPixel = mDisp.getSlopPixel() * <span class="number">2</span>;<span class="comment">//允许目标弹幕与mCaches中找到的弹幕宽高偏差</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">while</span> (it.hasNext() &amp;&amp; count++ &lt; maximumTimes) &#123;  <span class="comment">// limit maximum times 20</span></span><br><span class="line">              BaseDanmaku danmaku = it.next();</span><br><span class="line">              IDrawingCache&lt;?&gt; cache = danmaku.getDrawingCache();</span><br><span class="line">              <span class="keyword">if</span> (cache == <span class="keyword">null</span> || cache.get() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  <span class="keyword">continue</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">//在这种第二策略中这段逻辑根本不会执行，因为以已经被上面的第一策略拦截了</span></span><br><span class="line">              <span class="keyword">if</span> (danmaku.paintWidth == refDanmaku.paintWidth</span><br><span class="line">                      &amp;&amp; danmaku.paintHeight == refDanmaku.paintHeight</span><br><span class="line">                      &amp;&amp; danmaku.underlineColor == refDanmaku.underlineColor</span><br><span class="line">                      &amp;&amp; danmaku.borderColor == refDanmaku.borderColor</span><br><span class="line">                      &amp;&amp; danmaku.textColor == refDanmaku.textColor</span><br><span class="line">                      &amp;&amp; danmaku.text.equals(refDanmaku.text)) &#123;</span><br><span class="line">                  <span class="keyword">return</span> danmaku;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (strictMode) &#123;<span class="comment">//false</span></span><br><span class="line">                  <span class="keyword">continue</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (!danmaku.isTimeOut()) &#123;<span class="comment">//还必须在mCaches中过时的弹幕中查找</span></span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (cache.hasReferences()) &#123;<span class="comment">//如果是相同弹幕被重新引用的，第二策略没有这样的</span></span><br><span class="line">                  <span class="keyword">continue</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">//所以会走到这里，比较mCaches中过时的弹幕和目标弹幕宽高在不在允许的偏差内，如果在就返回查找出的这个弹幕</span></span><br><span class="line">              <span class="keyword">float</span> widthGap = cache.width() - refDanmaku.paintWidth;</span><br><span class="line">              <span class="keyword">float</span> heightGap = cache.height() - refDanmaku.paintHeight;</span><br><span class="line">              <span class="keyword">if</span> (widthGap &gt;= <span class="number">0</span> &amp;&amp; widthGap &lt;= slopPixel &amp;&amp;</span><br><span class="line">                      heightGap &gt;= <span class="number">0</span> &amp;&amp; heightGap &lt;= slopPixel) &#123;</span><br><span class="line">                  <span class="keyword">return</span> danmaku;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;如果在上述第二策略中，在过时的缓存中找到了和目标弹幕宽高差不多的缓存项，则根据目标弹幕样式，重新设置缓存(为每条弹幕创建一个bitmap和canvas，然后画出边框、下划线、文字等等)，调用DanmakuUtils.buildDanmakuDrawingCache(item, mDisp, cache)方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DrawingCache <span class="title">buildDanmakuDrawingCache</span><span class="params">(BaseDanmaku danmaku, IDisplayer disp,</span><br><span class="line">          DrawingCache cache)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (cache == <span class="keyword">null</span>)</span><br><span class="line">          cache = <span class="keyword">new</span> DrawingCache();</span><br><span class="line"><span class="comment">//组建弹幕缓存(bitmap,canvas)</span></span><br><span class="line">      cache.build((<span class="keyword">int</span>) Math.ceil(danmaku.paintWidth), (<span class="keyword">int</span>) Math.ceil(danmaku.paintHeight), disp.getDensityDpi(), <span class="keyword">false</span>);</span><br><span class="line">      DrawingCacheHolder holder = cache.get();</span><br><span class="line">      <span class="keyword">if</span> (holder != <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="comment">//绘制弹幕内容</span></span><br><span class="line">          ((AbsDisplayer) disp).drawDanmaku(danmaku, holder.canvas, <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">true</span>);</span><br><span class="line">          <span class="keyword">if</span>(disp.isHardwareAccelerated()) &#123;<span class="comment">//如果有硬件加速</span></span><br><span class="line">           <span class="comment">//超过一屏的弹幕要切割</span></span><br><span class="line">              holder.splitWith(disp.getWidth(), disp.getHeight(), disp.getMaximumCacheWidth(),</span><br><span class="line">                      disp.getMaximumCacheHeight());</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> cache;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;重新设置缓存分三步：1.组建弹幕缓存,2.绘制弹幕内容,3.切割超过一屏的弹幕。</p>
<p>&#160; &#160; &#160; &#160;No.1 组建弹幕缓存：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DrawingCache的build方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> density, <span class="keyword">boolean</span> checkSizeEquals)</span> </span>&#123;<span class="comment">//checkSizeEquals为false</span></span><br><span class="line">       <span class="keyword">final</span> DrawingCacheHolder holder = mHolder;</span><br><span class="line">       <span class="comment">//每个DrawingCache都有一个DrawingCacheHolder</span></span><br><span class="line">       holder.buildCache(w, h, density, checkSizeEquals);<span class="comment">//DrawingCacheHolder的buildCache方法</span></span><br><span class="line">       mSize = mHolder.bitmap.getRowBytes() * mHolder.bitmap.getHeight();<span class="comment">//返回创建的bitmap的大小</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//DrawingCacheHolder的buildCache方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildCache</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> density, <span class="keyword">boolean</span> checkSizeEquals)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">boolean</span> reuse = checkSizeEquals ? (w == width &amp;&amp; h == height) : (w &lt;= width &amp;&amp; h &lt;= height);<span class="comment">//检测大小 ？ 宽高相等 ： 小于已经缓存的bitmap宽高</span></span><br><span class="line">       <span class="keyword">if</span> (reuse &amp;&amp; bitmap != <span class="keyword">null</span>) &#123;<span class="comment">//如果能够复用bitmap</span></span><br><span class="line">           bitmap.eraseColor(Color.TRANSPARENT);<span class="comment">//擦出之前的颜色</span></span><br><span class="line">           canvas.setBitmap(bitmap);<span class="comment">//给Canvas重新预设bitmap</span></span><br><span class="line">           recycleBitmapArray();<span class="comment">//回收超过一屏弹幕切割后的bitmap数组，这个接下来会讲</span></span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (bitmap != <span class="keyword">null</span>) &#123;<span class="comment">//如果不能复用，则回收旧的缓存bitmap</span></span><br><span class="line">           recycle();</span><br><span class="line">       &#125;</span><br><span class="line">       width = w;</span><br><span class="line">       height = h;</span><br><span class="line">       bitmap = NativeBitmapFactory.createBitmap(w, h, Bitmap.Config.ARGB_8888);<span class="comment">//用native方法创建一个bitmap</span></span><br><span class="line">       <span class="keyword">if</span> (density &gt; <span class="number">0</span>) &#123;<span class="comment">//设置density</span></span><br><span class="line">           mDensity = density;</span><br><span class="line">           bitmap.setDensity(density);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//设置canvas</span></span><br><span class="line">       <span class="keyword">if</span> (canvas == <span class="keyword">null</span>)&#123;</span><br><span class="line">           canvas = <span class="keyword">new</span> Canvas(bitmap);</span><br><span class="line">           canvas.setDensity(density);</span><br><span class="line">       &#125;<span class="keyword">else</span></span><br><span class="line">           canvas.setBitmap(bitmap);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;组建弹幕缓存就是为个DrawingCache根据目标弹幕大小创建bitmap和canvas。</p>
<p>&#160; &#160; &#160; &#160;No.2 绘制弹幕内容：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">drawDanmaku</span><span class="params">(BaseDanmaku danmaku, Canvas canvas, </span><br><span class="line">  <span class="keyword">float</span> left, <span class="keyword">float</span> top, <span class="keyword">boolean</span> fromWorkerThread)</span> </span>&#123;<span class="comment">//danmaku, holder.canvas, 0, 0, true</span></span><br><span class="line">      <span class="keyword">float</span> _left = left;</span><br><span class="line">      <span class="keyword">float</span> _top = top;</span><br><span class="line">      </span><br><span class="line">...一些杂项，忽略...</span><br><span class="line"></span><br><span class="line">      TextPaint paint = getPaint(danmaku, fromWorkerThread);<span class="comment">//获取画笔</span></span><br><span class="line">      <span class="comment">//绘制背景，sStuffer可以自己设置，默认是SimpleTextCacheStuffer,默认drawBackground为空</span></span><br><span class="line">      <span class="comment">//这个可以自己扩展，上面讲过</span></span><br><span class="line">      sStuffer.drawBackground(danmaku, canvas, _left, _top);</span><br><span class="line">      <span class="keyword">if</span> (danmaku.lines != <span class="keyword">null</span>) &#123;<span class="comment">//如果是多行文本</span></span><br><span class="line">          String[] lines = danmaku.lines;</span><br><span class="line">          <span class="keyword">if</span> (lines.length == <span class="number">1</span>) &#123;<span class="comment">//多行文本行数为1</span></span><br><span class="line">              <span class="keyword">if</span> (hasStroke(danmaku)) &#123;<span class="comment">//如果有描边，则绘制描边</span></span><br><span class="line">               <span class="comment">//重设画笔（绘制描边）</span></span><br><span class="line">                  applyPaintConfig(danmaku, paint, <span class="keyword">true</span>);</span><br><span class="line">                  <span class="keyword">float</span> strokeLeft = left;</span><br><span class="line">                  <span class="keyword">float</span> strokeTop = top - paint.ascent();</span><br><span class="line">                  ......</span><br><span class="line">                  <span class="comment">//绘制描边</span></span><br><span class="line">                  sStuffer.drawStroke(danmaku, lines[<span class="number">0</span>], canvas, strokeLeft, strokeTop, paint);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">//再次重设画笔（绘制文字）</span></span><br><span class="line">              applyPaintConfig(danmaku, paint, <span class="keyword">false</span>);</span><br><span class="line">              <span class="comment">//绘制文字</span></span><br><span class="line">              sStuffer.drawText(danmaku, lines[<span class="number">0</span>], canvas, left, top - paint.ascent(), paint, fromWorkerThread);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;<span class="comment">//多行文本行数大于1</span></span><br><span class="line">           <span class="comment">//先计算每行文本的高度</span></span><br><span class="line">              <span class="keyword">float</span> textHeight = (danmaku.paintHeight - <span class="number">2</span> * danmaku.padding) / lines.length;</span><br><span class="line">              <span class="comment">//循环绘制每一行文本</span></span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; lines.length; t++) &#123;</span><br><span class="line">                  ......</span><br><span class="line">                  <span class="keyword">if</span> (hasStroke(danmaku)) &#123;<span class="comment">//如果有描边，则绘制描边</span></span><br><span class="line">                   <span class="comment">//重设画笔（绘制描边）</span></span><br><span class="line">                      applyPaintConfig(danmaku, paint, <span class="keyword">true</span>);</span><br><span class="line">                      <span class="keyword">float</span> strokeLeft = left;</span><br><span class="line">                      <span class="keyword">float</span> strokeTop = t * textHeight + top - paint.ascent();</span><br><span class="line">				......</span><br><span class="line">                      <span class="comment">//绘制描边</span></span><br><span class="line">                      sStuffer.drawStroke(danmaku, lines[t], canvas, strokeLeft, strokeTop, paint);</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="comment">//再次重设画笔（绘制文字）</span></span><br><span class="line">                  applyPaintConfig(danmaku, paint, <span class="keyword">false</span>);</span><br><span class="line">                  <span class="comment">//绘制文字</span></span><br><span class="line">                  sStuffer.drawText(danmaku, lines[t], canvas, left, t * textHeight + top - paint.ascent(), paint, fromWorkerThread);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果是单行文本</span></span><br><span class="line">          <span class="keyword">if</span> (hasStroke(danmaku)) &#123;<span class="comment">//如果有描边，则绘制描边</span></span><br><span class="line">           <span class="comment">//重设画笔（绘制描边）</span></span><br><span class="line">              applyPaintConfig(danmaku, paint, <span class="keyword">true</span>);</span><br><span class="line">              <span class="keyword">float</span> strokeLeft = left;</span><br><span class="line">              <span class="keyword">float</span> strokeTop = top - paint.ascent();</span><br><span class="line">		......</span><br><span class="line">              <span class="comment">//绘制描边</span></span><br><span class="line">              sStuffer.drawStroke(danmaku, <span class="keyword">null</span>, canvas, strokeLeft, strokeTop, paint);</span><br><span class="line">          &#125;</span><br><span class="line">	<span class="comment">//再次重设画笔（绘制文字）</span></span><br><span class="line">          applyPaintConfig(danmaku, paint, <span class="keyword">false</span>);</span><br><span class="line">          <span class="comment">//绘制文字</span></span><br><span class="line">          sStuffer.drawText(danmaku, <span class="keyword">null</span>, canvas, left, top - paint.ascent(), paint, fromWorkerThread);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// draw underline</span></span><br><span class="line">      <span class="keyword">if</span> (danmaku.underlineColor != <span class="number">0</span>) &#123;<span class="comment">//绘制下划线（if）</span></span><br><span class="line">          Paint linePaint = getUnderlinePaint(danmaku);</span><br><span class="line">          <span class="keyword">float</span> bottom = _top + danmaku.paintHeight - UNDERLINE_HEIGHT;</span><br><span class="line">          canvas.drawLine(_left, bottom, _left + danmaku.paintWidth, bottom, linePaint);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//draw border</span></span><br><span class="line">      <span class="keyword">if</span> (danmaku.borderColor != <span class="number">0</span>) &#123;<span class="comment">//绘制外框</span></span><br><span class="line">          Paint borderPaint = getBorderPaint(danmaku);</span><br><span class="line">          canvas.drawRect(_left, _top, _left + danmaku.paintWidth, _top + danmaku.paintHeight,</span><br><span class="line">                  borderPaint);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//设置画笔</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">applyPaintConfig</span><span class="params">(BaseDanmaku danmaku, Paint paint, <span class="keyword">boolean</span> stroke)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	......</span><br><span class="line">          <span class="keyword">if</span> (stroke) &#123;</span><br><span class="line">              paint.setStyle(HAS_PROJECTION ? Style.FILL : Style.STROKE);</span><br><span class="line">              paint.setColor(danmaku.textShadowColor &amp; <span class="number">0x00FFFFFF</span>);</span><br><span class="line">              <span class="keyword">int</span> alpha = HAS_PROJECTION ? sProjectionAlpha : AlphaValue.MAX;</span><br><span class="line">              paint.setAlpha(alpha);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              paint.setStyle(Style.FILL);</span><br><span class="line">              paint.setColor(danmaku.textColor &amp; <span class="number">0x00FFFFFF</span>);</span><br><span class="line">              paint.setAlpha(AlphaValue.MAX);</span><br><span class="line">          &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;上述就是绘制弹幕内容过程，主要就是sStuffer的drawStroke，drawText方法。如果你在DanmakuContext中没有设置CacheStuffer，则上述drawDanmaku方法中的sStuffer为默认的SimpleTextCacheStuffer。<br>&#160; &#160; &#160; &#160;drawStroke方法及其扩展都一样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SimpleTextCacheStuffer的drawStroke方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawStroke</span><span class="params">(BaseDanmaku danmaku, String lineText, Canvas canvas, <span class="keyword">float</span> left, <span class="keyword">float</span> top, Paint paint)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (lineText != <span class="keyword">null</span>) &#123;</span><br><span class="line">           canvas.drawText(lineText, left, top, paint);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           canvas.drawText(danmaku.text.toString(), left, top, paint);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;我们设了SpannedCacheStuffer, drawText方法有些区别：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SimpleTextCacheStuffer的drawText方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawText</span><span class="params">(BaseDanmaku danmaku, String lineText, Canvas canvas, <span class="keyword">float</span> left, <span class="keyword">float</span> top, TextPaint paint, <span class="keyword">boolean</span> fromWorkerThread)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (lineText != <span class="keyword">null</span>) &#123;</span><br><span class="line">           canvas.drawText(lineText, left, top, paint);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           canvas.drawText(danmaku.text.toString(), left, top, paint);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//SpannedCacheStuffer的drawText方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawText</span><span class="params">(BaseDanmaku danmaku, String lineText, Canvas canvas, <span class="keyword">float</span> left, <span class="keyword">float</span> top, TextPaint paint, <span class="keyword">boolean</span> fromWorkerThread)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (danmaku.obj == <span class="keyword">null</span>) &#123;<span class="comment">//普通弹幕</span></span><br><span class="line">           <span class="keyword">super</span>.drawText(danmaku, lineText, canvas, left, top, paint, fromWorkerThread);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果是图文混排弹幕</span></span><br><span class="line">       SoftReference&lt;StaticLayout&gt; reference = (SoftReference&lt;StaticLayout&gt;) danmaku.obj;</span><br><span class="line">       StaticLayout staticLayout = reference.get();</span><br><span class="line">       <span class="comment">//按位与，判断标志位是否有效。这里判断是否请求重新测量</span></span><br><span class="line">       <span class="keyword">boolean</span> requestRemeasure = <span class="number">0</span> != (danmaku.requestFlags &amp; BaseDanmaku.FLAG_REQUEST_REMEASURE);</span><br><span class="line">       <span class="comment">//判断是否请求重绘</span></span><br><span class="line">       <span class="keyword">boolean</span> requestInvalidate = <span class="number">0</span> != (danmaku.requestFlags &amp; BaseDanmaku.FLAG_REQUEST_INVALIDATE);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (requestInvalidate || staticLayout == <span class="keyword">null</span>) &#123;<span class="comment">//如果请求重绘或者staticLayout 软引用被回收了</span></span><br><span class="line">           <span class="keyword">if</span> (requestInvalidate) &#123;</span><br><span class="line">            <span class="comment">//与非操作，清除标志位。清除请求重绘标志位</span></span><br><span class="line">               danmaku.requestFlags &amp;= ~BaseDanmaku.FLAG_REQUEST_INVALIDATE;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mProxy != <span class="keyword">null</span>) &#123;<span class="comment">//这个在设置DanmakuContext时设置，上面讲过，可以自己扩展</span></span><br><span class="line">               mProxy.prepareDrawing(danmaku, fromWorkerThread);</span><br><span class="line">           &#125;</span><br><span class="line">           CharSequence text = danmaku.text;</span><br><span class="line">           <span class="keyword">if</span> (text != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (requestRemeasure) &#123;<span class="comment">//重新测量</span></span><br><span class="line">                   staticLayout = <span class="keyword">new</span> StaticLayout(text, paint, (<span class="keyword">int</span>) Math.ceil(StaticLayout.getDesiredWidth(danmaku.text, paint)), Layout.Alignment.ALIGN_NORMAL, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="keyword">true</span>);</span><br><span class="line">                   danmaku.paintWidth = staticLayout.getWidth();</span><br><span class="line">                   danmaku.paintHeight = staticLayout.getHeight();</span><br><span class="line">                   danmaku.requestFlags &amp;= ~BaseDanmaku.FLAG_REQUEST_REMEASURE;<span class="comment">//清除标志位</span></span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;<span class="comment">//不用重新测量</span></span><br><span class="line">                   staticLayout = <span class="keyword">new</span> StaticLayout(text, paint, (<span class="keyword">int</span>) danmaku.paintWidth, Layout.Alignment.ALIGN_NORMAL, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="keyword">true</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               danmaku.obj = <span class="keyword">new</span> SoftReference&lt;&gt;(staticLayout);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//staticLayout可以继续用</span></span><br><span class="line">       <span class="keyword">boolean</span> needRestore = <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">if</span> (left != <span class="number">0</span> &amp;&amp; top != <span class="number">0</span>) &#123;</span><br><span class="line">           canvas.save();</span><br><span class="line">           canvas.translate(left, top + paint.ascent());</span><br><span class="line">           needRestore = <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//绘制弹幕内容</span></span><br><span class="line">       staticLayout.draw(canvas);</span><br><span class="line">       <span class="keyword">if</span> (needRestore) &#123;</span><br><span class="line">           canvas.restore();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;绘制弹幕内容就完了，主要是绘制描边，绘制文字，绘制下划线，边框等等。</p>
<p>&#160; &#160; &#160; &#160;No.3 切割超过一屏的弹幕：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DrawingCacheHolder的splitWith方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">splitWith</span><span class="params">(<span class="keyword">int</span> dispWidth, <span class="keyword">int</span> dispHeight, <span class="keyword">int</span> maximumCacheWidth, <span class="keyword">int</span> maximumCacheHeight)</span> </span>&#123;</span><br><span class="line">       recycleBitmapArray();<span class="comment">//回收已存的bitmapArray数组</span></span><br><span class="line">       <span class="keyword">if</span> (width &lt;= <span class="number">0</span> || height &lt;= <span class="number">0</span> || bitmap == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果弹幕的宽高都没有超过屏幕宽高，则不切割bitmap</span></span><br><span class="line">       <span class="keyword">if</span> (width &lt;= maximumCacheWidth &amp;&amp; height &lt;= maximumCacheHeight) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//切割超过一屏的弹幕</span></span><br><span class="line">       maximumCacheWidth = Math.min(maximumCacheWidth, dispWidth);</span><br><span class="line">       maximumCacheHeight = Math.min(maximumCacheHeight, dispHeight);</span><br><span class="line">       <span class="comment">//计算弹幕宽高是屏幕宽高的倍数，然后决定切割成多少块</span></span><br><span class="line">       <span class="keyword">int</span> xCount = width / maximumCacheWidth + (width % maximumCacheWidth == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">       <span class="keyword">int</span> yCount = height / maximumCacheHeight + (height % maximumCacheHeight == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">       <span class="comment">//然后求切割后弹幕每一块宽和高的平均值</span></span><br><span class="line">       <span class="keyword">int</span> averageWidth = width / xCount;</span><br><span class="line">       <span class="keyword">int</span> averageHeight = height / yCount;</span><br><span class="line">       <span class="comment">//建立二位bitmap数组，用于存放切割碎片</span></span><br><span class="line">       <span class="keyword">final</span> Bitmap[][] bmpArray = <span class="keyword">new</span> Bitmap[yCount][xCount];</span><br><span class="line">       <span class="keyword">if</span> (canvas == <span class="keyword">null</span>)&#123;</span><br><span class="line">           canvas = <span class="keyword">new</span> Canvas();</span><br><span class="line">           <span class="keyword">if</span> (mDensity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               canvas.setDensity(mDensity);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       Rect rectSrc = <span class="keyword">new</span> Rect();</span><br><span class="line">       Rect rectDst = <span class="keyword">new</span> Rect();</span><br><span class="line">       <span class="comment">//切割bitmap到bitmapArray中</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> yIndex = <span class="number">0</span>; yIndex &lt; yCount; yIndex++) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> xIndex = <span class="number">0</span>; xIndex &lt; xCount; xIndex++) &#123;</span><br><span class="line">            <span class="comment">//创建每一块小块bitmap</span></span><br><span class="line">               Bitmap bmp = bmpArray[yIndex][xIndex] = NativeBitmapFactory.createBitmap(</span><br><span class="line">                       averageWidth, averageHeight, Bitmap.Config.ARGB_8888);</span><br><span class="line">               <span class="keyword">if</span> (mDensity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                   bmp.setDensity(mDensity);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//将弹幕的大bitmap绘制进每个小块bitmap中</span></span><br><span class="line">               canvas.setBitmap(bmp);</span><br><span class="line">               <span class="keyword">int</span> left = xIndex * averageWidth, top = yIndex * averageHeight;</span><br><span class="line">               rectSrc.set(left, top, left + averageWidth, top + averageHeight);</span><br><span class="line">               rectDst.set(<span class="number">0</span>, <span class="number">0</span>, bmp.getWidth(), bmp.getHeight());</span><br><span class="line">               canvas.drawBitmap(bitmap, rectSrc, rectDst, <span class="keyword">null</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       canvas.setBitmap(bitmap);</span><br><span class="line">       bitmapArray = bmpArray;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;切割超过一屏的弹幕，<strong>就像玩切田字格游戏一样</strong>，完成后保存了一个bitmapArray数组。</p>
<p>&#160; &#160; &#160; &#160;到这里我们buildCache(item, false)的策略二中的重新设置缓存DanmakuUtils.buildDanmakuDrawingCache(item, mDisp, cache)就走完了。然后将这个目标弹幕的引用放入缓存Danmakus中(mCaches)，同时更新已使用大小mRealSize。同时注意mCaches内部成员items是TreeSet类型，不能添加相同的对象。</p>
<p>&#160; &#160; &#160; &#160;策略二设计的挺复杂的，我们可以看到这个策略应该是弹幕已经播放时不断执行的，对过时弹幕缓存的重复利用。不过我们刚开始，这一策略还未起作用，所以跳过，进入下一阶段：</p>
<p> &#160; &#160; &#160; &#160;4）如果上述两次查找缓存都没找到，则从FinitePool中取出一个，没有就new一个，然后同上配置DrawingCache：<br> &#160; &#160; &#160; &#160;继续回到buildCache方法这个位置： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">byte</span> <span class="title">buildCache</span><span class="params">(BaseDanmaku item, <span class="keyword">boolean</span> forceInsert)</span> </span>&#123;<span class="comment">//item, false</span></span><br><span class="line">		...测量过了...</span><br><span class="line">		...第一策略已经pass...</span><br><span class="line">		...第二策略已经pass...</span><br><span class="line">                  <span class="comment">//如果上述两次查找缓存都没找到，则进入下面逻辑</span></span><br><span class="line">                  <span class="comment">// guess cache size</span></span><br><span class="line">                  <span class="keyword">if</span> (!forceInsert) &#123;<span class="comment">//如果forceInsert为false，则表示不检测内存超出</span></span><br><span class="line">                      <span class="comment">//计算此弹幕bitmap的大小，width * height * 4</span></span><br><span class="line">                      <span class="comment">//(因为用native创建的Bitmap的Config为ARGB_8888，所以一个像素占4个字节)</span></span><br><span class="line">                      <span class="keyword">int</span> cacheSize = DanmakuUtils.getCacheSize((<span class="keyword">int</span>) item.paintWidth,</span><br><span class="line">                              (<span class="keyword">int</span>) item.paintHeight);</span><br><span class="line">                      <span class="comment">//如果当前已经使用大小 + 此弹幕缓存大小 &gt; 设置的最大内存（2/3 应用内存）        </span></span><br><span class="line">                      <span class="keyword">if</span> (mRealSize + cacheSize &gt; mMaxSize) &#123;<span class="comment">//没有超</span></span><br><span class="line">                          <span class="keyword">return</span> RESULT_FAILED;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="comment">//从FinitePool中的300个DrawingCache对象中取出来一个</span></span><br><span class="line">                  cache = mCachePool.acquire();</span><br><span class="line">                  <span class="comment">//如果从上面的FinitePool取完了，则会直接new一个DrawingCache，配置DrawingCache</span></span><br><span class="line">                  cache = DanmakuUtils.buildDanmakuDrawingCache(item, mDisp, cache);</span><br><span class="line">                  item.cache = cache;</span><br><span class="line">                  <span class="comment">//将item存入mCaches缓存，同时更新已使用大小mRealSize</span></span><br><span class="line">                  <span class="keyword">boolean</span> pushed = mCacheManager.push(item, sizeOf(item), forceInsert);</span><br><span class="line">                  <span class="keyword">if</span> (!pushed) &#123;<span class="comment">//如果item存放失败(使用内存超出规定大小)</span></span><br><span class="line">                      releaseDanmakuCache(item, cache);<span class="comment">//释放DrawingCache</span></span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">return</span> pushed ? RESULT_SUCCESS : RESULT_FAILED;</span><br><span class="line">		......</span><br><span class="line">&#125;</span><br><span class="line">   <span class="comment">//FinitePool的acquire方法，从缓存链表头取出一个对象</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> T <span class="title">acquire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        T element;</span><br><span class="line">		<span class="comment">//mRoot 就是缓存链表表头指向的对象</span></span><br><span class="line">        <span class="keyword">if</span> (mRoot != <span class="keyword">null</span>) &#123;</span><br><span class="line">            element = mRoot;</span><br><span class="line">            mRoot = element.getNextPoolable();</span><br><span class="line">            mPoolCount--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            element = mManager.newInstance();</span><br><span class="line">        &#125;</span><br><span class="line">	        <span class="keyword">if</span> (element != <span class="keyword">null</span>) &#123;</span><br><span class="line">            element.setNextPoolable(<span class="keyword">null</span>);</span><br><span class="line">            element.setPooled(<span class="keyword">false</span>);</span><br><span class="line">            mManager.onAcquired(element);</span><br><span class="line">        &#125;	</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;上述策略三是直接新建一个缓存DrawingCache，然后根据目标弹幕样式等配置它然后将它付给目标弹幕，再将目标弹幕放入缓存mCaches中。<br>&#160; &#160; &#160; &#160;刚开始时会执行策略三，因为刚开始时还没有缓存供我们使用，所以只能新建。</p>
<p>&#160; &#160; &#160; &#160;到此buildCache方法就走完了。我们可以看到buildCache主要截取了从当前时间开始的3倍弹幕时间内所有弹幕，然后为每一条弹幕建立缓存（创建DrawingCache对象，然后测量弹幕大小，再绘制弹幕内容，最后将信息保存到DrawingCache中，然后将它赋给目标弹幕的cache属性），并将这些弹幕保存到缓存mCaches中。</p>
<p>&#160; &#160; &#160; &#160;再次回顾一下上面的逻辑：</p>
<ul>
<li>子线程从发送PREPARE消息开始，然后接着发送了DISPATCH_ACTIONS消息；</li>
<li>DISPATCH_ACTIONS消息处理逻辑内部又会发送DISPATCH_ACTIONS消息，时间间隔为半条弹幕时间就这样不断循环发送；</li>
<li>DISPATCH_ACTIONS消息处理会调用dispatchAction方法，dispatchAction方法会发送BUILD_CACHES消息；</li>
<li>BUILD_CACHES消息处理会调用prepareCaches方法，prepareCaches方法内部会调用buildCache方法为从当前时间开始的3倍弹幕时间内所有的弹幕做缓存。</li>
</ul>
<p>&#160; &#160; &#160; &#160;buildCache走完后，赶紧回到它之前调用方法的地方，不要把自己搞晕了= 。=<br>&#160; &#160; &#160; &#160;回到CacheManagingDrawTask的prepareCaches方法中，<strong>最后更新一下缓存定时器的时间，到缓存的最后一条弹幕的出现时间</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">prepareCaches</span><span class="params">(<span class="keyword">boolean</span> repositioned)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	...截取三倍弹幕时间内所有弹幕，并为他们一一建立缓存...</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (item != <span class="keyword">null</span>) &#123;<span class="comment">//截取的最后一条弹幕,更新缓存定时器时间到它的出现时间</span></span><br><span class="line">        mCacheTimer.update(item.time);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mCacheTimer.update(end);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;prepareCaches方法走完后，回到处理原先处理BUILD_CACHES消息的逻辑中，继续执行剩余部分：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//CacheHandler的handleMessage方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line"> ......</span><br><span class="line"> <span class="keyword">case</span> BUILD_CACHES:</span><br><span class="line">        removeMessages(BUILD_CACHES);</span><br><span class="line">        <span class="keyword">boolean</span> repositioned = ((mTaskListener != <span class="keyword">null</span> </span><br><span class="line">         &amp;&amp; mReadyState == <span class="keyword">false</span>) || mSeekedFlag);<span class="comment">// 为true</span></span><br><span class="line">        prepareCaches(repositioned);<span class="comment">//首次建立缓存已经完毕</span></span><br><span class="line">        <span class="keyword">if</span> (repositioned)</span><br><span class="line">         mSeekedFlag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (mTaskListener != <span class="keyword">null</span> &amp;&amp; mReadyState == <span class="keyword">false</span>) &#123;</span><br><span class="line">         mTaskListener.ready();<span class="comment">//然后回到mTaskListener监听ready方法</span></span><br><span class="line">         mReadyState = <span class="keyword">true</span>;<span class="comment">//将mReadyState标志位置为true，下次BUILD_CACHES不会进入这段逻辑了</span></span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">       ...... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;执行mTaskListener.ready()方法，得回到上层逻辑DrawHandler的prepare(runnable)方法中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DrawHandler的prepare方法</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">final</span> Runnable runnable)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (drawTask == <span class="keyword">null</span>) &#123;</span><br><span class="line">           drawTask = createDrawTask(mDanmakuView.isDanmakuDrawingCacheEnabled(), timer,</span><br><span class="line">                   mDanmakuView.getContext(), mDanmakuView.getWidth(), mDanmakuView.getHeight(),</span><br><span class="line">                   mDanmakuView.isHardwareAccelerated(), <span class="keyword">new</span> IDrawTask.TaskListener() &#123;</span><br><span class="line">                       <span class="meta">@Override</span></span><br><span class="line">                       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ready</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                           initRenderingConfigs();<span class="comment">//初始化一些渲染参数</span></span><br><span class="line">                           runnable.run();<span class="comment">//执行runnable的run方法，继续追踪</span></span><br><span class="line">                       &#125;</span><br><span class="line">				......</span><br><span class="line">                   &#125;);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           runnable.run();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//DrawHandler的initRenderingConfigs方法</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initRenderingConfigs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">long</span> averageFrameConsumingTime = <span class="number">16</span>;<span class="comment">//平均每帧渲染间隔</span></span><br><span class="line">       mCordonTime = Math.max(<span class="number">33</span>, (<span class="keyword">long</span>) (averageFrameConsumingTime * <span class="number">2.5f</span>));<span class="comment">//40，警戒值1</span></span><br><span class="line">       mCordonTime2 = (<span class="keyword">long</span>) (mCordonTime * <span class="number">2.5f</span>);<span class="comment">//100，警戒值2</span></span><br><span class="line">       mFrameUpdateRate = Math.max(<span class="number">16</span>, averageFrameConsumingTime / <span class="number">15</span> * <span class="number">15</span>);<span class="comment">//16，每帧渲染间隔</span></span><br><span class="line">       mThresholdTime = mFrameUpdateRate + <span class="number">3</span>;<span class="comment">//19，渲染间隔阀值</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;初始化一些渲染参数，主要就是计算一下警戒时间和渲染频率。然后继续追踪runnable.run()方法，这个得回到DrawHandler的handleMessage方法中处理DrawHandler.PREPARE逻辑处：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DrawHandler的handleMessage方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> what = msg.what;</span><br><span class="line">       <span class="keyword">switch</span> (what) &#123;</span><br><span class="line">           <span class="keyword">case</span> PREPARE:</span><br><span class="line">		......</span><br><span class="line">                   prepare(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                       <span class="meta">@Override</span></span><br><span class="line">                       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;<span class="comment">//会回调到这里</span></span><br><span class="line">                           pausedPosition = <span class="number">0</span>;</span><br><span class="line">                           mReady = <span class="keyword">true</span>;<span class="comment">//将mReady 标志位置为true</span></span><br><span class="line">                           <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">                               mCallback.prepared();<span class="comment">//回调callback监听</span></span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;);</span><br><span class="line">               ......</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;继续追踪mCallback.prepared()，会回到MainActivity当中我们设置DanmakuView的地方：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MainActivity中设置mDanmakuView</span></span><br><span class="line">   mDanmakuView.setCallback(<span class="keyword">new</span> master.flame.danmaku.controller.DrawHandler.Callback() &#123;</span><br><span class="line">	......</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepared</span><span class="params">()</span> </span>&#123;                 </span><br><span class="line">    mDanmakuView.start();</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">   <span class="comment">//继续产看DanmaKuView的start方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       start(<span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">long</span> postion)</span> </span>&#123;</span><br><span class="line">	......</span><br><span class="line">       handler.obtainMessage(DrawHandler.START, postion).sendToTarget();<span class="comment">//DrawHandler发送START消息</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;然后就是DrawHandler发送START消息：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DrawHandler的handleMessage方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">		......</span><br><span class="line">        <span class="keyword">case</span> START:</span><br><span class="line">               Long startTime = (Long) msg.obj;<span class="comment">//0</span></span><br><span class="line">               <span class="keyword">if</span> (startTime != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   pausedPosition = startTime;<span class="comment">//0</span></span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   pausedPosition = <span class="number">0</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           <span class="keyword">case</span> SEEK_POS:</span><br><span class="line">			......</span><br><span class="line">           <span class="keyword">case</span> RESUME:</span><br><span class="line">               quitFlag = <span class="keyword">false</span>;</span><br><span class="line">               <span class="keyword">if</span> (mReady) &#123;<span class="comment">//true</span></span><br><span class="line">				......</span><br><span class="line">                   mTimeBase = SystemClock.uptimeMillis() - pausedPosition;<span class="comment">//将时间基线设为当前时间</span></span><br><span class="line">                   timer.update(pausedPosition);<span class="comment">//更新主定时器时间到初始位置，为0</span></span><br><span class="line">                   removeMessages(RESUME);</span><br><span class="line">                   sendEmptyMessage(UPDATE);<span class="comment">//发送UPDATE消息</span></span><br><span class="line">                   drawTask.start();<span class="comment">//CacheManagingDrawTask的start方法</span></span><br><span class="line">				......</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  ......</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> UPDATE:</span><br><span class="line">               <span class="keyword">if</span> (mUpdateInNewThread) &#123;<span class="comment">//在DrawHandler构造方法里赋值的变量，只有当可用CPU个数大于3时才为true</span></span><br><span class="line">                   updateInNewThread();<span class="comment">//四核，八核的请进</span></span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   updateInCurrentThread();<span class="comment">//单核，双核的请进</span></span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           ......    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;上述逻辑最后会进入RESUME消息处理中，先调用CacheManagingDrawTask的start方法，然后处理UPDATE消息。我们先看看CacheManagingDrawTask的start方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CacheManagingDrawTask的start方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	......</span><br><span class="line">       mCacheManager.resume();<span class="comment">//CacheManager的resume方法</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//继续跟CacheManager的resume方法</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           ......</span><br><span class="line">           mHandler.resume();<span class="comment">//CacheManagingDrawTask的resume方法</span></span><br><span class="line">		......</span><br><span class="line">       &#125;</span><br><span class="line">    <span class="comment">//继续跟CacheManagingDrawTask的resume方法   </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           mCancelFlag = <span class="keyword">false</span>;</span><br><span class="line">           mPause = <span class="keyword">false</span>;</span><br><span class="line">           removeMessages(DISPATCH_ACTIONS);</span><br><span class="line">           sendEmptyMessage(DISPATCH_ACTIONS);<span class="comment">//发送DISPATCH_ACTIONS消息，我们上面分析过，就是建立缓存</span></span><br><span class="line">           sendEmptyMessageDelayed(CLEAR_TIMEOUT_CACHES, mContext.mDanmakuFactory.MAX_DANMAKU_DURATION);<span class="comment">//延时发送CLEAR_TIMEOUT_CACHES消息</span></span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;我们可以看到CacheManagingDrawTask的start方法最终做了两件事，一件是发送DISPATCH_ACTIONS再次建立缓存，这个流程我们上面分析过；第二件是<code>延时发送</code>CLEAR_TIMEOUT_CACHES消息。</p>
<p>&#160; &#160; &#160; &#160;所以我们看看CLEAR_TIMEOUT_CACHES消息处理逻辑：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CacheHandler的handleMessage方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">	 .......</span><br><span class="line">	 <span class="keyword">case</span> CLEAR_TIMEOUT_CACHES:</span><br><span class="line">            clearTimeOutCaches();<span class="comment">//继续跟这个</span></span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           ......    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用 clearTimeOutCaches方法</span></span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">clearTimeOutCaches</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          clearTimeOutCaches(mTimer.currMillisecond);<span class="comment">//调用重载方法，参数为主定时器当前时间</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//调用重载方法，参数为主定时器当前时间</span></span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">clearTimeOutCaches</span><span class="params">(<span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">          IDanmakuIterator it = mCaches.iterator();<span class="comment">//从之前buildCache中建立的缓存中一一遍历</span></span><br><span class="line">          <span class="keyword">while</span> (it.hasNext() &amp;&amp; !mEndFlag) &#123;<span class="comment">//mEndFlag = false</span></span><br><span class="line">              BaseDanmaku val = it.next();</span><br><span class="line">              <span class="keyword">if</span> (val.isTimeOut()) &#123;<span class="comment">//如果缓存的弹幕已经超时</span></span><br><span class="line">			......</span><br><span class="line">                  entryRemoved(<span class="keyword">false</span>, val, <span class="keyword">null</span>);<span class="comment">//销毁缓存</span></span><br><span class="line">                  it.remove();<span class="comment">//从缓存mCaches中移除此引用</span></span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;顺着逻辑看看entryRemoved(false, val, null)方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">entryRemoved</span><span class="params">(<span class="keyword">boolean</span> evicted, BaseDanmaku oldValue, BaseDanmaku newValue)</span> </span>&#123;<span class="comment">//第1个和第3个参数没用到</span></span><br><span class="line">    IDrawingCache&lt;?&gt; cache = oldValue.getDrawingCache();</span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">long</span> releasedSize = clearCache(oldValue);<span class="comment">//调用了clearCache方法</span></span><br><span class="line">        <span class="keyword">if</span> (oldValue.isTimeOut()) &#123;</span><br><span class="line">         <span class="comment">//这个方法最终会调用我们最初设置DanmakuContext.setCacheStuffer(new SpannedCacheStuffer(), mCacheStufferAdapter)</span></span><br><span class="line">         <span class="comment">//中第二个参数类型为BaseCacheStuffer.Proxy的releaseResource方法,</span></span><br><span class="line">         <span class="comment">//方法注释是这么写的 TODO 重要:清理含有ImageSpan的text中的一些占用内存的资源 例如drawable</span></span><br><span class="line">            mContext.getDisplayer().getCacheStuffer().releaseResource(oldValue);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (releasedSize &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        mRealSize -= releasedSize;<span class="comment">//真正缓存大小减去需要释放的缓存大小</span></span><br><span class="line">        mCachePool.release((DrawingCache) cache);<span class="comment">//将Drawingcache放回到FinitePool中，已供下次取出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//往下看，看看clearCache方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">clearCache</span><span class="params">(BaseDanmaku oldValue)</span> </span>&#123;</span><br><span class="line">    IDrawingCache&lt;?&gt; cache = oldValue.cache;</span><br><span class="line">    <span class="keyword">if</span> (cache == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cache.hasReferences()) &#123;<span class="comment">//如果DrawingCache缓存还被重复引用</span></span><br><span class="line">        cache.decreaseReference();<span class="comment">//则将引用计数-1</span></span><br><span class="line">        oldValue.cache = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//不销毁缓存(bitmap,canvas等)，只有等到引用计数为0时才会销毁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> size = sizeOf(oldValue);<span class="comment">//计算缓存的bitmap大小</span></span><br><span class="line">    cache.destroy();<span class="comment">//同时销毁bitmap等</span></span><br><span class="line">    oldValue.cache = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//缓存的bitmap的大小</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">sizeOf</span><span class="params">(BaseDanmaku value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value.cache != <span class="keyword">null</span> &amp;&amp; !value.cache.hasReferences()) &#123;</span><br><span class="line">        <span class="keyword">return</span> value.cache.size();<span class="comment">//返回的是Drawing中bitmap对象的大小，上面讲过的</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;CLEAR_TIMEOUT_CACHES消息处理就分析完了，就是移除缓存弹幕mCache中过时的弹幕，并且销毁他们持有的DrawingCache，同时销毁内部的bitmap、canvas等。</p>
<h3 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h3><p>&#160; &#160; &#160; &#160;现在重点来了！还记得我们之前挖的一个大坑么？就是妹子图那个地方。那是CacheHandler给工作线程发送DISPATCH_ACTIONS消息时调用的dispatchAction方法。因为CacheHandler每个半条弹幕时间就会发DISPATCH_ACTIONS消息，所以我们得仔细分析一下dispatchAction方法的各种情况：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">dispatchAction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="comment">//如果上一次buildCache完成后得到的缓存弹幕末尾项的时间（上面分析过，这个值存在mCacheTimer.currMillisecond中）</span></span><br><span class="line">         <span class="comment">//和主定时器当前时间之间的时间差值已经大于一条弹幕时间,</span></span><br><span class="line">         <span class="comment">//则会清除所有不在屏幕内的缓存，然后重新buildCache建立缓存</span></span><br><span class="line">            <span class="keyword">if</span> (mCacheTimer.currMillisecond &lt;= mTimer.currMillisecond - mContext.mDanmakuFactory.MAX_DANMAKU_DURATION) &#123;</span><br><span class="line">                evictAllNotInScreen();<span class="comment">//则会清除所有不在屏幕内的缓存</span></span><br><span class="line">                mCacheTimer.update(mTimer.currMillisecond);</span><br><span class="line">                sendEmptyMessage(BUILD_CACHES);<span class="comment">//重新建立缓存</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">float</span> level = getPoolPercent();<span class="comment">//获得缓存实际大小占设置最大内存的百分比</span></span><br><span class="line">            BaseDanmaku firstCache = mCaches.first();</span><br><span class="line">            <span class="comment">//TODO 如果firstcache大于当前时间超过半屏并且水位在0.5f以下,就要往里蓄水</span></span><br><span class="line">            <span class="keyword">long</span> gapTime = firstCache != <span class="keyword">null</span> ? firstCache.time - mTimer.currMillisecond : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">long</span> doubleScreenDuration = mContext.mDanmakuFactory.MAX_DANMAKU_DURATION * <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (level &lt; <span class="number">0.6f</span> &amp;&amp; gapTime &gt; mContext.mDanmakuFactory.MAX_DANMAKU_DURATION) &#123;</span><br><span class="line">                mCacheTimer.update(mTimer.currMillisecond);</span><br><span class="line">                removeMessages(BUILD_CACHES);</span><br><span class="line">                sendEmptyMessage(BUILD_CACHES);<span class="comment">//重新建立缓存</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (level &gt; <span class="number">0.4f</span> &amp;&amp; gapTime &lt; -doubleScreenDuration) &#123;<span class="comment">//如果水位在0.5以上，并且上一次蓄水距离现在已经超过两条弹幕时间了，就要开闸放水</span></span><br><span class="line">                <span class="comment">// clear timeout caches</span></span><br><span class="line">                removeMessages(CLEAR_TIMEOUT_CACHES);</span><br><span class="line">                sendEmptyMessage(CLEAR_TIMEOUT_CACHES);<span class="comment">//CLEAR_TIMEOUT_CACHES消息刚分析过了，清除过时缓存</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (level &gt;= <span class="number">0.9f</span>) &#123;<span class="comment">//水位快满了，等待下次放水</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// check cache time</span></span><br><span class="line">            <span class="keyword">long</span> deltaTime = mCacheTimer.currMillisecond - mTimer.currMillisecond;</span><br><span class="line">            <span class="comment">//缓存的第一条弹幕已经过时了，并且缓存弹幕末尾时间和现在时间差值已经超过一条弹幕时间了</span></span><br><span class="line">            <span class="keyword">if</span> (firstCache != <span class="keyword">null</span> &amp;&amp; firstCache.isTimeOut() &amp;&amp; deltaTime &lt; -mContext.mDanmakuFactory.MAX_DANMAKU_DURATION) &#123;</span><br><span class="line">                mCacheTimer.update(mTimer.currMillisecond);</span><br><span class="line">                sendEmptyMessage(CLEAR_OUTSIDE_CACHES);<span class="comment">//先清除过时缓存</span></span><br><span class="line">                sendEmptyMessage(BUILD_CACHES);<span class="comment">//再重组缓存</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (deltaTime &gt; doubleScreenDuration) &#123;<span class="comment">//如果缓存的最后一条弹幕时间距离现在还有双倍弹幕时间多，则啥都不做</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//剩余情况组建缓存</span></span><br><span class="line">            removeMessages(BUILD_CACHES);</span><br><span class="line">            sendEmptyMessage(BUILD_CACHES);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//则会清除所有不在屏幕内的缓存    </span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">evictAllNotInScreen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        evictAllNotInScreen(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">evictAllNotInScreen</span><span class="params">(<span class="keyword">boolean</span> removeAllReferences)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mCaches != <span class="keyword">null</span>) &#123;</span><br><span class="line">            IDanmakuIterator it = mCaches.iterator();</span><br><span class="line">            <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                BaseDanmaku danmaku = it.next();</span><br><span class="line">	......</span><br><span class="line">                <span class="keyword">if</span> (danmaku.isOutside()) &#123;<span class="comment">//如果弹幕已经走完了，超过屏幕</span></span><br><span class="line">                    entryRemoved(<span class="keyword">true</span>, danmaku, <span class="keyword">null</span>);<span class="comment">//回收缓存</span></span><br><span class="line">                    it.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">  </span><br><span class="line">        &#125;</span><br><span class="line">        mRealSize = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获得缓存实际大小占设置最大内存的百分比</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getPoolPercent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mMaxSize == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mRealSize / (<span class="keyword">float</span>) mMaxSize;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;dispatchAction方法主要分为以下几种规则：</p>
<ul>
<li>如果上一次buildCache完成后得到的缓存弹幕末尾项的时间（上面分析过，这个值存在mCacheTimer.currMillisecond中）和主定时器当前时间之间的时间差值已经大于一条弹幕时间, 则会清除所有不在屏幕内的缓存，然后重新buildCache建立缓存；</li>
<li>如果缓存弹幕的第一项出现时间大于当前时间超过半屏，并且总缓存大小在规定最大值一半以下, 就要重新建立缓存；</li>
<li>如果总缓存大小在规定最大值一半以上，并且上一次建立缓存距离现在已经超过两条弹幕时间了，就要清除超时缓存；</li>
<li>如果总缓存大小快达到规定最大值，就等待下一次清除超时缓存；</li>
<li>缓存的第一条弹幕已经过时了，并且缓存弹幕末尾时间和现在时间差值已经超过一条弹幕时间了，先清除过时缓存，再重组缓存；</li>
<li>如果缓存的最后一条弹幕时间距离现在还有双倍弹幕时间多，则啥都不做;</li>
<li>剩余情况就是重组缓存。</li>
</ul>
<p>&#160; &#160; &#160; &#160;因为DISPATCH_ACTIONS消息是每隔半条弹幕时间发送一次，所以会不断执行dispatchAction方法。然后根据上述出现的情况不断BUILD_CACHES和CLEAR_TIMEOUT_CACHES,这样工作线程就形成了一套缓存机制。</p>
<h3 id="绘制弹幕界面"><a href="#绘制弹幕界面" class="headerlink" title="绘制弹幕界面"></a>绘制弹幕界面</h3><p>&#160; &#160; &#160; &#160;到此CacheManagingDrawTask的start方法就分析完了，继续回到DrawHandler的handleMessage方法，接着处理UPDATE消息：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DrawHandler的handleMessage方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">case</span> UPDATE:</span><br><span class="line">               <span class="keyword">if</span> (mUpdateInNewThread) &#123;<span class="comment">//在DrawHandler构造方法里赋值的变量，只有当可用CPU个数大于3时才为true</span></span><br><span class="line">                   updateInNewThread();<span class="comment">//四核，八核的请进</span></span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   updateInCurrentThread();<span class="comment">//单核，双核的请进</span></span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           ...... 	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;到这里，我们应该能猜到接下要进行应该就是绘制工作了。其实updateInNewThread和updateInCurrentThread做的事情是一样的，只不过其中一个新开了子线程去做这些事情。两者的工作原理都是更新定时器，然后postInvalidate，使DanmakuView重绘，然后再发UPDATE消息，重复上述过程。</p>
<p>&#160; &#160; &#160; &#160;鉴于目前四核手机已经烂大街了，我们也就挑个多核的方法进去看看：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateInNewThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mThread != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mThread = <span class="keyword">new</span> UpdateThread(<span class="string">"DFM Update"</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">long</span> lastTime = SystemClock.uptimeMillis();</span><br><span class="line">            <span class="keyword">long</span> dTime = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (!isQuited() &amp;&amp; !quitFlag) &#123;</span><br><span class="line">                <span class="keyword">long</span> startMS = SystemClock.uptimeMillis();</span><br><span class="line">                dTime = SystemClock.uptimeMillis() - lastTime;</span><br><span class="line">                <span class="keyword">long</span> diffTime = mFrameUpdateRate - dTime;<span class="comment">//mFrameUpdateRate 为16，之前计算过</span></span><br><span class="line">                <span class="keyword">if</span> (diffTime &gt; <span class="number">1</span>) &#123;<span class="comment">//如果间隔时间太短，则会延时，一定要等够16毫秒，达到绘制时间间隔</span></span><br><span class="line">                    SystemClock.sleep(<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;d</span><br><span class="line">                <span class="comment">//上面逻辑是为了延时，稳定帧率</span></span><br><span class="line">                lastTime = startMS;</span><br><span class="line">                <span class="keyword">long</span> d = syncTimer(startMS);<span class="comment">//同步主定时器时间</span></span><br><span class="line">       ......</span><br><span class="line">       </span><br><span class="line">                d = mDanmakuView.drawDanmakus();<span class="comment">//开始postInvalidate，绘制弹幕，同时返回绘制时间</span></span><br><span class="line">                <span class="comment">//这种情况出现在绘制时间内，绘制时子线程在wait，等待绘制结束，然后返回差值必定大于警戒值100</span></span><br><span class="line">                <span class="keyword">if</span> (d &gt; mCordonTime2) &#123;  <span class="comment">// this situation may be cuased by ui-thread waiting of DanmakuView, so we sync-timer at once</span></span><br><span class="line">                    timer.add(d);<span class="comment">//绘制完成后更新主定时器时间</span></span><br><span class="line">                    mDrawTimes.clear();</span><br><span class="line">                &#125;</span><br><span class="line">	......</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    mThread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;updateInNewThread主要做了两件事：延时然后同步主定时器时间，然后通知DanmakuView重绘。</p>
<p>&#160; &#160; &#160; &#160;我们先看同步主定时器时间：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">syncTimer</span><span class="params">(<span class="keyword">long</span> startMS)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      ......</span><br><span class="line">      <span class="keyword">long</span> d = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">long</span> time = startMS - mTimeBase;<span class="comment">//当前时间到初始时间的时间差</span></span><br><span class="line">       ......</span><br><span class="line">          <span class="keyword">long</span> gapTime = time - timer.currMillisecond;<span class="comment">//总时间差减去上一次绘制完成时间，得到绘制间隙时间</span></span><br><span class="line">          <span class="keyword">long</span> averageTime = Math.max(mFrameUpdateRate, getAverageRenderingTime());<span class="comment">//计算绘制间隙平均时间，大于等于16（getAverageRenderingTime方法是计算加入mDrawTimes队列的已经绘制过的时间总和除以帧数，得到平均时间，这个下面会讲到）</span></span><br><span class="line">          <span class="comment">//若果距离上次间隙时间过长||上次渲染时间大于第一警戒时间（40 ms）||上一步计算的绘制间隙平均时间大于第一警戒时间</span></span><br><span class="line">          <span class="keyword">if</span> (gapTime &gt; <span class="number">2000</span> || mRenderingState.consumingTime &gt; mCordonTime || averageTime &gt; mCordonTime) &#123;</span><br><span class="line">              d = gapTime;</span><br><span class="line">              gapTime = <span class="number">0</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果是普通情况</span></span><br><span class="line">              d = averageTime + gapTime / mFrameUpdateRate;<span class="comment">//将绘制间隙平均时间赋给d，后面的项值不大，可以忽略</span></span><br><span class="line">              d = Math.max(mFrameUpdateRate, d);<span class="comment">//大于等于固定绘制间隔16</span></span><br><span class="line">              d = Math.min(mCordonTime, d);<span class="comment">//小于第一警戒时间40</span></span><br><span class="line">       </span><br><span class="line">		......</span><br><span class="line">          &#125;</span><br><span class="line">          ......</span><br><span class="line">          timer.add(d);<span class="comment">//更新主定时器时间，加上计算的时间间隔</span></span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">      <span class="keyword">return</span> d;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//计算平均绘制间隔时间</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">getAverageRenderingTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> frames = mDrawTimes.size();</span><br><span class="line">      <span class="keyword">if</span>(frames &lt;= <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">long</span> dtime = mDrawTimes.getLast() - mDrawTimes.getFirst();</span><br><span class="line">      <span class="keyword">return</span> dtime / frames;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;syncTimer主要是计算了一下绘制间隔时间，然后同步一下主定时器。</p>
<p>&#160; &#160; &#160; &#160;然后我们看看通知DanmakuView重绘部分：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DanmakuView的drawDanmakus方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">drawDanmakus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">long</span> stime = SystemClock.uptimeMillis();</span><br><span class="line">       lockCanvas();<span class="comment">//再看看lockCanvas</span></span><br><span class="line">       <span class="keyword">return</span> SystemClock.uptimeMillis() - stime;<span class="comment">//返回等待时间差</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//DanmakuView的lockCanvas方法</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">lockCanvas</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	......</span><br><span class="line">       postInvalidateCompat();<span class="comment">//通知view重绘</span></span><br><span class="line">       <span class="keyword">synchronized</span> (mDrawMonitor) &#123;</span><br><span class="line">           <span class="keyword">while</span> ((!mDrawFinished) &amp;&amp; (handler != <span class="keyword">null</span>)) &#123;<span class="comment">//mDrawFinished标志位为false，所以会进入循环。只有onDraw方法的绘制走完了才会将他置为true，才会跳出循环</span></span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   mDrawMonitor.wait(<span class="number">200</span>);<span class="comment">//onDraw没走完就会一直循环等待</span></span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (mDanmakuVisible == <span class="keyword">false</span> || handler == <span class="keyword">null</span> || handler.isStop()) &#123;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       Thread.currentThread().interrupt();</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           mDrawFinished = <span class="keyword">false</span>;<span class="comment">//绘制结束后，将标志位置为false，一边下次进入方法后再次进入上述等待逻辑</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postInvalidateCompat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       mRequestRender = <span class="keyword">true</span>;<span class="comment">//将mRequestRender 标志位置为true，一遍onDraw方法逻辑执行</span></span><br><span class="line">       <span class="comment">//通知view重绘</span></span><br><span class="line">       <span class="keyword">if</span>(Build.VERSION.SDK_INT &gt;= <span class="number">16</span>) &#123;</span><br><span class="line">           <span class="keyword">this</span>.postInvalidateOnAnimation();</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">this</span>.postInvalidate();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这样就能保证保证每隔一定时间（这个时间通过syncTimer计算），更新主定时器（就是从0开始，往后每次加上（间隔时间 + 绘制时间）），然后执行postInvalidate通知DanmakuView重绘。</p>
<p>&#160; &#160; &#160; &#160;postInvalidate后，View重绘，会重走onDraw方法，所以我们进入DanmakuView的onDraw方法看看：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DanmakuView的onDraw方法</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> ((!mDanmakuVisible) &amp;&amp; (!mRequestRender)) &#123;<span class="comment">//如果没有请求重绘则mRequestRender为false，不会绘制弹幕</span></span><br><span class="line">           <span class="keyword">super</span>.onDraw(canvas);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">	......</span><br><span class="line">           <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">               RenderingState rs = handler.draw(canvas);<span class="comment">//DrawHandler的draw方法</span></span><br><span class="line">			......</span><br><span class="line">           &#125;</span><br><span class="line">      ......</span><br><span class="line">       <span class="comment">//绘制结束后将mRequestRender 标志位重新设为false，</span></span><br><span class="line">       <span class="comment">//以便下一次发绘制消息时进入等待逻辑等候绘制结束，这个上面DanmakuView的drawDanmakus方法提到过</span></span><br><span class="line">       mRequestRender = <span class="keyword">false</span>;</span><br><span class="line">       unlockCanvasAndPost();<span class="comment">//通知UpdateThread绘制完成</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unlockCanvasAndPost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">synchronized</span> (mDrawMonitor) &#123;</span><br><span class="line">           mDrawFinished = <span class="keyword">true</span>;<span class="comment">//将mDrawFinished 置为true，以便DanmakuView的lockCanvas方法跳出循环，这个上面也提到过</span></span><br><span class="line">           mDrawMonitor.notifyAll();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;DanmakuView的onDraw回调逻辑会执行DrawHandler的draw方法，我们继续跟进去：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> RenderingState <span class="title">draw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line">      mDisp.setExtraData(canvas);<span class="comment">//将canvas一些信息设置给AndroidDisplayer</span></span><br><span class="line">      mRenderingState.set(drawTask.draw(mDisp));<span class="comment">//绘制部分是drawTask.draw(mDisp)</span></span><br><span class="line">      recordRenderingTime();<span class="comment">//记录绘制结束时间</span></span><br><span class="line">      <span class="keyword">return</span> mRenderingState;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//还记得上面的DrawHandler的syncTimer方法吗？里面调用了getAverageRenderingTime计算绘制平均间隔时间，</span></span><br><span class="line">  <span class="comment">//其中用到的mDrawTimes变量就是在这里添加元素的</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">recordRenderingTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">long</span> lastTime = SystemClock.uptimeMillis();</span><br><span class="line">      mDrawTimes.addLast(lastTime);<span class="comment">//将绘制结束时间加入到类型为LinkedList的mDrawTimes集合中</span></span><br><span class="line">      <span class="keyword">int</span> frames = mDrawTimes.size();</span><br><span class="line">      <span class="keyword">if</span> (frames &gt; MAX_RECORD_SIZE) &#123;<span class="comment">//最大容量为500个绘制时间，超出了则移除第一个</span></span><br><span class="line">          mDrawTimes.removeFirst();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;上述逻辑中，我的注释部分先分析了记录绘制结束时间部分，填了上边syncTimer时的坑。<br>&#160; &#160; &#160; &#160;然后应该进入主要绘制部分了drawTask.draw(mDisp)，也就是CacheManagingDrawTask的draw方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CacheManagingDrawTask的draw方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> RenderingState <span class="title">draw</span><span class="params">(AbsDisplayer displayer)</span> </span>&#123;</span><br><span class="line">       RenderingState result = <span class="keyword">super</span>.draw(displayer);<span class="comment">//会调用父类的draw方法</span></span><br><span class="line">	......</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//DrawTask的draw方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> RenderingState <span class="title">draw</span><span class="params">(AbsDisplayer displayer)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> drawDanmakus(displayer,mTimer);<span class="comment">//又调用了drawDanmakus方法</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//DrawTask的drawDanmakus方法</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> RenderingState <span class="title">drawDanmakus</span><span class="params">(AbsDisplayer disp, DanmakuTimer timer)</span> </span>&#123;</span><br><span class="line">	......</span><br><span class="line">       <span class="keyword">if</span> (danmakuList != <span class="keyword">null</span>) &#123;</span><br><span class="line">           Canvas canvas = (Canvas) disp.getExtraData();<span class="comment">//取出DanmakuView的canvas</span></span><br><span class="line">		<span class="comment">//当前时间 - 1屏弹幕时间 -100 （多减100是为了下次重新截取弹幕组时让绘制边界做到无缝衔接）</span></span><br><span class="line">           <span class="keyword">long</span> beginMills = timer.currMillisecond - mContext.mDanmakuFactory.MAX_DANMAKU_DURATION - <span class="number">100</span>;</span><br><span class="line">           <span class="comment">//当前时间 + 1屏弹幕时间</span></span><br><span class="line">           <span class="keyword">long</span> endMills = timer.currMillisecond + mContext.mDanmakuFactory.MAX_DANMAKU_DURATION;</span><br><span class="line">           <span class="comment">//每过了一屏的弹幕时间，就会进入如下if逻辑，截取以当前时间为基准的前后两屏弹幕；</span></span><br><span class="line">           <span class="comment">//如果距离上次截取时间不到一屏弹幕时间，则不会进入if的逻辑</span></span><br><span class="line">           <span class="keyword">if</span>(mLastBeginMills &gt; beginMills || timer.currMillisecond &gt; mLastEndMills) &#123;</span><br><span class="line">               IDanmakus subDanmakus = danmakuList.sub(beginMills, endMills);</span><br><span class="line">               <span class="keyword">if</span>(subDanmakus != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   danmakus = subDanmakus;</span><br><span class="line">               &#125;</span><br><span class="line">               mLastBeginMills = beginMills;</span><br><span class="line">               mLastEndMills = endMills;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;<span class="comment">//距离上次截取时间不到一屏时间</span></span><br><span class="line">		......</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (danmakus != <span class="keyword">null</span> &amp;&amp; !danmakus.isEmpty()) &#123;<span class="comment">//开始绘制弹幕</span></span><br><span class="line">               RenderingState renderingState = mRenderingState = mRenderer.draw(mDisp, danmakus, mStartRenderTime);</span><br><span class="line">		......</span><br><span class="line">		&#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;我们可以看到第一次进入会截取以当前时间为基准的前后两屏弹幕。以后每过一屏弹幕时间，会重新截取当时时间为基准的前后两屏弹幕，如果不到一屏时间则不截取，还是以前的弹幕数据。</p>
<p>&#160; &#160; &#160; &#160;截取完弹幕数据后，就是绘制了，继续执行下面逻辑(mRenderer.draw(mDisp, danmakus, mStartRenderTime))，开始绘制工作：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DanmakuRenderer的draw方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> RenderingState <span class="title">draw</span><span class="params">(IDisplayer disp, IDanmakus danmakus, <span class="keyword">long</span> startRenderTime)</span> </span>&#123;</span><br><span class="line">       ......       </span><br><span class="line">       IDanmakuIterator itr = danmakus.iterator();</span><br><span class="line">       ......      </span><br><span class="line"></span><br><span class="line">       BaseDanmaku drawItem = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">while</span> (itr.hasNext()) &#123;</span><br><span class="line"></span><br><span class="line">           drawItem = itr.next();</span><br><span class="line"></span><br><span class="line">		......</span><br><span class="line">		<span class="comment">//如果弹幕还没有到出现时间，则检查它有没有缓存，如果没有则为它建立缓存</span></span><br><span class="line">           <span class="keyword">if</span> (drawItem.isLate()) &#123;</span><br><span class="line">               IDrawingCache&lt;?&gt; cache = drawItem.getDrawingCache();</span><br><span class="line">               <span class="keyword">if</span> (mCacheManager != <span class="keyword">null</span> &amp;&amp; (cache == <span class="keyword">null</span> || cache.get() == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                   mCacheManager.addDanmaku(drawItem);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">		......</span><br><span class="line"></span><br><span class="line">           <span class="comment">// measure 测量，我们之前prepareCache已经为他们在buildCache是测量过了</span></span><br><span class="line">           <span class="keyword">if</span> (!drawItem.isMeasured()) &#123;</span><br><span class="line">               drawItem.measure(disp, <span class="keyword">false</span>);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// layout 布局，计算弹幕在屏幕上应该显示的位置</span></span><br><span class="line">           mDanmakusRetainer.fix(drawItem, disp, mVerifier);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// draw //绘制弹幕</span></span><br><span class="line">           <span class="keyword">if</span> (!drawItem.isOutside() &amp;&amp; drawItem.isShown()) &#123;</span><br><span class="line">               <span class="keyword">if</span> (drawItem.lines == <span class="keyword">null</span> &amp;&amp; drawItem.getBottom() &gt; disp.getHeight()) &#123;</span><br><span class="line">                   <span class="keyword">continue</span>;    <span class="comment">// skip bottom outside danmaku ，忽略超过视图底部的弹幕</span></span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//开始绘制</span></span><br><span class="line">               <span class="keyword">int</span> renderingType = drawItem.draw(disp);</span><br><span class="line">               <span class="keyword">if</span>(renderingType == IRenderer.CACHE_RENDERING) &#123;<span class="comment">//如果是使用缓存bitmap绘制的</span></span><br><span class="line">                   ......</span><br><span class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span>(renderingType == IRenderer.TEXT_RENDERING) &#123;<span class="comment">//如果使用缓存绘制失败，则会使用原声方法Canvas去draw</span></span><br><span class="line">                   ......</span><br><span class="line">                   <span class="keyword">if</span> (mCacheManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       mCacheManager.addDanmaku(drawItem);<span class="comment">//再次为词条弹幕构建缓存，以便下次使用缓存bitmap绘制</span></span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">			......</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;从截取的弹幕中遍历每一个，然后一一绘制。绘制步骤有如下几步：</p>
<ul>
<li>如果弹幕还没有到出现时间，则检查它有没有缓存，如果没有则为它建立缓存；</li>
<li>measure 测量，我们之前prepareCache已经为他们在buildCache时测量过了;</li>
<li>layout 布局，计算弹幕在屏幕上应该显示的位置；</li>
<li>draw 绘制弹幕。</li>
</ul>
<p>&#160; &#160; &#160; &#160;我们一步一步分析：<br>&#160; &#160; &#160; &#160;1）弹幕未到出现时间，检查是否建立缓存：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用CacheManagingDrawTask的addDanmaku方法</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addDanmaku</span><span class="params">(BaseDanmaku danmaku)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (mHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">			......</span><br><span class="line">			<span class="comment">//CacheHandler</span></span><br><span class="line">                  mHandler.obtainMessage(CacheHandler.ADD_DANMAKKU, danmaku).sendToTarget();</span><br><span class="line">            ......</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//CacheHandler</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">case</span> ADD_DANMAKKU:</span><br><span class="line">              BaseDanmaku item = (BaseDanmaku) msg.obj;</span><br><span class="line">              addDanmakuAndBuildCache(item);<span class="comment">//调用了addDanmakuAndBuildCache方法</span></span><br><span class="line">              <span class="keyword">break</span>;        </span><br><span class="line">      &#125;</span><br><span class="line">       <span class="comment">//调用了addDanmakuAndBuildCache方法</span></span><br><span class="line">          <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addDanmakuAndBuildCache</span><span class="params">(BaseDanmaku danmaku)</span> </span>&#123;</span><br><span class="line">           <span class="comment">//过时了 || 并且弹幕时间不在3屏弹幕时间内(因为mCaches只缓存了3屏时间内的所有弹幕，上面说过的),并且它不是直播弹幕。则不建立缓存</span></span><br><span class="line">              <span class="keyword">if</span> (danmaku.isTimeOut() || (danmaku.time &gt; mCacheTimer.currMillisecond + mContext.mDanmakuFactory.MAX_DANMAKU_DURATION &amp;&amp; !danmaku.isLive)) &#123;</span><br><span class="line">                  <span class="keyword">return</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">//优先级为0或者在过滤规则内，不建立缓存</span></span><br><span class="line">              <span class="keyword">if</span> (danmaku.priority == <span class="number">0</span> &amp;&amp; danmaku.isFiltered()) &#123;</span><br><span class="line">                  <span class="keyword">return</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              IDrawingCache&lt;?&gt; cache = danmaku.getDrawingCache();</span><br><span class="line">              <span class="keyword">if</span> (cache == <span class="keyword">null</span> || cache.get() == <span class="keyword">null</span>) &#123;<span class="comment">//如果弹幕没有缓存</span></span><br><span class="line">                  buildCache(danmaku, <span class="keyword">true</span>);<span class="comment">//建立缓存（buildCache方法我们上面分析过，就是用来建立缓存的）</span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;2）测量，这个我们上面再buildCache时分析过了，不再赘述；</p>
<p>&#160; &#160; &#160; &#160;3）布局：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用DanmakusRetainer的fix方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fix</span><span class="params">(BaseDanmaku danmaku, IDisplayer disp, Verifier verifier)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> type = danmaku.getType();</span><br><span class="line">       <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">           <span class="keyword">case</span> BaseDanmaku.TYPE_SCROLL_RL:</span><br><span class="line">               rldrInstance.fix(danmaku, disp, verifier);</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> BaseDanmaku.TYPE_SCROLL_LR:</span><br><span class="line">               lrdrInstance.fix(danmaku, disp, verifier);</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> BaseDanmaku.TYPE_FIX_TOP:</span><br><span class="line">               ftdrInstance.fix(danmaku, disp, verifier);</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> BaseDanmaku.TYPE_FIX_BOTTOM:</span><br><span class="line">               fbdrInstance.fix(danmaku, disp, verifier);</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> BaseDanmaku.TYPE_SPECIAL:</span><br><span class="line">               danmaku.layout(disp, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;类型太多了，我们只分析TYPE_SCROLL_RL类型弹幕其他的就不分析，有兴趣的可以自己分析一下其他的。接着会调用AlignTopRetainer的fix方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//保存需要显示的弹幕容器类（保存的一行只有一条弹幕，下面会说明的），内部持有一个以弹幕的y坐标排序的TreeSet集合，这个需要注意</span></span><br><span class="line"><span class="keyword">protected</span> Danmakus mVisibleDanmakus = <span class="keyword">new</span> Danmakus(Danmakus.ST_BY_YPOS);</span><br><span class="line">      </span><br><span class="line"><span class="comment">//AlignTopRetainer的fix方法</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fix</span><span class="params">(BaseDanmaku drawItem, IDisplayer disp, Verifier verifier)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (drawItem.isOutside())<span class="comment">//如果弹幕已经滚动到视图边界外，则不会为它布局</span></span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          <span class="keyword">float</span> topPos = <span class="number">0</span>;<span class="comment">//弹幕的y坐标</span></span><br><span class="line">          <span class="keyword">int</span> lines = <span class="number">0</span>;<span class="comment">//弹幕在第几行显示</span></span><br><span class="line">          <span class="keyword">boolean</span> shown = drawItem.isShown();<span class="comment">//弹幕是否已经显示</span></span><br><span class="line">          <span class="keyword">boolean</span> willHit = !shown &amp;&amp; !mVisibleDanmakus.isEmpty();<span class="comment">//是否会和其他弹幕碰撞</span></span><br><span class="line">          <span class="keyword">boolean</span> isOutOfVertialEdge = <span class="keyword">false</span>;<span class="comment">//弹幕y值是否超过试图高度</span></span><br><span class="line">          BaseDanmaku removeItem = <span class="keyword">null</span>;<span class="comment">//需要移除的弹幕</span></span><br><span class="line">          <span class="comment">//为即将显示的弹幕确认位置</span></span><br><span class="line">          <span class="keyword">if</span> (!shown) &#123;</span><br><span class="line">              mCancelFixingFlag = <span class="keyword">false</span>;</span><br><span class="line">              <span class="comment">// 确定弹幕位置开始</span></span><br><span class="line">              IDanmakuIterator it = mVisibleDanmakus.iterator();</span><br><span class="line">              <span class="comment">//这四个变量分别为：</span></span><br><span class="line">              <span class="comment">//insertItem ---- 确认目标弹幕插入到哪一行的同行参考弹幕</span></span><br><span class="line">              <span class="comment">//firstItem ---- 已经布局过的弹幕保存容器中的第一项</span></span><br><span class="line">              <span class="comment">//lastItem ---- 已经布局过的弹幕保存容器中最后一项</span></span><br><span class="line">              <span class="comment">//minRightRow ---- 已经布局过弹幕中x值最小的弹幕，即最左边的弹幕</span></span><br><span class="line">              BaseDanmaku insertItem = <span class="keyword">null</span>, firstItem = <span class="keyword">null</span>, lastItem = <span class="keyword">null</span>, minRightRow = <span class="keyword">null</span>;</span><br><span class="line">              <span class="keyword">boolean</span> overwriteInsert = <span class="keyword">false</span>;<span class="comment">//是否超出插入范围</span></span><br><span class="line">              <span class="comment">//遍历已经绘制过的弹幕，因为mVisibleDanmakus 内弹幕以y值排序的，所以按y值从小到大遍历</span></span><br><span class="line">              <span class="keyword">while</span> (!mCancelFixingFlag &amp;&amp; it.hasNext()) &#123;</span><br><span class="line">                  lines++;<span class="comment">//每次循环都会将行号+1</span></span><br><span class="line">                  BaseDanmaku item = it.next();</span><br><span class="line">                  </span><br><span class="line">                  <span class="keyword">if</span>(item == drawItem)&#123;<span class="comment">//如果已经布局过了，说明已经存在自己位置了</span></span><br><span class="line">                      insertItem = item;<span class="comment">//将布局过的弹幕复制给参考弹幕insertItem </span></span><br><span class="line">                      lastItem = <span class="keyword">null</span>;<span class="comment">//置空 lastItem </span></span><br><span class="line">                      shown = <span class="keyword">true</span>;<span class="comment">//shown 置为true，以便末尾不再执行加入mVisibleDanmakus逻辑</span></span><br><span class="line">                      willHit = <span class="keyword">false</span>;<span class="comment">//本身已经存在自己位置了，当然没有碰壁一说</span></span><br><span class="line">                      <span class="keyword">break</span>;<span class="comment">//怕被下面干扰晕的可以跳出去继续看</span></span><br><span class="line">                  &#125;</span><br><span class="line">			</span><br><span class="line">                  <span class="keyword">if</span> (firstItem == <span class="keyword">null</span>)<span class="comment">//找到已经布局过的弹幕第一项</span></span><br><span class="line">                      firstItem = item;</span><br><span class="line">			<span class="comment">//如果插入目标弹幕后，y值超过了视图高度</span></span><br><span class="line">                  <span class="keyword">if</span> (drawItem.paintHeight + item.getTop() &gt; disp.getHeight()) &#123;</span><br><span class="line">                      overwriteInsert = <span class="keyword">true</span>;<span class="comment">//则将超出插入范围标签置为true</span></span><br><span class="line">                      <span class="keyword">break</span>;<span class="comment">//怕晕的跳出循环</span></span><br><span class="line">                  &#125;</span><br><span class="line">			<span class="comment">//找出最左边的弹幕</span></span><br><span class="line">                  <span class="keyword">if</span> (minRightRow == <span class="keyword">null</span>) &#123;</span><br><span class="line">                      minRightRow = item;</span><br><span class="line">                  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                      <span class="keyword">if</span> (minRightRow.getRight() &gt;= item.getRight()) &#123;</span><br><span class="line">                          minRightRow = item;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">// 检查如果插入目标弹幕是否会和正在遍历的已经布局过的参考弹幕碰撞</span></span><br><span class="line">                  willHit = DanmakuUtils.willHitInDuration(disp, item, drawItem,</span><br><span class="line">                          drawItem.getDuration(), drawItem.getTimer().currMillisecond);</span><br><span class="line">                  <span class="keyword">if</span> (!willHit) &#123;<span class="comment">//如果没有碰撞</span></span><br><span class="line">                      insertItem = item;<span class="comment">//则将它复制给参考弹幕insertItem </span></span><br><span class="line">                      <span class="keyword">break</span>;<span class="comment">//然后跳出循环，下去确定位置</span></span><br><span class="line">                  &#125;<span class="comment">/*如果有碰撞，则继续弹幕缩小添加范围，寻找可以添加的条件，最后出while循环，下去布局*/</span></span><br><span class="line">                  </span><br><span class="line">			</span><br><span class="line">                  lastItem = item;<span class="comment">//暂时找到已经布局过的弹幕最后一项，然后继续循环</span></span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">boolean</span> checkEdge = <span class="keyword">true</span>;</span><br><span class="line">              <span class="keyword">if</span> (insertItem != <span class="keyword">null</span>) &#123;<span class="comment">//已经布局过了||目标弹幕不会碰壁可以插入</span></span><br><span class="line">                  <span class="keyword">if</span> (lastItem != <span class="keyword">null</span>)<span class="comment">//目标弹幕插入，y值即为上一次遍历的弹幕的底部</span></span><br><span class="line">                      topPos = lastItem.getBottom();</span><br><span class="line">                  <span class="keyword">else</span><span class="comment">//已经布局过了，则y的位置不变</span></span><br><span class="line">                      topPos = insertItem.getTop();</span><br><span class="line">                      </span><br><span class="line">                  <span class="keyword">if</span> (insertItem != drawItem)&#123;<span class="comment">//如果目标弹幕可以插入</span></span><br><span class="line">                   <span class="comment">//这里需要注意，因为一行可以放n多条弹幕，只要前后不碰撞就行；</span></span><br><span class="line">                   <span class="comment">//所以下次我们在同一行插入弹幕判断碰壁时，当然要和这行最后一条弹幕去判断；</span></span><br><span class="line">                   <span class="comment">//因此我们移除前一条弹幕，放入插入的目标弹幕，下次添加弹幕判断时就和目标弹幕判断，然后这么循环下去</span></span><br><span class="line">                      removeItem = insertItem;</span><br><span class="line">                      </span><br><span class="line">                      shown = <span class="keyword">false</span>;<span class="comment">//置为false，以便mVisibleDanmakus 添加还未布局的新弹幕</span></span><br><span class="line">                  &#125;</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (overwriteInsert &amp;&amp; minRightRow != <span class="keyword">null</span>) &#123;<span class="comment">//没有空行可以插入</span></span><br><span class="line">                  topPos = minRightRow.getTop();<span class="comment">//暂时放到最最左边的弹幕那一行（excuse me ？？？）</span></span><br><span class="line">                  checkEdge = <span class="keyword">false</span>;<span class="comment">//不做范围检查</span></span><br><span class="line">                  shown = <span class="keyword">false</span>;</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lastItem != <span class="keyword">null</span>) &#123;<span class="comment">//找不到插入的位置</span></span><br><span class="line">                  topPos = lastItem.getBottom();<span class="comment">//暂时放到最低位置的弹幕下面，下面检测边界时会酌情河蟹</span></span><br><span class="line">                  willHit = <span class="keyword">false</span>;<span class="comment">//置false碰壁标志</span></span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstItem != <span class="keyword">null</span>) &#123;<span class="comment">////mVisibleDanmakus只有第一条数据，截取弹幕集的第二条弹幕没有和第一条碰壁时</span></span><br><span class="line">                  topPos = firstItem.getTop();<span class="comment">//此时第二条弹幕和第一条在同一行</span></span><br><span class="line">                  removeItem = firstItem;</span><br><span class="line">                  shown = <span class="keyword">false</span>;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;<span class="comment">//mVisibleDanmakus 没有数据，截取弹幕集的第一条弹幕</span></span><br><span class="line">                  topPos = <span class="number">0</span>;<span class="comment">//第一条弹幕当然在最上面</span></span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (checkEdge) &#123;<span class="comment">//如果检查范围</span></span><br><span class="line">               <span class="comment">//检查是否超出布局范围</span></span><br><span class="line">                  isOutOfVertialEdge = isOutVerticalEdge(overwriteInsert, drawItem, disp, topPos, firstItem,</span><br><span class="line">                          lastItem);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (isOutOfVertialEdge) &#123;<span class="comment">//如果超出布局范围，等待河蟹</span></span><br><span class="line">                  topPos = <span class="number">0</span>;</span><br><span class="line">                  willHit = <span class="keyword">true</span>;</span><br><span class="line">                  lines = <span class="number">1</span>;</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (removeItem != <span class="keyword">null</span>) &#123;<span class="comment">//上面可以插入目标弹幕的逻辑用上了</span></span><br><span class="line">                  lines--;<span class="comment">//因为参考弹幕和目标弹幕在同一行，但是每进入while循环一次就将行号+1，所有要减回去和参考弹幕保持相同行号</span></span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (topPos == <span class="number">0</span>) &#123;<span class="comment">//方便加入容器</span></span><br><span class="line">                  shown = <span class="keyword">false</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">	<span class="comment">//这是河蟹规则，都是在设置DanmakuContext时指定的，比如最大行数限制，重复限制等等。</span></span><br><span class="line">	<span class="comment">//这里限于篇幅已经太长了，也实在写不动了，就不再跟下去了。内部逻辑也不难，大家有兴趣可以自己看看。</span></span><br><span class="line">          <span class="keyword">if</span> (verifier != <span class="keyword">null</span> &amp;&amp; verifier.skipLayout(drawItem, topPos, lines, willHit)) &#123;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (isOutOfVertialEdge) &#123;<span class="comment">//mVisibleDanmakus中所有弹幕绘制出来都超出范围了</span></span><br><span class="line">              clear();</span><br><span class="line">          &#125;</span><br><span class="line">	<span class="comment">//这才是真正确认弹幕位置的地方</span></span><br><span class="line">          drawItem.layout(disp, drawItem.getLeft(), topPos);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (!shown) &#123;<span class="comment">//如果还未显示，则加入即将显示的容器中。可以看到，最终会把所有截取的弹幕加入到这个容器里</span></span><br><span class="line">              mVisibleDanmakus.removeItem(removeItem);<span class="comment">//移除同一行之前的参考弹幕，保持保存的一行只有一条弹幕，上面说明过</span></span><br><span class="line">              mVisibleDanmakus.addItem(drawItem);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//清除容器，重新放入新的内容</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          mCancelFixingFlag = <span class="keyword">true</span>;</span><br><span class="line">          mVisibleDanmakus.clear();</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这绝对是我写的注释最多的方法了ToT。。。。。。其实思路挺好理解的，通俗地讲就是这样的过程：</p>
<ul>
<li><strong>先添往最第一行添加一条弹幕，把它存到一个容器里（这个容器会把新添加进来的弹幕按照y值从小到大排序，而且容器只保存每一行的最后一条弹幕）</strong>。</li>
<li><strong>然后添加第二条弹幕，从第一行开始添加，先判断和第一条弹幕会不会碰壁，如果不会碰壁则添加到这一行，然后容器内移除之前第一条的弹幕，保存这一条弹幕；如果会碰壁则添加到下一行，然后容器保存这条弹幕</strong>；</li>
<li><strong>然后添加第三条，继续从第一行开始添加，先判断和第一条……(重复第二条的逻辑)……</strong>；<br>。。。。。。</li>
</ul>
<p>&#160; &#160; &#160; &#160;就是这么个思路，但是写起来真心不是随意就能写出来的。即使先不说写，把这个思路想出来，让我去设计一套规则，估计都相当困难啊。唉，人与人之间的差距始终在思维。。。。。。</p>
<p>&#160; &#160; &#160; &#160;扯远了，我们继续回归正题，上面逻辑完成了弹幕定位规则(内部那个layout接下来再讲)，限于篇幅，我只挑一个检查碰撞的代码贴出来分析，其它的请有兴趣者自行跟踪。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">willHitInDuration</span><span class="params">(IDisplayer disp, BaseDanmaku d1, BaseDanmaku d2,</span><br><span class="line">          <span class="keyword">long</span> duration, <span class="keyword">long</span> currTime)</span> </span>&#123;<span class="comment">//disp, item, drawItem, drawItem.getDuration(), drawItem.getTimer().currMillisecond</span></span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> type1 = d1.getType();</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> type2 = d2.getType();</span><br><span class="line">      <span class="comment">// allow hit if different type 不同类型的弹幕允许碰撞</span></span><br><span class="line">      <span class="keyword">if</span>(type1 != type2)</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span>(d1.isOutside())&#123;<span class="comment">//item已经跑出视图了，不存在碰撞问题</span></span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">long</span> dTime = d2.time - d1.time;</span><br><span class="line">      <span class="keyword">if</span> (dTime &lt;= <span class="number">0</span>)<span class="comment">//drawItem在item前面，已经碰撞了</span></span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      <span class="comment">//两者出现时间已经相差一条弹幕时间了 || item超时跑出去了 || drawItem超时 ，都不会碰撞    </span></span><br><span class="line">      <span class="keyword">if</span> (Math.abs(dTime) &gt;= duration || d1.isTimeOut() || d2.isTimeOut()) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//item和drawItem都是顶部或者底部固定弹幕，因为在同一行，必定碰撞</span></span><br><span class="line">      <span class="keyword">if</span> (type1 == BaseDanmaku.TYPE_FIX_TOP || type1 == BaseDanmaku.TYPE_FIX_BOTTOM) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//调用checkHitAtTime方法</span></span><br><span class="line">      <span class="keyword">return</span> checkHitAtTime(disp, d1, d2, currTime) </span><br><span class="line">              || checkHitAtTime(disp, d1, d2,  d1.time + d1.getDuration());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//调用checkHitAtTime方法</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkHitAtTime</span><span class="params">(IDisplayer disp, BaseDanmaku d1, BaseDanmaku d2, <span class="keyword">long</span> time)</span></span>&#123;<span class="comment">//time = currTime || time = item.time + item.duration</span></span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">float</span>[] rectArr1 = d1.getRectAtTime(disp, time);<span class="comment">//time获得item在视图的（l，t，r，b）</span></span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">float</span>[] rectArr2 = d2.getRectAtTime(disp, time);<span class="comment">//time获得drawItem在视图的（l，t，r，b）</span></span><br><span class="line">      <span class="keyword">if</span> (rectArr1 == <span class="keyword">null</span> || rectArr2 == <span class="keyword">null</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">return</span> checkHit(d1.getType(), d2.getType(), rectArr1, rectArr2);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//调用checkHit方法    </span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkHit</span><span class="params">(<span class="keyword">int</span> type1, <span class="keyword">int</span> type2, <span class="keyword">float</span>[] rectArr1,</span><br><span class="line">          <span class="keyword">float</span>[] rectArr2)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(type1 != type2)</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">if</span> (type1 == BaseDanmaku.TYPE_SCROLL_RL) &#123;<span class="comment">//只要drawItem的left小于item的right就碰撞了</span></span><br><span class="line">          <span class="comment">// hit if left2 &lt; right1</span></span><br><span class="line">          <span class="keyword">return</span> rectArr2[<span class="number">0</span>] &lt; rectArr1[<span class="number">2</span>];</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (type1 == BaseDanmaku.TYPE_SCROLL_LR)&#123;</span><br><span class="line">          <span class="comment">// hit if right2 &gt; left1</span></span><br><span class="line">          <span class="keyword">return</span> rectArr2[<span class="number">2</span>] &gt; rectArr1[<span class="number">0</span>];</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//R2LDanmaku的getRectAtTime方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">float</span>[] getRectAtTime(IDisplayer displayer, <span class="keyword">long</span> time) &#123;<span class="comment">//time = currTime || time = item.time + item.duration</span></span><br><span class="line">      <span class="keyword">if</span> (!isMeasured())</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">float</span> left = getAccurateLeft(displayer, time);<span class="comment">//获得此时弹幕在视图的x坐标</span></span><br><span class="line">      <span class="keyword">if</span> (RECT == <span class="keyword">null</span>) &#123;</span><br><span class="line">          RECT = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">4</span>];</span><br><span class="line">      &#125;</span><br><span class="line">      RECT[<span class="number">0</span>] = left;<span class="comment">//left</span></span><br><span class="line">      RECT[<span class="number">1</span>] = y;<span class="comment">//top</span></span><br><span class="line">      RECT[<span class="number">2</span>] = left + paintWidth;<span class="comment">//right</span></span><br><span class="line">      RECT[<span class="number">3</span>] = y + paintHeight;<span class="comment">//bottom</span></span><br><span class="line">      <span class="keyword">return</span> RECT;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//R2LDanmaku的getAccurateLeft方法</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">float</span> <span class="title">getAccurateLeft</span><span class="params">(IDisplayer displayer, <span class="keyword">long</span> currTime)</span> </span>&#123;<span class="comment">//currTime = timer.currTime || currTime = item.time + item.duration</span></span><br><span class="line">      <span class="keyword">long</span> elapsedTime = currTime - time;<span class="comment">//当前时间 - 弹幕出现时间</span></span><br><span class="line">......</span><br><span class="line"><span class="comment">//因此返回弹幕位于视图的x坐标，即视图宽度 - 弹幕已经显示了多少秒 * 每秒移动步长</span></span><br><span class="line"><span class="keyword">return</span> displayer.getWidth() - elapsedTime * mStepX;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;检查碰撞逻辑比较简单，就是先根据当前时间就算出两条弹幕的位置（l1，t1，r1，b1），看看是否前面弹幕的 r1 小于后面弹幕的 l1；再根据前面弹幕的结束时间，计算出两条弹幕的位置（l2，t2，r2，b2）再次看看是否前面弹幕的 r2小于后面弹幕的 l2。只有两条都满足才不会碰撞。</p>
<p>&#160; &#160; &#160; &#160;好了检测碰撞就先到这里，然后继续回到AlignTopRetainer的fix方法，还有一个drawItem.layout(disp, drawItem.getLeft(), topPos);没讲呢，这才是真正确认弹幕位置的地方，继续查看L2RDanmaku的layout方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">layout</span><span class="params">(IDisplayer displayer, <span class="keyword">float</span> x, <span class="keyword">float</span> y)</span> </span>&#123;<span class="comment">//disp, drawItem.getLeft(), topPos</span></span><br><span class="line">    <span class="keyword">if</span> (mTimer != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">long</span> currMS = mTimer.currMillisecond;</span><br><span class="line">        <span class="keyword">long</span> deltaDuration = currMS - time;<span class="comment">//计算出出现时间和当前时间的时间差</span></span><br><span class="line">        <span class="keyword">if</span> (deltaDuration &gt; <span class="number">0</span> &amp;&amp; deltaDuration &lt; duration.value) &#123;<span class="comment">//如果还没有到出现时间或者超出弹幕时间</span></span><br><span class="line">            <span class="keyword">this</span>.x = getAccurateLeft(displayer, currMS);<span class="comment">//计算出当前时间弹幕的x坐标，上面刚讲过</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.isShown()) &#123;</span><br><span class="line">                <span class="keyword">this</span>.y = y;<span class="comment">//把上面计算好的y值赋过来</span></span><br><span class="line">                <span class="keyword">this</span>.setVisibility(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            mLastTime = currMS;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mLastTime = currMS;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.setVisibility(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这样弹幕的位置也就确定了，layout步骤就走完了。下一步就是draw步骤了。</p>
<p>&#160; &#160; &#160; &#160;4）绘制弹幕：<br>&#160; &#160; &#160; &#160;赶紧回到DanmakuRenderer的draw方法，这个时候千万不要把自己搞晕了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DanmakuRenderer的draw方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RenderingState <span class="title">draw</span><span class="params">(IDisplayer disp, IDanmakus danmakus, <span class="keyword">long</span> startRenderTime)</span> </span>&#123;</span><br><span class="line">        ......       </span><br><span class="line">        IDanmakuIterator itr = danmakus.iterator();</span><br><span class="line">        ......      </span><br><span class="line"></span><br><span class="line">        BaseDanmaku drawItem = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (itr.hasNext()) &#123;</span><br><span class="line"></span><br><span class="line">            drawItem = itr.next();</span><br><span class="line"></span><br><span class="line">			......</span><br><span class="line">			...检查是否建立缓存...            </span><br><span class="line">			......</span><br><span class="line"></span><br><span class="line">            ...是否测量...</span><br><span class="line"></span><br><span class="line">            ...layout布局...</span><br><span class="line"></span><br><span class="line">            <span class="comment">// draw //绘制弹幕</span></span><br><span class="line">            <span class="keyword">if</span> (!drawItem.isOutside() &amp;&amp; drawItem.isShown()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (drawItem.lines == <span class="keyword">null</span> &amp;&amp; drawItem.getBottom() &gt; disp.getHeight()) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;    <span class="comment">// skip bottom outside danmaku ，忽略超过视图底部的弹幕</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//开始绘制</span></span><br><span class="line">                <span class="keyword">int</span> renderingType = drawItem.draw(disp);</span><br><span class="line">                <span class="keyword">if</span>(renderingType == IRenderer.CACHE_RENDERING) &#123;<span class="comment">//如果是使用缓存bitmap绘制的</span></span><br><span class="line">                    ......</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(renderingType == IRenderer.TEXT_RENDERING) &#123;<span class="comment">//如果使用缓存绘制失败，则会使用原声方法Canvas去draw</span></span><br><span class="line">                    ......</span><br><span class="line">                    <span class="keyword">if</span> (mCacheManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        mCacheManager.addDanmaku(drawItem);<span class="comment">//再次为词条弹幕构建缓存，以便下次使用缓存bitmap绘制</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">				......    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;继续跟踪int renderingType = drawItem.draw(disp) 这里：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BaseDanmaku的draw方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">draw</span><span class="params">(IDisplayer displayer)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> displayer.draw(<span class="keyword">this</span>);<span class="comment">//调用AndroidDisplayer的draw方法</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//调用AndroidDisplayer的draw方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">draw</span><span class="params">(BaseDanmaku danmaku)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">float</span> top = danmaku.getTop();<span class="comment">//弹幕在视图的y值</span></span><br><span class="line">       <span class="keyword">float</span> left = danmaku.getLeft();<span class="comment">//弹幕在视图的x值</span></span><br><span class="line">       <span class="keyword">if</span> (canvas != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">		......</span><br><span class="line">			</span><br><span class="line">           <span class="comment">// drawing cache</span></span><br><span class="line">           <span class="keyword">boolean</span> cacheDrawn = <span class="keyword">false</span>;</span><br><span class="line">           <span class="keyword">int</span> result = IRenderer.CACHE_RENDERING;</span><br><span class="line">           IDrawingCache&lt;?&gt; cache = danmaku.getDrawingCache();</span><br><span class="line">           <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;<span class="comment">//如果弹幕有缓存</span></span><br><span class="line">            <span class="comment">//取出缓存</span></span><br><span class="line">               DrawingCacheHolder holder = (DrawingCacheHolder) cache.get();</span><br><span class="line">               <span class="keyword">if</span> (holder != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//DrawingCacheHolder的draw方法，我们在上面的buildCache时分析过了，将每一条弹幕的bitmap绘制到视图的canvas上</span></span><br><span class="line">                   cacheDrawn = holder.draw(canvas, left, top, alphaPaint);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (!cacheDrawn) &#123;<span class="comment">//如果缓存绘制失败</span></span><br><span class="line">			......</span><br><span class="line">			<span class="comment">//则使用Android原生的canvas.drawText等方法绘制，drawDanmaku方法我们上面buildCache时也分析过</span></span><br><span class="line">               drawDanmaku(danmaku, canvas, left, top, <span class="keyword">false</span>);</span><br><span class="line">               result = IRenderer.TEXT_RENDERING;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">return</span> result;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> IRenderer.NOTHING_RENDERING;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;上面逻辑比较简单，先查看弹幕有没有缓存，如果有，就使用缓存绘制。在上面的buildCache时我们知道，缓存绘制的每一条弹幕都是一条bitmap，所以这里用缓存也是将bitmap绘制到视图的Canvas中。如果使用缓存绘制失败，会调用drawDanmaku方法，这个方法我们在上面的buildCache也分析过，则使用Android原生的canvas.drawText等绘制。</p>
<p>&#160; &#160; &#160; &#160;这样弹幕就被绘制到视图界面上了。        </p>
<p>&#160; &#160; &#160; &#160;终于完了，以上就是DanmakuFlameMaster的流程分析过程了，分析的快吐学了ToT。。。。。。</p>
<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><p>&#160; &#160; &#160; &#160;上面刚开始奖CacheManagingDrawTask时曾经说过，也可以不用CacheManagingDrawTask，直接使用DrawTask，只要将<strong>DanmakuView</strong>的<strong>mEnableDanmakuDrwaingCache</strong>变量改为false就可以了。这样改动之后就用不上工程里那些so库了，也就不用建立那么复杂的缓存机制。</p>
<p>&#160; &#160; &#160; &#160;还有一点区别就是使用CacheManagingDrawTask画出来的每一条弹幕都是bitmap，而用DrawTask的弹幕都是Canvas.drawText画出来的。</p>
<p>&#160; &#160; &#160; &#160;限于篇幅，DrawTask就不分析了，逻辑比CacheManagingDrawTask简单多了，大家有兴趣的自己看看。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>&#160; &#160; &#160; &#160;DanmakuFlameMaster到此就分析完全了，简单总结一下流程就是：</p>
<ul>
<li>加载弹幕资源</li>
<li>开启缓存机制，不断建立缓存和回收</li>
<li>开始绘制任务，根据定时器时间确定弹幕位置，绘制弹幕</li>
</ul>
<p>&#160; &#160; &#160; &#160;这篇文章写的过程中也是十分蛋疼的，写的我差点over了。因为DanmakuFlameMaster源码实在太复杂了，坑非常多，所以很多细节都没有顾及。下次我绝对不会再写这么长的文章了，身体和脑力真心伤不起啊。赶紧休息一下<del>~</del>~~~~</p>

      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2016/07/02/DanmakuFlameMaster简单分析/">弹幕框架DanmakuFlameMaster简单分析</a></p>
        <p><span>文章作者:</span><a href="/" title="回到主页">windrunnerlihuan</a></p>
        <p><span>发布时间:</span>2016-07-02, 20:13:04</p>
        <p><span>最后更新:</span>2016-07-07, 06:27:30</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2016/07/02/DanmakuFlameMaster简单分析/" title="弹幕框架DanmakuFlameMaster简单分析">http://windrunnerlihuan.com/2016/07/02/DanmakuFlameMaster简单分析/</a>
            <span class="copy-path" data-clipboard-text="原文: http://windrunnerlihuan.com/2016/07/02/DanmakuFlameMaster简单分析/　　作者: windrunnerlihuan" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target = "_blank">"署名-非商用-相同方式共享 4.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



    <nav id="article-nav">
        
            <div id="article-nav-newer" class="article-nav-title">
                <a href="/2016/07/12/浅析Bitmap占据内存大小/">
                    浅析Bitmap占据内存大小
                </a>
            </div>
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/2016/06/24/Android属性动画原理分析/">
                    Android属性动画流程分析
                </a>
            </div>
        
    </nav>

  
</article>

    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#基本使用"><span class="toc-number">1.</span> <span class="toc-text">基本使用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#流程分析"><span class="toc-number">2.</span> <span class="toc-text">流程分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#初始配置"><span class="toc-number">2.1.</span> <span class="toc-text">初始配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#加载资源"><span class="toc-number">2.2.</span> <span class="toc-text">加载资源</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#启动弹幕"><span class="toc-number">2.3.</span> <span class="toc-text">启动弹幕</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CacheManagingDrawTask绘制任务"><span class="toc-number">2.3.1.</span> <span class="toc-text">CacheManagingDrawTask绘制任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#缓存机制"><span class="toc-number">2.3.2.</span> <span class="toc-text">缓存机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#绘制弹幕界面"><span class="toc-number">2.3.3.</span> <span class="toc-text">绘制弹幕界面</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TODO"><span class="toc-number">2.4.</span> <span class="toc-text">TODO</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#结语"><span class="toc-number">3.</span> <span class="toc-text">结语</span></a></li></ol>
</div>
<style>
    .left-col .switch-btn {
        display: none;
    }
    .left-col .switch-area {
        display: none;
    }
</style>

<input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">
<script>
    var valueHide = "隐藏目录";
    var valueShow = "显示目录";

    if ($(".left-col").is(":hidden")) {
        $("#tocButton").attr("value", valueShow);
    }

    $("#tocButton").click(function() {
        if ($("#toc").is(":hidden")) {
            $("#tocButton").attr("value", valueHide);
            $("#toc").slideDown(320);
            $(".switch-btn, .switch-area").fadeOut(300);
        }
        else {
            $("#tocButton").attr("value", valueShow);
            $("#toc").slideUp(350);
            $(".switch-btn, .switch-area").fadeIn(500);
        }
    })

    if ($(".toc").length < 1) {
        $("#toc, #tocButton").hide();
        $(".switch-btn, .switch-area").show();
    }
</script>





    
<div class="share">
    
        <div class="bdsharebuttonbox">
            <a href="#" class="fa fa-twitter bds_twi" data-cmd="twi" title="分享到推特"></a>
            <a href="#" class="fa fa-weibo bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
            <a href="#" class="fa fa-qq bds_sqq" data-cmd="sqq" title="分享给 QQ 好友"></a>
            <a href="#" class="fa fa-files-o bds_copy" data-cmd="copy" title="复制网址"></a>
            <a href="#" class="fa fa fa-envelope-o bds_mail" data-cmd="mail" title="通过邮件分享"></a>
            <a href="#" class="fa fa-weixin bds_weixin" data-cmd="weixin" title="生成文章二维码"></a>
            <a href="#" class="fa fa-share-alt bds_more" data-cmd="more"></i></a>
        </div>
        <script>
            window._bd_share_config={
                "common":{"bdSnsKey":{},"bdText":"弹幕框架DanmakuFlameMaster简单分析　| April is your lie　","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
        </script>
    

    
</div>







    
      <div class="duoshuo" id="comments">
    <!-- ��˵���ۿ� start -->
    <div class="ds-thread" data-thread-key="2016/07/02/DanmakuFlameMaster简单分析/" data-title="弹幕框架DanmakuFlameMaster简单分析" data-url="http://windrunnerlihuan.com/2016/07/02/DanmakuFlameMaster简单分析/"></div>
    <!-- ��˵���ۿ� end -->
    <!-- ��˵����JS���� start (һ����ҳֻ������һ��) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:"windrunnerlihuan"};
    (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = 'http://windrunnerlihuan.com/js/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
    </script>
    <!-- ��˵����JS���� end -->
</div>

    




    <div class="scroll" id="post-nav-button">
        
            <a href="/2016/07/12/浅析Bitmap占据内存大小/" title="上一篇: 浅析Bitmap占据内存大小">
                <i class="fa fa-angle-left"></i>
            </a>
        

        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/2016/06/24/Android属性动画原理分析/" title="下一篇: Android属性动画流程分析">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/09/05/插件开发中的资源问题分析及填坑处理/">插件开发中的资源问题分析及填坑处理</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/23/智能指针简单分析/">智能指针简单分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/31/Android消息机制零散分析/">Android消息处理零散分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/12/浅析Bitmap占据内存大小/">浅析Bitmap占据内存大小</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/02/DanmakuFlameMaster简单分析/">弹幕框架DanmakuFlameMaster简单分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/24/Android属性动画原理分析/">Android属性动画流程分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/12/Binder简要分析/">Android跨进程通信机制Binder简要分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/06/移动直播技术秒开优化经验/">移动直播技术秒开优化经验</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/27/博客搭建历程/">博客搭建历程————————Github和Hexo</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/27/新的开始/">新的开始</a></li></ul>




    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2016 windrunnerlihuan
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.0">Yelee</a> by HuanLi & MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" >本站到访数: 
                            <span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>, </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit">本页阅读量: 
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
    <script src="/js/GithubRepoWidget.js"></script>

<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>




    <script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>