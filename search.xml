<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[插件开发中的资源问题分析及填坑处理]]></title>
      <url>http://windrunnerlihuan.com/2016/09/05/%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E8%B5%84%E6%BA%90%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E5%8F%8A%E5%A1%AB%E5%9D%91%E5%A4%84%E7%90%86/</url>
      <content type="html"><![CDATA[<p>&#160; &#160; &#160; &#160;做插件开发有两个问题需要解决，一个是资源文件加载，另一个是关于四大组件生命周期的管理。这里我们就简单分析会遇到那些坑，和一些简单的处理方法或者思路。<br><a id="more"></a><br>&#160; &#160; &#160; &#160;插件开发目前已经不是什么最新技术了，目前市面上已有很多成熟的方案和开源工程，比如<code>任玉刚</code>的<a href="https://github.com/singwhatiwanna/dynamic-load-apk" target="_blank" rel="external">dynamic-load-apk</a>、阿里的<a href="https://github.com/alibaba/AndFix" target="_blank" rel="external">AndFix</a>和<a href="https://github.com/alibaba/dexposed" target="_blank" rel="external">dexposed</a>、360的<a href="https://github.com/Qihoo360/DroidPlugin" target="_blank" rel="external">DroidPlugin</a>、QQ空间的<a href="https://github.com/jasonross/Nuwa" target="_blank" rel="external">nuwa</a>。各家实现方案也是各有不同，这些开源库大多已经广泛应用于很多市面上的软件。<br>&#160; &#160; &#160; &#160;说到未来，不得不提一下<strong>ReactNative</strong>，移动应用web化一定是一个必然的趋势，就好像曾经的桌面应用由C/S到B/S的转变。而怎么web化才是关键之处。但目前<strong>RN</strong>在IOS开发中优势很明显，在Android中却是挖坑不断。</p>
<h1 id="普通插件开发"><a href="#普通插件开发" class="headerlink" title="普通插件开发"></a>普通插件开发</h1><h2 id="开发前提"><a href="#开发前提" class="headerlink" title="开发前提"></a>开发前提</h2><p>&#160; &#160; &#160; &#160;Android为我们从ClassLoader派生出了两个类：<strong>DexClassLoader</strong>和<strong>PathClassLoader</strong>。在加载类的时候，是执行父类ClassLoader的loadClass方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String className, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    Class&lt;?&gt; clazz = findLoadedClass(className);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            clazz = parent.loadClass(className, <span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// Don't want to see this.</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">            clazz = findClass(className);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> clazz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;因此DexClassLoader和PathClassLoader都属于符合双亲委派模型的类加载器（因为它们没有重载loadClass方法）。也就是说，它们在加载一个类之前，回去检查自己以及自己以上的类加载器是否已经加载了这个类。如果已经加载过了，就会直接将之返回，而不会重复加载。<br>&#160; &#160; &#160; &#160;这两者的区别在于DexClassLoader需要提供一个可写的outpath路径，用来释放.apk包或者.jar包中的dex文件。换个说法来说，就是PathClassLoader不能主动从zip包中释放出dex，因此只支持直接操作dex格式文件，或者已经安装的apk（因为已经安装的apk在cache中存在缓存的dex文件）。而DexClassLoader可以支持.apk、.jar和.dex文件，并且会在指定的outpath路径释放出dex文件。<br>&#160; &#160; &#160; &#160;因此，我们要实现插件开发，需要用DexClassLoader。</p>
<h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h2><p>&#160; &#160; &#160; &#160;如果只需要加载插件apk中一个普通的类，只要构造一个DexClassLoader，它的构造方法对每个参数已经说明的很清楚了，我们可以试验一下。<br>&#160; &#160; &#160; &#160;新建一个插件工程TestPlugin，里面放一个类Plugin.java，再放一个简单的方法，即TestPlugin/src/com/example/plugin/Plugin.java：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Plugin</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getCommonStr</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"COMMON"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;然后新建一个宿主工程TestHost，在MainActivity里面写一个加载插件的方法，即TestHost/src/com/example/host/MainActivity.java:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">		setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">		loadPluginClass();		</span><br><span class="line">	&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadPluginClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	......</span><br><span class="line">	<span class="comment">//定义DexClassLoader  </span></span><br><span class="line">    <span class="comment">//第一个参数：是dex压缩文件的路径  </span></span><br><span class="line">    <span class="comment">//第二个参数：是dex解压缩后存放的目录  </span></span><br><span class="line">    <span class="comment">//第三个参数：是C/C++依赖的本地库文件目录,可以为null  </span></span><br><span class="line">    <span class="comment">//第四个参数：是上一级的类加载器  </span></span><br><span class="line">	DexClassLoader dexClassLoader = <span class="keyword">new</span> DexClassLoader(<span class="keyword">this</span>.getCacheDir().getAbsolutePath() + File.separator + <span class="string">"TestPlugin.apk"</span>,</span><br><span class="line">	<span class="keyword">this</span>.getCacheDir().getAbsolutePath(), <span class="keyword">null</span>, getApplicationContext().getClassLoader());</span><br><span class="line">	Class&lt;?&gt; pluginClass = dexClassLoader .loadClass(<span class="string">"com.example.plugin.Plugin"</span>);</span><br><span class="line">	<span class="keyword">if</span>(pluginClass == <span class="keyword">null</span>)&#123;</span><br><span class="line">		Log.e(TAG, <span class="string">"plugin class cann't be found"</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Object pluginObject = pluginClass.newInstance();</span><br><span class="line"></span><br><span class="line">	Method pluginMethod = pluginClass.getMethod(<span class="string">"getCommonStr"</span>);</span><br><span class="line">	<span class="keyword">if</span>(pluginMethod == <span class="keyword">null</span>)&#123;</span><br><span class="line">		Log.e(TAG, <span class="string">"plugin method cann't be found"</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	String methodStr = (String) pluginMethod .invoke(pluginObject);</span><br><span class="line">	Log.e(TAG, <span class="string">"Print Method str = "</span> + methodStr);</span><br><span class="line"></span><br><span class="line">	......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;先安装宿主程序TestHost.apk，然后将插件TestPlugin.apk放到/data/data/com.example.host/cache/下面，再次运行宿主程序，会打印如下log：<br>&#160; &#160; &#160; &#160;Print Method str = COMMON<br>&#160; &#160; &#160; &#160;这个应该比较随意了，会使用DexClassLoader这个类的开发者都是轻车熟路。</p>
<h2 id="加载资源"><a href="#加载资源" class="headerlink" title="加载资源"></a>加载资源</h2><h3 id="普通资源"><a href="#普通资源" class="headerlink" title="普通资源"></a>普通资源</h3><p>&#160; &#160; &#160; &#160;我们知道插件apk中的资源文件是无法直接加载的，因为插件apk并没有安装，所以没有给每个资源生成特定的资源id，所以我们没法使用R.XXX去引用。<br>&#160; &#160; &#160; &#160;不过我们通过android系统安装apk时对资源文件的处理流程中发现可以通过AssetManager这个类完成对插件中资源的引用。Java的源码中发现，它有一个私有方法addAssetPath，只需要将apk的路径作为参数传入，我们就可以获得对应的AssetsManager对象，然后我们就可以使用AssetsManager对象，创建一个Resources对象，然后就可以从Resource对象中访问apk中的资源了。总结如下：</p>
<ul>
<li>新建一个AssetManager对象</li>
<li>通过反射调用addAssetPath方法</li>
<li>以AssetsManager对象为参数，创建Resources对象即可</li>
</ul>
<p>&#160; &#160; &#160; &#160;我们测试demo可以写一个工具类，省略了一部分，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PluginBaseImpl</span> <span class="keyword">extends</span> <span class="title">PluginBase</span> </span>&#123;</span><br><span class="line">	......</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Resources <span class="title">loadResource</span><span class="params">(Context parentContext, String apkPath)</span> </span>&#123;</span><br><span class="line">		Resources ret = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			AssetManager assetManager = AssetManager.class.newInstance();</span><br><span class="line">			Method method = assetManager.getClass().getDeclaredMethod(<span class="string">"addAssetPath"</span>, String.class);</span><br><span class="line">			method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">			method.invoke(assetManager, apkPath);</span><br><span class="line">			ret = <span class="keyword">new</span> Resources(assetManager, parentContext.getResources().getDisplayMetrics(), parentContext.getResources().getConfiguration());</span><br><span class="line">			Log.e(TAG, <span class="string">"loadResources succeed"</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			Log.e(TAG, <span class="string">"loadResources faided"</span>);</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;然后我们再插件工程里面再添加一个方法，再放入一个简单的资源：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Plugin</span></span>&#123;</span><br><span class="line">	......</span><br><span class="line">		<span class="function"><span class="keyword">public</span> String <span class="title">getContextStr</span><span class="params">(Resources resources)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> resources.getString(R.string.plugin_str);<span class="comment">//&lt;string name="plugin_str"&gt;PLUGIN&lt;/string&gt;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;测试如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">	...省略一些初始化代码...</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadPluginClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">	......</span><br><span class="line">	<span class="comment">//构造一个DexClassLoader</span></span><br><span class="line">	DexClassLoader  dexClassLoader = mPluginBase.makeDexClassLoader(APK_PATH, DEX_PATH,</span><br><span class="line">	<span class="keyword">null</span>, getApplicationContext().getClassLoader());</span><br><span class="line">	Class&lt;?&gt; pluginClass = mDexClassLoader.loadClass(<span class="string">"com.example.plugin.Plugin"</span>);</span><br><span class="line">	......</span><br><span class="line">	Object pluginObject = pluginClass.newInstance();</span><br><span class="line">	<span class="comment">//加载插件apk资源</span></span><br><span class="line">	Resources pluginResources = mPluginBase.loadResource(<span class="keyword">this</span>, APK_PATH);</span><br><span class="line">	</span><br><span class="line">	Method m2 = pluginClass.getMethod(<span class="string">"getContextStr"</span>, Resources.class);</span><br><span class="line">	String methodStr2 = (String) m2.invoke(pluginObject, pluginResources);</span><br><span class="line">	Log.e(TAG, <span class="string">"Print Resource str = "</span> + methodStr2);</span><br><span class="line">	......		</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;运行之后，打印log如下：<br>&#160; &#160; &#160; &#160;Print Resource str = PLUGIN</p>
<h3 id="Layout资源"><a href="#Layout资源" class="headerlink" title="Layout资源"></a>Layout资源</h3><p>&#160; &#160; &#160; &#160;如果要使用插件apk里面的layout资源，比如引用某个布局文件TestPlugin/res/layout/plugin.xml，就需要做一做处理。<br>&#160; &#160; &#160; &#160;一般从layout转换成view需要用到LayoutInflate，比如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">View view = LayoutInflater.from(context).inflate(R.layout.plugin, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;但是这个context不能直接传宿主程序的context，否则回报一个资源id没有找到异常。我们跟着LayoutInflate的源码进去看看，问题出在哪儿：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LayoutInflater</span> </span>&#123;</span><br><span class="line">	<span class="comment">//Inflate时会调用到</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">inflate</span><span class="params">(<span class="keyword">int</span> resource, ViewGroup root, <span class="keyword">boolean</span> attachToRoot)</span> </span>&#123;</span><br><span class="line">	    <span class="comment">//这句返回的resource是宿主程序ContextImpl里的resource，即宿主程序的resource</span></span><br><span class="line">        <span class="keyword">final</span> Resources res = getContext().getResources();</span><br><span class="line">        </span><br><span class="line">		......</span><br><span class="line">		<span class="comment">//所以这里在宿主resource里当然找不到插件资源id了，这个里面抛出了异常</span></span><br><span class="line">        <span class="keyword">final</span> XmlResourceParser parser = res.getLayout(resource);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> inflate(parser, root, attachToRoot);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            parser.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;我们看到inflate时还是在宿主程序的资源里查找了插件资源，因此回报异常。不过我们可以投机取巧一下，重写一个LayoutInflate的Inflate第二个重载方法。在插件工程里可以做如下测试：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Plugin</span></span>&#123;</span><br><span class="line">	......</span><br><span class="line">		<span class="function"><span class="keyword">public</span> LinearLayout <span class="title">getLinearLayout</span><span class="params">(Context context, <span class="keyword">final</span> Resources resources)</span></span>&#123;</span><br><span class="line">		LayoutInflater inflater = <span class="keyword">new</span> LayoutInflater(context) &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> LayoutInflater <span class="title">cloneInContext</span><span class="params">(Context newContext)</span> </span>&#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> View <span class="title">inflate</span><span class="params">(<span class="keyword">int</span> resource, ViewGroup root,</span><br><span class="line">					<span class="keyword">boolean</span> attachToRoot)</span> </span>&#123;</span><br><span class="line"><span class="comment">//		        final Resources res = getContext().getResources(); //注释掉这行</span></span><br><span class="line">		        <span class="keyword">final</span> Resources res = resources; <span class="comment">//替换为插件apk资源</span></span><br><span class="line"></span><br><span class="line">		        <span class="keyword">final</span> XmlResourceParser parser = res.getLayout(resource);</span><br><span class="line">		        <span class="keyword">try</span> &#123;</span><br><span class="line">		            <span class="keyword">return</span> inflate(parser, root, attachToRoot);</span><br><span class="line">		        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		            parser.close();</span><br><span class="line">		        &#125;</span><br><span class="line">			&#125;    </span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="keyword">return</span> (LinearLayout) inflater.inflate(R.layout.plugin_layout, <span class="keyword">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;然后在宿主程序里写上测试demo：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">	...省略一些初始化代码...</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadPluginClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">	......</span><br><span class="line">	<span class="comment">//构造一个DexClassLoader</span></span><br><span class="line">	DexClassLoader  dexClassLoader = mPluginBase.makeDexClassLoader(APK_PATH, DEX_PATH,</span><br><span class="line">	<span class="keyword">null</span>, getApplicationContext().getClassLoader());</span><br><span class="line">	Class&lt;?&gt; pluginClass = mDexClassLoader.loadClass(<span class="string">"com.example.plugin.Plugin"</span>);</span><br><span class="line">	......</span><br><span class="line">	Object pluginObject = pluginClass.newInstance();</span><br><span class="line">	<span class="comment">//加载插件apk资源</span></span><br><span class="line">	Resources pluginResources = mPluginBase.loadResource(<span class="keyword">this</span>, APK_PATH);</span><br><span class="line">	<span class="comment">//测试插件layout文件</span></span><br><span class="line">	Method m3 = pluginClass.getMethod(<span class="string">"getLinearLayout"</span>, Context.class, Resources.class);</span><br><span class="line">	LinearLayout pluginView = (LinearLayout) m3.invoke(pluginObject, <span class="keyword">this</span>, pluginResources );</span><br><span class="line">	<span class="keyword">this</span>.addContentView(pluginView, <span class="keyword">new</span> RelativeLayout.LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));</span><br><span class="line">	......		</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;经过测试，插件的layout布局被加入到了宿主界面上，图片就不贴了。</p>
<h3 id="另外三种方式"><a href="#另外三种方式" class="headerlink" title="另外三种方式"></a>另外三种方式</h3><p>&#160; &#160; &#160; &#160;上面的方法其实还是有些繁琐，如果要封装的完善一些可以尝试下面三种方案：</p>
<ul>
<li>创建一个自己的ContextImpl，Override其方法</li>
<li>通过反射，直接替换当前context的mResources私有成员变量</li>
<li>反射替换ActivityThread里的Instrumentation，将插件资源和宿主资源整合</li>
</ul>
<p>(1) 创建自己的Context：<br>&#160; &#160; &#160; &#160;要构建自己的Context，就得继承ContextWrapper类，（Context类和它的一些子类大家应该都清楚）然后重写里面的一些重要方法。实例代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PluginContext</span> <span class="keyword">extends</span> <span class="title">ContextWrapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"PluginContext"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> DexClassLoader mClassLoader ;</span><br><span class="line">    <span class="keyword">private</span> Resources mResources;</span><br><span class="line">    <span class="keyword">private</span> LayoutInflater mInflater;</span><br><span class="line"></span><br><span class="line">    PluginContext(Context context, String pluginPath, String optimizedDirectory, String libraryPath) &#123;</span><br><span class="line">        <span class="keyword">super</span>(context.getApplicationContext());</span><br><span class="line">        </span><br><span class="line">        Resources resc = context.getResources();</span><br><span class="line">        <span class="comment">//隐藏API是这样的</span></span><br><span class="line">        <span class="comment">//AssetManager assets = new AssetManager();</span></span><br><span class="line">        AssetManager assets = AssetManager.class.newInstance();</span><br><span class="line">        assets.addAssetPath(pluginPath);</span><br><span class="line"></span><br><span class="line">		mClassLoader = <span class="keyword">new</span> DexClassLoader(pluginPath, optimizedDirectory, libraryPath, context.getClassLoader());</span><br><span class="line">        mResources = <span class="keyword">new</span> Resources(assets, resc.getDisplayMetrics(), </span><br><span class="line">                resc.getConfiguration(), resc.getCompatibilityInfo(), <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//隐藏API是这样的</span></span><br><span class="line">        <span class="comment">//mInflater = PolicyManager.makeNewLayoutInflater(this);</span></span><br><span class="line">        mInflater = <span class="keyword">new</span> LayoutInflater(context) &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> LayoutInflater <span class="title">cloneInContext</span><span class="params">(Context newContext)</span> </span>&#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> View <span class="title">inflate</span><span class="params">(<span class="keyword">int</span> resource, ViewGroup root,</span><br><span class="line">					<span class="keyword">boolean</span> attachToRoot)</span> </span>&#123;</span><br><span class="line"><span class="comment">//		        final Resources res = getContext().getResources();</span></span><br><span class="line">		        <span class="keyword">final</span> Resources res = mResources;</span><br><span class="line"></span><br><span class="line">		        <span class="keyword">final</span> XmlResourceParser parser = res.getLayout(resource);</span><br><span class="line">		        <span class="keyword">try</span> &#123;</span><br><span class="line">		            <span class="keyword">return</span> inflate(parser, root, attachToRoot);</span><br><span class="line">		        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		            parser.close();</span><br><span class="line">		        &#125;</span><br><span class="line">			&#125;    </span><br><span class="line">		&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClassLoader <span class="title">getClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mClassLoader ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AssetManager <span class="title">getAssets</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mResources.getAssets();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Resources <span class="title">getResources</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mResources;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getSystemService</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (name == Context.LAYOUT_INFLATER_SERVICE)</span><br><span class="line">            <span class="keyword">return</span> mInflater;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getSystemService(name);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Theme mTheme;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Resources.<span class="function">Theme <span class="title">getTheme</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (mTheme == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> resid = Resources.selectDefaultTheme(<span class="number">0</span>,</span><br><span class="line">                        getBaseContext().getApplicationInfo().targetSdkVersion);</span><br><span class="line">                mTheme = mResources.newTheme();</span><br><span class="line">                mTheme.applyStyle(resid, <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> mTheme;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这样我们插件的Context就构造完成了，以后就可以使用这个Context加载插件中的资源文件了。</p>
<p>(2) 替换当前context的mResources私有成员变量：<br>&#160; &#160; &#160; &#160;这个需要在Activity的attachBaseContext方法中替换它的Context，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">	......</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">attachBaseContext</span><span class="params">(Context newBase)</span> </span>&#123;</span><br><span class="line">		replaceContextResources(newBase);</span><br><span class="line">		<span class="keyword">super</span>.attachBaseContext(newBase);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span><br><span class="line">     * 使用反射的方式，使用mPluginResources对象，替换Context的mResources对象</span><br><span class="line">     * <span class="doctag">@param</span> context</span><br><span class="line">     */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">replaceContextResources</span><span class="params">(Context context)</span></span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Field field = context.getClass().getDeclaredField(<span class="string">"mResources"</span>);</span><br><span class="line">			field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">			field.set(context, mPluginResources);</span><br><span class="line">			Log.e(TAG, <span class="string">"replace resources succeed"</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			Log.e(TAG, <span class="string">"replace resources failed"</span>);</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>(3) 反射替换ActivityThread里的Instrumentation，将插件资源和宿主资源整合:<br>&#160; &#160; &#160; &#160;AssetManager的addAssetPath()法调用native层AssetManager对象的addAssetPath()法，通过查看c++代码可以知道，该方法可以被调用多次，每次调用都会把对应资源添加起来，而后来添加的在使用资源是会被首先搜索到。可以怎么理解，C++层的AssetManager有一个存放资源的栈，每次调用addAssetPath()法都会把资源对象压如栈，而在读取搜索资源时是从栈顶开始搜索，找不到就往下查。所以我们可以这样来处理AssetManager并得到Resources。<br>&#160; &#160; &#160; &#160;使用到资源的地方归纳起来有两处，一处是在Java代码中通过Context.getResources获取，一处是在xml文件（如布局文件）里指定资源，其实xml文件里最终也是通过Context来获取资源的只不过是他一般获取的是Resources里的AssetManager。所以，我们可以在Context对象被创建后且还未使用时把它里面的Resources（mResources）替换掉。整个应用的Context数目等于Application+Activity+Service的数目，Context会在这几个类创建对象的时候创建并添加进去。而这些行为都是在ActivityTHread和Instrumentation里做的。<br>&#160; &#160; &#160; &#160;以Activity为例，步骤如下：<br>&#160; &#160; &#160; &#160;1. Activity对象的创建是在ActivityThread里调用Instrumentation的newActivity方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ActivityThread类</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Activity <span class="title">performLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</span><br><span class="line">		......</span><br><span class="line">        java.lang.ClassLoader cl = r.packageInfo.getClassLoader();</span><br><span class="line">        activity = mInstrumentation.newActivity(</span><br><span class="line">                    cl, component.getClassName(), r.intent);</span><br><span class="line">        ......            </span><br><span class="line">&#125;</span><br><span class="line">	<span class="comment">//Instrumentation类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Activity <span class="title">newActivity</span><span class="params">(ClassLoader cl, String className,</span><br><span class="line">            Intent intent)</span></span><br><span class="line">            <span class="keyword">throws</span> InstantiationException, IllegalAccessException,</span><br><span class="line">            ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Activity)cl.loadClass(className).newInstance();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;2.Context对象的创建是在ActivityThread里调用createBaseContextForActivity方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ActivityThread类</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Activity <span class="title">performLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</span><br><span class="line">		......</span><br><span class="line">        Context appContext = createBaseContextForActivity(r, activity);</span><br><span class="line">        ......            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;3.Activity绑定Context是在ActivityThread里调用Activity对象的attach方法，其中appContext就是上面创建的Context对象:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ActivityThread类</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Activity <span class="title">performLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</span><br><span class="line">		......</span><br><span class="line">        activity.attach(appContext, <span class="keyword">this</span>, getInstrumentation(), r.token,</span><br><span class="line">                        r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class="line">                        r.embeddedID, r.lastNonConfigurationInstances, config,</span><br><span class="line">                        r.voiceInteractor);</span><br><span class="line">        ......            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;替换掉Activity里Context里的Resources最好要早，基于上面的观察，我们可以在调用Instrumentation的callActivityOnCreate（）方法时把Resources替换掉。那么问题又来了，我们如何控制callActivityOnCreate（）方法的执行，这里又得使用hook的思想了，即把ActivityThread里面的Instrumentation对象（mInstrumentation）给替换掉，同样得使用反射。步骤如下:<br>&#160; &#160; &#160; &#160;1. 获取ActivityThread对象:<br>&#160; &#160; &#160; &#160;ActivityThread里面有一个静态方法，该方法返回的是ActivityThread对象本身，所以我们可以调用该方法来获取ActivityTHread对象:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ActivityThread类</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ActivityThread <span class="title">currentActivityThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> sCurrentActivityThread;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;然而ActivityThread是被hide的，所以得通过反射来处理，处理如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取ActivityThread类</span></span><br><span class="line">Class&lt;?&gt; activityThreadClass = Class.forName(<span class="string">"android.app.ActivityThread"</span>);</span><br><span class="line"><span class="comment">//获取currentActivityThread方法</span></span><br><span class="line">Method currentActivityThreadMethod = activityThreadClass.getDeclaredMethod(<span class="string">"currentActivityThread"</span>);</span><br><span class="line">currentActivityThreadMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//获取ActivityThread对象</span></span><br><span class="line">Object CurrentActivityThread = currentActivityThreadMethod.invoke(<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;2. 获取ActivityThread里的Instrumentation对象:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Field mInstrumentationField = activityThreadClass.getDeclaredField(<span class="string">"mInstrumentation"</span>);</span><br><span class="line">mInstrumentationField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Instrumentation mInstrumentation = (Instrumentation) mInstrumentationField.get(CurrentActivityThread);</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;3. 构建我们自己的Instrumentation对象，并从写callActivityOnCreate方法<br>在callActivityOnCreate方法里要先获取当前Activity对象里的Context（mBase），再获取Context对象里的Resources（mResources）变量，在把mResources变量指向我们构造的Resources对象，做到移花接木。构建我们的MyInstrumentation类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInstrumentation</span> <span class="keyword">extends</span> <span class="title">Instrumentation</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> Instrumentation mInstrumentationParent;</span><br><span class="line">	<span class="keyword">private</span> Context mContextParent;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyInstrumentation</span><span class="params">(Instrumentation instrumentation, Context context)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		mInstrumentationParent = instrumentation;</span><br><span class="line">		mContextParent = context;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callActivityOnCreate</span><span class="params">(Activity activity, Bundle icicle)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Field mBaseField = Activity.class.getSuperclass().getSuperclass().getDeclaredField(<span class="string">"mBase"</span>);</span><br><span class="line">			mBaseField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">			Context mBase = (Context) mBaseField.get(activity);</span><br><span class="line">			</span><br><span class="line">			Class&lt;?&gt; contextImplClazz = Class.forName(<span class="string">"android.app.ContextImpl"</span>);</span><br><span class="line">			Field mResourcesField = contextImplClazz.getDeclaredField(<span class="string">"mResources"</span>);</span><br><span class="line">			mResourcesField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">			</span><br><span class="line">			String dexPath = activity.getCacheDir() + File.separator + <span class="string">"TestPlugin.apk"</span>;</span><br><span class="line">			String dexPath2 = mContextParent.getApplicationContext().getPackageCodePath();</span><br><span class="line">			</span><br><span class="line">			AssetManager assetManager = AssetManager.class.newInstance();</span><br><span class="line">			Method addAssetPath = assetManager.getClass().getDeclaredMethod(<span class="string">"addAssetPath"</span>, String.class);</span><br><span class="line">			addAssetPath.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">			</span><br><span class="line">			addAssetPath.invoke(assetManager, dexPath);</span><br><span class="line">			addAssetPath.invoke(assetManager, dexPath2);</span><br><span class="line">			</span><br><span class="line">			Method ensureStringBlocksMethod = AssetManager.class.getDeclaredMethod(<span class="string">"ensureStringBlocks"</span>);</span><br><span class="line">			ensureStringBlocksMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">			ensureStringBlocksMethod.invoke(assetManager);</span><br><span class="line">			</span><br><span class="line">			Resources superRes = mContextParent.getResources();</span><br><span class="line">			Resources resources = <span class="keyword">new</span> Resources(assetManager, superRes.getDisplayMetrics(), superRes.getConfiguration());</span><br><span class="line">			</span><br><span class="line">			mResourcesField.set(mBase, resources);</span><br><span class="line">			</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">super</span>.callActivityOnCreate(activity, icicle);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;4. 最后，使ActivityThread里面的mInstrumentation变量指向我们构建的MyInstrumentation对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hookResources</span><span class="params">(Context context)</span></span>&#123;</span><br><span class="line">	 <span class="comment">//获取ActivityThread类</span></span><br><span class="line">       Class&lt;?&gt; activityThreadClass;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		activityThreadClass = Class.forName(<span class="string">"android.app.ActivityThread"</span>);</span><br><span class="line">		<span class="comment">//获取currentActivityThread方法</span></span><br><span class="line">		Method currentActivityThreadMethod = activityThreadClass.getDeclaredMethod(<span class="string">"currentActivityThread"</span>);</span><br><span class="line">		currentActivityThreadMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">		<span class="comment">//获取ActivityThread对象</span></span><br><span class="line">		Object CurrentActivityThread = currentActivityThreadMethod.invoke(<span class="keyword">null</span>);</span><br><span class="line">		<span class="comment">//获取Instrumentation变量</span></span><br><span class="line">		Field mInstrumentationField = activityThreadClass.getDeclaredField(<span class="string">"mInstrumentation"</span>);</span><br><span class="line">        mInstrumentationField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Instrumentation mInstrumentation = (Instrumentation) mInstrumentationField.get(CurrentActivityThread);</span><br><span class="line">		<span class="comment">//构建自己的Instrumentation对象</span></span><br><span class="line">        Instrumentation proxy = <span class="keyword">new</span> MyInstrumentation(mInstrumentation, context);</span><br><span class="line">        <span class="comment">//移花接木</span></span><br><span class="line">        mInstrumentationField.set(CurrentActivityThread, proxy);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="加载SO库流程分析和填坑"><a href="#加载SO库流程分析和填坑" class="headerlink" title="加载SO库流程分析和填坑"></a>加载SO库流程分析和填坑</h2><p>&#160; &#160; &#160; &#160;插件加载带有动态库的apk时，会报UnsatisfiedLinkError找不到动态库的错误原因是我们没有动态指定so库的路径。<br>&#160; &#160; &#160; &#160;解决方法是在DexClassLoader中第三个参数书指定so库的目录路径，因此我们需要把动态库给解压出来放到data/data/xx（package）目录下。<br>&#160; &#160; &#160; &#160;这个，我把so文件放到了/data/data/com.example.host/cache/下面，然后给我们的DexClassLoader第三个参数指定了这个目录，然后在插件工程里调用System.loadLibrary方法就不会报错了。</p>
<p>&#160; &#160; &#160; &#160;关于解压so文件和获取手机CPU的ABI类型这里就不在赘述，网上也是大把的代码。我们主要分析一下Android找寻so和加载的流程：</p>
<h3 id="SO库加载过程"><a href="#SO库加载过程" class="headerlink" title="SO库加载过程"></a>SO库加载过程</h3><p>&#160; &#160; &#160; &#160;在Android中如果想使用so的话，首先得先加载，加载现在主要有两种方法，一种是直接System.loadLibrary方法加载工程中的libs目录下的默认so文件，这里的加载文件名是xxx，而整个so的文件名为：libxxx.so。还有一种是加载指定目录下的so文件，使用System.load方法，这里需要加载的文件名是全路径，比如：xxx/xxx/libxxx.so。<br>&#160; &#160; &#160; &#160;我们可以看看System类的这两个方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">(String pathName)</span> </span>&#123;</span><br><span class="line">    Runtime.getRuntime().load(pathName, VMStack.getCallingClassLoader());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadLibrary</span><span class="params">(String libName)</span> </span>&#123;</span><br><span class="line">    Runtime.getRuntime().loadLibrary(libName, VMStack.getCallingClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这两个方法都会进入到Runtime类的不同方法中，我们继续跟进去：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//load方法比较简单</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">load</span><span class="params">(String absolutePath, ClassLoader loader)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (absolutePath == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"absolutePath == null"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//都会调用doLoad方法</span></span><br><span class="line">       String error = doLoad(absolutePath, loader);</span><br><span class="line">       <span class="keyword">if</span> (error != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> UnsatisfiedLinkError(error);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//loadLibrary比较复杂</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">loadLibrary</span><span class="params">(String libraryName, ClassLoader loader)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (loader != <span class="keyword">null</span>) &#123;<span class="comment">//这个loader就是加载目标类的ClassLoader，宿主工程为系统指定的PathClassLoader，插件工程为我们构造的DexClassLoader</span></span><br><span class="line">        <span class="comment">//首先会从一些指定目录中查找指定名字的so文件</span></span><br><span class="line">           String filename = loader.findLibrary(libraryName);</span><br><span class="line">           <span class="comment">//如果没有找到就会抛异常</span></span><br><span class="line">           <span class="keyword">if</span> (filename == <span class="keyword">null</span>) &#123;<span class="comment">//这个异常就是我们没有指定DexClassLoader第三个参数时报的异常</span></span><br><span class="line">               <span class="comment">// It's not necessarily true that the ClassLoader used</span></span><br><span class="line">               <span class="comment">// System.mapLibraryName, but the default setup does, and it's</span></span><br><span class="line">               <span class="comment">// misleading to say we didn't find "libMyLibrary.so" when we</span></span><br><span class="line">               <span class="comment">// actually searched for "liblibMyLibrary.so.so".</span></span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> UnsatisfiedLinkError(loader + <span class="string">" couldn't find \""</span> +</span><br><span class="line">                                              System.mapLibraryName(libraryName) + <span class="string">"\""</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//都会调用doLoad方法</span></span><br><span class="line">           String error = doLoad(filename, loader);</span><br><span class="line">           <span class="keyword">if</span> (error != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> UnsatisfiedLinkError(error);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">	<span class="comment">//下面逻辑是当指定ClassLoader为null时，就在一些系统so库目录中查找</span></span><br><span class="line">       String filename = System.mapLibraryName(libraryName);</span><br><span class="line">       List&lt;String&gt; candidates = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">       String lastError = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">for</span> (String directory : mLibPaths) &#123;</span><br><span class="line">           String candidate = directory + filename;</span><br><span class="line">           candidates.add(candidate);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (IoUtils.canOpenReadOnly(candidate)) &#123;</span><br><span class="line">               String error = doLoad(candidate, loader);</span><br><span class="line">               <span class="keyword">if</span> (error == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="keyword">return</span>; <span class="comment">// We successfully loaded the library. Job done.</span></span><br><span class="line">               &#125;</span><br><span class="line">               lastError = error;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (lastError != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> UnsatisfiedLinkError(lastError);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> UnsatisfiedLinkError(<span class="string">"Library "</span> + libraryName + <span class="string">" not found; tried "</span> + candidates);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;我们这里详细分析一下loadLibrary方法。首先会判断指定的ClassLoader是否为空，这里传入的值为VMStack.getCallingClassLoader()，就是加载目标类的ClassLoader，宿主工程为系统指定的PathClassLoader，插件工程为我们构造的DexClassLoader。</p>
<p>&#160; &#160; &#160; &#160;然后执行：String filename = loader.findLibrary(libraryName);<br>这一步其实是调用PathClassLoader和DexClassLoader共同父类BaseDexClassLoader的findLibrary方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> DexPathList pathList;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">BaseDexClassLoader</span><span class="params">(String dexPath, File optimizedDirectory,</span><br><span class="line">           String libraryPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>(parent);</span><br><span class="line">       <span class="comment">//pathList在构造方法中赋值</span></span><br><span class="line">       <span class="keyword">this</span>.pathList = <span class="keyword">new</span> DexPathList(<span class="keyword">this</span>, dexPath, libraryPath, optimizedDirectory);</span><br><span class="line">   &#125;	</span><br><span class="line"></span><br><span class="line"><span class="comment">//BaseDexClassLoader的findLibrary方法</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">findLibrary</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> pathList.findLibrary(name);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;BaseDexClassLoader的findLibrary方法内部又调用了DexPathList的findLibrary方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DexPathList的findLibrary方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">findLibrary</span><span class="params">(String libraryName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//转换指定libraryName为so库文件名，例如turn "MyLibrary" into "libMyLibrary.so".</span></span><br><span class="line">       String fileName = System.mapLibraryName(libraryName);</span><br><span class="line">       <span class="comment">//在nativeLibraryDirectories中遍历目标so库是否存在</span></span><br><span class="line">       <span class="keyword">for</span> (File directory : nativeLibraryDirectories) &#123;</span><br><span class="line">           String path = <span class="keyword">new</span> File(directory, fileName).getPath();</span><br><span class="line">           <span class="keyword">if</span> (IoUtils.canOpenReadOnly(path)) &#123;</span><br><span class="line">               <span class="keyword">return</span> path;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> File[] nativeLibraryDirectories;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DexPathList</span><span class="params">(ClassLoader definingContext, String dexPath,</span><br><span class="line">           String libraryPath, File optimizedDirectory)</span> </span>&#123;</span><br><span class="line">	......</span><br><span class="line">	<span class="comment">//也是在构造方法中给nativeLibraryDirectories 赋值；</span></span><br><span class="line">	<span class="comment">//libraryPath就是我们在DexClassLoader中指定的第三个参数,系统的PathClassLoader指定为/data/app-lib/xxx(包名)</span></span><br><span class="line">       <span class="keyword">this</span>.nativeLibraryDirectories = splitLibraryPath(libraryPath);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//GO ON 继续跟踪</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> File[] splitLibraryPath(String path) &#123;</span><br><span class="line">       <span class="comment">// Native libraries may exist in both the system and</span></span><br><span class="line">       <span class="comment">// application library paths, and we use this search order:</span></span><br><span class="line">       <span class="comment">//</span></span><br><span class="line">       <span class="comment">//   1. this class loader's library path for application libraries</span></span><br><span class="line">       <span class="comment">//   2. the VM's library path from the system property for system libraries</span></span><br><span class="line">       <span class="comment">//</span></span><br><span class="line">       <span class="comment">// This order was reversed prior to Gingerbread; see http://b/2933456.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//System.getProperty("java.library.path")返回的是/vendor/lib:/system/lib</span></span><br><span class="line">       ArrayList&lt;File&gt; result = splitPaths(path, System.getProperty(<span class="string">"java.library.path"</span>), <span class="keyword">true</span>);</span><br><span class="line">       <span class="keyword">return</span> result.toArray(<span class="keyword">new</span> File[result.size()]);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//NEXT  path1为我们在DexClassLoader中指定的第三个参数,系统的PathClassLoader指定为/data/app-lib/xxx(包名)；path2为/vendor/lib:/system/lib；wantDirectories为true</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;File&gt; <span class="title">splitPaths</span><span class="params">(String path1, String path2,</span><br><span class="line">           <span class="keyword">boolean</span> wantDirectories)</span> </span>&#123;<span class="comment">//</span></span><br><span class="line">       ArrayList&lt;File&gt; result = <span class="keyword">new</span> ArrayList&lt;File&gt;();</span><br><span class="line"></span><br><span class="line">       splitAndAdd(path1, wantDirectories, result);</span><br><span class="line">       splitAndAdd(path2, wantDirectories, result);</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//FINALLY 用“:”分割路径字符串，并且将这些路径都放入到一个ArrayList中</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">splitAndAdd</span><span class="params">(String searchPath, <span class="keyword">boolean</span> directoriesOnly,</span><br><span class="line">           ArrayList&lt;File&gt; resultList)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (searchPath == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span> (String path : searchPath.split(<span class="string">":"</span>)) &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               StructStat sb = Libcore.os.stat(path);</span><br><span class="line">               <span class="keyword">if</span> (!directoriesOnly || S_ISDIR(sb.st_mode)) &#123;</span><br><span class="line">                   resultList.add(<span class="keyword">new</span> File(path));</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (ErrnoException ignored) &#123;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;上述代码就是查找so库文件的逻辑了，会分别在/vendor/lib、/system/lib、/data/app-lib/xxx(包名)、和指定目录下查找，如果找不到，就会报UnsatisfiedLinkError异常。</p>
<p>&#160; &#160; &#160; &#160;查找逻辑就先到这里，继续回到Runtime类中。接着就会调用doLoad方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">private</span> String <span class="title">doLoad</span><span class="params">(String name, ClassLoader loader)</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	......</span><br><span class="line">       String ldLibraryPath = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">if</span> (loader != <span class="keyword">null</span> &amp;&amp; loader <span class="keyword">instanceof</span> BaseDexClassLoader) &#123;</span><br><span class="line">        <span class="comment">//ldLibraryPath就是上面提到的vendor/lib、/system/lib、/data/app-lib/xxx(包名)、和指定目录用“:”连接的字符串</span></span><br><span class="line">           ldLibraryPath = ((BaseDexClassLoader) loader).getLdLibraryPath();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">//最后会调用nativeLoad方法</span></span><br><span class="line">           <span class="keyword">return</span> nativeLoad(name, loader, ldLibraryPath);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> String <span class="title">nativeLoad</span><span class="params">(String filename, ClassLoader loader, String ldLibraryPath)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这里调用了本地方法，不过悲催的是，我的ART版本代码没有找到，所以只能看 Dalvik版本的。 Runtime类的成员函数nativeLoad在C++层对应的函数为Dalvik_java_lang_Runtime_nativeLoad，这个函数定义在文件dalvik/vm/native/java_lang_Runtime.c中，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Dalvik_java_lang_Runtime_nativeLoad</span><span class="params">(<span class="keyword">const</span> u4* args,  </span><br><span class="line">    JValue* pResult)</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">    StringObject* fileNameObj = (StringObject*) args[<span class="number">0</span>]; <span class="comment">//so库名</span></span><br><span class="line">    Object* classLoader = (Object*) args[<span class="number">1</span>];  <span class="comment">//类加载器</span></span><br><span class="line">    <span class="keyword">char</span>* fileName = <span class="literal">NULL</span>;  </span><br><span class="line">    StringObject* result = <span class="literal">NULL</span>;  </span><br><span class="line">    <span class="keyword">char</span>* reason = <span class="literal">NULL</span>;  </span><br><span class="line">    <span class="keyword">bool</span> success;  </span><br><span class="line">  </span><br><span class="line">    assert(fileNameObj != <span class="literal">NULL</span>); </span><br><span class="line">    <span class="comment">//将 fileNameObj 转化为C++层字符串</span></span><br><span class="line">    fileName = dvmCreateCstrFromString(fileNameObj);  </span><br><span class="line">    <span class="comment">//调用dvmLoadNativeCode方法</span></span><br><span class="line">    success = dvmLoadNativeCode(fileName, classLoader, &amp;reason);  </span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;  </span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* msg = (reason != <span class="literal">NULL</span>) ? reason : <span class="string">"unknown failure"</span>;  </span><br><span class="line">        result = dvmCreateStringFromCstr(msg);  </span><br><span class="line">        dvmReleaseTrackedAlloc((Object*) result, <span class="literal">NULL</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">free</span>(reason);  </span><br><span class="line">    <span class="built_in">free</span>(fileName);  </span><br><span class="line">    RETURN_PTR(result);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160; 参数args[0]保存的是一个Java层的String对象，这个String对象描述的就是要加载的so文件，函数Dalvik_java_lang_Runtime_nativeLoad首先是调用函数dvmCreateCstrFromString来将它转换成一个C++层的字符串fileName，然后再调用函数dvmLoadNativeCode来执行加载so文件的操作。</p>
<p>&#160; &#160; &#160; &#160;接下来，我们就继续分析函数dvmLoadNativeCode的实现，这个函数定义在文件dalvik/vm/Native.c中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dvmLoadNativeCode</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pathName, Object* classLoader,  </span><br><span class="line">        <span class="keyword">char</span>** detail)</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">    SharedLib* pEntry;  </span><br><span class="line">    <span class="keyword">void</span>* handle;  </span><br><span class="line">    ......  </span><br><span class="line">  </span><br><span class="line">    pEntry = findSharedLibEntry(pathName);  </span><br><span class="line">    <span class="keyword">if</span> (pEntry != <span class="literal">NULL</span>) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (pEntry-&gt;classLoader != classLoader) &#123;  </span><br><span class="line">            ......  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        ......  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (!checkOnLoadResult(pEntry))  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    ......  </span><br><span class="line">  </span><br><span class="line">    handle = dlopen(pathName, RTLD_LAZY);  </span><br><span class="line">    ......  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* create a new entry */</span>  </span><br><span class="line">    SharedLib* pNewEntry;  </span><br><span class="line">    pNewEntry = (SharedLib*) <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(SharedLib));  </span><br><span class="line">    pNewEntry-&gt;pathName = strdup(pathName);  </span><br><span class="line">    pNewEntry-&gt;handle = handle;  </span><br><span class="line">    pNewEntry-&gt;classLoader = classLoader;  </span><br><span class="line">    ......  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* try to add it to the list */</span>  </span><br><span class="line">    SharedLib* pActualEntry = addSharedLibEntry(pNewEntry);  </span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span> (pNewEntry != pActualEntry) &#123;  </span><br><span class="line">        ......  </span><br><span class="line">        freeSharedLibEntry(pNewEntry);  </span><br><span class="line">        <span class="keyword">return</span> checkOnLoadResult(pActualEntry);  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        ......  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">bool</span> result = <span class="literal">true</span>;  </span><br><span class="line">        <span class="keyword">void</span>* vonLoad;  </span><br><span class="line">        <span class="keyword">int</span> version;  </span><br><span class="line">  </span><br><span class="line">        vonLoad = dlsym(handle, <span class="string">"JNI_OnLoad"</span>);  </span><br><span class="line">        <span class="keyword">if</span> (vonLoad == <span class="literal">NULL</span>) &#123;  </span><br><span class="line">            LOGD(<span class="string">"No JNI_OnLoad found in %s %p, skipping init\n"</span>,  </span><br><span class="line">                pathName, classLoader);  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            ......  </span><br><span class="line">  </span><br><span class="line">            OnLoadFunc func = vonLoad;  </span><br><span class="line">            ......  </span><br><span class="line">  </span><br><span class="line">            version = (*func)(gDvm.vmList, <span class="literal">NULL</span>);  </span><br><span class="line">            ......  </span><br><span class="line">  </span><br><span class="line">            <span class="keyword">if</span> (version != JNI_VERSION_1_2 &amp;&amp; version != JNI_VERSION_1_4 &amp;&amp;  </span><br><span class="line">                version != JNI_VERSION_1_6)  </span><br><span class="line">            &#123;  </span><br><span class="line">                .......  </span><br><span class="line">                result = <span class="literal">false</span>;  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                LOGV(<span class="string">"+++ finished JNI_OnLoad %s\n"</span>, pathName);  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        ......  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (result)  </span><br><span class="line">            pNewEntry-&gt;onLoadResult = kOnLoadOkay;  </span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">            pNewEntry-&gt;onLoadResult = kOnLoadFailed;  </span><br><span class="line">  </span><br><span class="line">        ......  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">return</span> result;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;函数dvmLoadNativeCode首先是检查参数pathName所指定的so文件是否已经加载过了，这是通过调用函数findSharedLibEntry来实现的。如果已经加载过，那么就可以获得一个SharedLib对象pEntry。这个SharedLib对象pEntry描述了有关参数pathName所指定的so文件的加载信息，例如，上次用来加载它的类加载器和上次的加载结果。如果上次用来加载它的类加载器不等于当前所使用的类加载器，或者上次没有加载成功，那么函数dvmLoadNativeCode就回直接返回false给调用者，表示不能在当前进程中加载参数pathName所描述的so文件。</p>
<blockquote>
<p>这里有一个检测异常的代码，而这个错误，是我们在使用插件开发加载so的时候可能会遇到的错误，比如现在我们使用DexClassLoader类去加载插件，但是因为我们为了插件能够实时更新，所以每次都会赋值新的DexClassLoader对象，但是第一次加载so文件到内存中了，这时候退出程序，但是没有真正意义上的退出，只是关闭了Activity了，这时候再次启动又会赋值新的加载器对象，那么原先so已经加载到内存中了，但是这时候是新的类加载器那么就报错了，解决办法其实很简单，主要有两种方式：<br>第一种方式：在退出程序的时候采用真正意义上的退出，比如调用System.exit(0)方法，这时候进程被杀了，加载到内存的so也就被释放了，那么下次赋值新的类加载就在此加载so到内存了，<br>第二种方式：就是全局定义一个static类型的类加载DexClassLoader也是可以的，因为static类型是保存在当前进程中，如果进程没有被杀就一直存在这个对象，下次进入程序的时候判断当前类加载器是否为null，如果不为null就不要赋值了，但是这个方法有一个弊端就是类加载器没有从新赋值，如果插件这时候更新了，但是还是使用之前的加载器，那么新插件将不会进行加载。</p>
</blockquote>
<p>&#160; &#160; &#160; &#160;我们假设参数pathName所指定的so文件还没有被加载过，这时候函数dvmLoadNativeCode就会先调用dlopen来在当前进程中加载它，并且将获得的句柄保存在变量handle中，接着再创建一个SharedLib对象pNewEntry来描述它的加载信息。这个SharedLib对象pNewEntry还会通过函数addSharedLibEntry被缓存起来，以便可以知道当前进程都加载了哪些so文件。</p>
<p>&#160; &#160; &#160; &#160; 注意，在调用函数addSharedLibEntry来缓存新创建的SharedLib对象pNewEntry的时候，如果得到的返回值pActualEntry指向的不是SharedLib对象pNewEntry，那么就表示另外一个线程也正在加载参数pathName所指定的so文件，并且比当前线程提前加载完成。在这种情况下，函数addSharedLibEntry就什么也不用做而直接返回了。否则的话，函数addSharedLibEntry就要继续负责调用前面所加载的so文件中的一个指定的函数来注册它里面的JNI方法。</p>
<p>&#160; &#160; &#160; &#160; 这个指定的函数的名称为“JNI_OnLoad”，也就是说，每一个用来实现JNI方法的so文件都应该定义有一个名称为“JNI_OnLoad”的函数，并且这个函数的原型为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">jint <span class="title">JNI_OnLoad</span><span class="params">(JavaVM* vm, <span class="keyword">void</span>* reserved)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160; 函数dvmLoadNativeCode通过调用函数dlsym就可以获得在前面加载的so中名称为“JNI_OnLoad”的函数的地址，最终保存在函数指针func中。有了这个函数指针之后，我们就可以直接调用它来执行注册JNI方法的操作了。注意，在调用该JNI_OnLoad函数时，第一个要传递进行的参数是一个JavaVM对象，这个JavaVM对象描述的是在当前进程中运行的Dalvik虚拟机，第二个要传递的参数可以设置为NULL，这是保留给以后使用的。</p>
<p>&#160; &#160; &#160; &#160;到这里我们就总结一下Android中加载so的流程：</p>
<ul>
<li>调用System.loadLibrary和System.load方法进行加载so文件</li>
<li>通过Runtime.java类的nativeLoad方法进行最终调用，这里需要通过类加载器获取到nativeLib路径</li>
<li>到底层之后，就开始使用dlopen方法加载so文件，然后使用dlsym方法调用JNI_OnLoad方法，最终开始了so的执行</li>
</ul>
<h3 id="释放SO库文件"><a href="#释放SO库文件" class="headerlink" title="释放SO库文件"></a>释放SO库文件</h3><p>&#160; &#160; &#160; &#160;我们在使用System.loadLibrary加载so的时候，传递的是so文件的libxxx.so中的xxx部分，那么系统是如何找到这个so文件然后进行加载的呢？这个就要先从apk文件安装时机说起。</p>
<p> &#160; &#160; &#160; &#160;Android系统在启动的过程中，会启动一个应用程序管理服务PackageManagerService，这个服务负责扫描系统中特定的目录，找到里面的应用程序文件，即以Apk为后缀的文件，然后对这些文件进解析，得到应用程序的相关信息，完成应用程序的安装过程。<br>&#160; &#160; &#160; &#160;应用程序管理服务PackageManagerService安装应用程序的过程，其实就是解析析应用程序配置文件AndroidManifest.xml的过程，并从里面得到得到应用程序的相关信息，例如得到应用程序的组件Activity、Service、Broadcast Receiver和Content Provider等信息，有了这些信息后，通过ActivityManagerService这个服务，我们就可以在系统中正常地使用这些应用程序了。</p>
<p> &#160; &#160; &#160; &#160;下面我们一步一步分析：<br>  &#160; &#160; &#160; &#160;我们知道Android系统系统启动时会启动Zygote进程，Zygote进程又会启动SystemServer组件，启动的时候就会调用它的main函数，然后会初始化一系列服务。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> PackageManagerService mPackageManagerService;</span><br><span class="line">	</span><br><span class="line">	......</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> SystemServer().run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	......</span><br><span class="line">	startBootstrapServices();</span><br><span class="line">	......</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startBootstrapServices</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	mPackageManagerService = PackageManagerService.main(mSystemContext, mInstaller,</span><br><span class="line">                mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF, mOnlyCore);</span><br><span class="line">	&#125;	</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;中间会启动PackageManagerService，这个函数定义在frameworks/base/services/java/com/android/server/PackageManagerService.java文件中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PackageManagerService</span> <span class="keyword">extends</span> <span class="title">IPackageManager</span>.<span class="title">Stub</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	......</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> PackageManagerService <span class="title">main</span><span class="params">(Context context, Installer installer,</span><br><span class="line">            <span class="keyword">boolean</span> factoryTest, <span class="keyword">boolean</span> onlyCore)</span> </span>&#123;</span><br><span class="line">        PackageManagerService m = <span class="keyword">new</span> PackageManagerService(context, installer,</span><br><span class="line">                factoryTest, onlyCore);</span><br><span class="line">        ServiceManager.addService(<span class="string">"package"</span>, m);</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这个函数创建了一个PackageManagerService服务实例，然后把这个服务添加到ServiceManager中去， 在创建这个PackageManagerService服务实例时，会在PackageManagerService类的构造函数中开始执行安装应用程序的过程：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">PackageManagerService</span><span class="params">(Context context, Installer installer,</span><br><span class="line">           <span class="keyword">boolean</span> factoryTest, <span class="keyword">boolean</span> onlyCore)</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line">scanPackageLI(scanFile, reparseFlags, scanFlags, <span class="number">0</span>, <span class="keyword">null</span>);</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;PackageManagerService的构造方法中就完成了对apk文件的解包，还有对xm文件的解析等等，感兴趣的可以自己分析。这里我们限于篇幅，就只分析so文件的解包过程。<br>&#160; &#160; &#160; &#160;这里会调用scanPackageLI方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> PackageParser.<span class="function">Package <span class="title">scanPackageLI</span><span class="params">(File scanFile, <span class="keyword">int</span> parseFlags, <span class="keyword">int</span> scanFlags,</span><br><span class="line">        <span class="keyword">long</span> currentTime, UserHandle user)</span> <span class="keyword">throws</span> PackageManagerException </span>&#123;</span><br><span class="line">    ......    </span><br><span class="line"> <span class="comment">// Note that we invoke the following method only if we are about to unpack an application</span></span><br><span class="line"> PackageParser.Package scannedPkg = scanPackageLI(pkg, parseFlags, scanFlags</span><br><span class="line">            | SCAN_UPDATE_SIGNATURE, currentTime, user);</span><br><span class="line">            </span><br><span class="line">    ......                    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> PackageParser.<span class="function">Package <span class="title">scanPackageLI</span><span class="params">(PackageParser.Package pkg, <span class="keyword">int</span> parseFlags,</span><br><span class="line">        <span class="keyword">int</span> scanFlags, <span class="keyword">long</span> currentTime, UserHandle user)</span> <span class="keyword">throws</span> PackageManagerException </span>&#123;</span><br><span class="line">    ......    </span><br><span class="line"> <span class="keyword">final</span> PackageParser.Package res = scanPackageDirtyLI(pkg, parseFlags, scanFlags,</span><br><span class="line">                currentTime, user);</span><br><span class="line">                </span><br><span class="line">    ......                </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;经过一系列重载方法调用，最终会调用scanPackageDirtyLI方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span> PackageParser.<span class="function">Package <span class="title">scanPackageDirtyLI</span><span class="params">(PackageParser.Package pkg, <span class="keyword">int</span> parseFlags,</span><br><span class="line">         <span class="keyword">int</span> scanFlags, <span class="keyword">long</span> currentTime, UserHandle user)</span> <span class="keyword">throws</span> PackageManagerException </span>&#123;</span><br><span class="line">         </span><br><span class="line">         <span class="comment">//初始化so库放置的目录，并赋值给pkg</span></span><br><span class="line">setNativeLibraryPaths(pkg);</span><br><span class="line"></span><br><span class="line">         <span class="keyword">final</span> <span class="keyword">boolean</span> isAsec = isForwardLocked(pkg) || isExternal(pkg);</span><br><span class="line">         <span class="comment">//nativeLibraryRootStr 指定为/data/app-lib/xxx(包名)</span></span><br><span class="line">         <span class="keyword">final</span> String nativeLibraryRootStr = pkg.applicationInfo.nativeLibraryRootDir;</span><br><span class="line">         <span class="comment">//false</span></span><br><span class="line">         <span class="keyword">final</span> <span class="keyword">boolean</span> useIsaSpecificSubdirs = pkg.applicationInfo.nativeLibraryRootRequiresIsa;</span><br><span class="line"></span><br><span class="line">         NativeLibraryHelper.Handle handle = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	......</span><br><span class="line">	<span class="comment">//标记打开apk</span></span><br><span class="line">             handle = NativeLibraryHelper.Handle.create(scanFile);</span><br><span class="line"></span><br><span class="line">             <span class="keyword">final</span> File nativeLibraryRoot = <span class="keyword">new</span> File(nativeLibraryRootStr);</span><br><span class="line"></span><br><span class="line">             <span class="comment">// Null out the abis so that they can be recalculated.</span></span><br><span class="line">             pkg.applicationInfo.primaryCpuAbi = <span class="keyword">null</span>;</span><br><span class="line">             pkg.applicationInfo.secondaryCpuAbi = <span class="keyword">null</span>;</span><br><span class="line">	......</span><br><span class="line">	</span><br><span class="line">                 String[] abiList = (cpuAbiOverride != <span class="keyword">null</span>) ?</span><br><span class="line">                         <span class="keyword">new</span> String[] &#123; cpuAbiOverride &#125; : Build.SUPPORTED_ABIS;</span><br><span class="line"></span><br><span class="line">	    ......</span><br><span class="line"></span><br><span class="line">                 <span class="keyword">final</span> <span class="keyword">int</span> copyRet;</span><br><span class="line">                 <span class="keyword">if</span> (isAsec) &#123;</span><br><span class="line">                     copyRet = NativeLibraryHelper.findSupportedAbi(handle, abiList);</span><br><span class="line">                 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="comment">//解压对应ABI的so文件到指定目录</span></span><br><span class="line">                     copyRet = NativeLibraryHelper.copyNativeBinariesForSupportedAbi(handle,</span><br><span class="line">                             nativeLibraryRoot, abiList, useIsaSpecificSubdirs);</span><br><span class="line">                 &#125;</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">         ......</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;scanPackageDirtyLI首先调用setNativeLibraryPaths方法，这个方法主要是指定一下so库释放路径：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setNativeLibraryPaths</span><span class="params">(PackageParser.Package pkg)</span> </span>&#123;</span><br><span class="line"><span class="keyword">final</span> ApplicationInfo info = pkg.applicationInfo;</span><br><span class="line">       <span class="keyword">final</span> String codePath = pkg.codePath;</span><br><span class="line">       <span class="keyword">final</span> File codeFile = <span class="keyword">new</span> File(codePath);</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">boolean</span> bundledApp = isSystemApp(info) &amp;&amp; !isUpdatedSystemApp(info);</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">boolean</span> asecApp = isForwardLocked(info) || isExternal(info);</span><br><span class="line"></span><br><span class="line">       info.nativeLibraryRootDir = <span class="keyword">null</span>;</span><br><span class="line">       info.nativeLibraryRootRequiresIsa = <span class="keyword">false</span>;</span><br><span class="line">       info.nativeLibraryDir = <span class="keyword">null</span>;</span><br><span class="line">       info.secondaryNativeLibraryDir = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (isApkFile(codeFile)) &#123;</span><br><span class="line">           <span class="comment">// Monolithic install</span></span><br><span class="line">           <span class="keyword">if</span> (bundledApp) &#123;</span><br><span class="line">		......</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (asecApp) &#123;</span><br><span class="line">		......</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">final</span> String apkName = deriveCodePathName(codePath);</span><br><span class="line">               <span class="comment">//mAppLib32InstallDir为/data/app-lib/</span></span><br><span class="line">               info.nativeLibraryRootDir = <span class="keyword">new</span> File(mAppLib32InstallDir, apkName)</span><br><span class="line">                       .getAbsolutePath();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           info.nativeLibraryRootRequiresIsa = <span class="keyword">false</span>;</span><br><span class="line">           info.nativeLibraryDir = info.nativeLibraryRootDir;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          ......</span><br><span class="line">       &#125;    </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;然后调用NativeLibraryHelper.Handle.create(scanFile)标记打开apk文件：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Handle</span> <span class="keyword">implements</span> <span class="title">Closeable</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		......</span><br><span class="line">		</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span>[] apkHandles;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> multiArch;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Handle <span class="title">create</span><span class="params">(File packageFile)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> PackageLite lite = PackageParser.parsePackageLite(packageFile, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">return</span> create(lite);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (PackageParserException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Failed to parse package: "</span> + packageFile, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Handle <span class="title">create</span><span class="params">(Package pkg)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> create(pkg.getAllCodePaths(),</span><br><span class="line">                    (pkg.applicationInfo.flags &amp; ApplicationInfo.FLAG_MULTIARCH) != <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Handle <span class="title">create</span><span class="params">(PackageLite lite)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> create(lite.getAllCodePaths(), lite.multiArch);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//最后调用到这里</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Handle <span class="title">create</span><span class="params">(List&lt;String&gt; codePaths, <span class="keyword">boolean</span> multiArch)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> size = codePaths.size();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span>[] apkHandles = <span class="keyword">new</span> <span class="keyword">long</span>[size];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> String path = codePaths.get(i);</span><br><span class="line">                <span class="comment">//调用这个native方法，打开apk，并将JNI层返回的句柄保留到java层</span></span><br><span class="line">                apkHandles[i] = nativeOpenApk(path);</span><br><span class="line">                </span><br><span class="line">				......</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Handle(apkHandles, multiArch);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Handle(<span class="keyword">long</span>[] apkHandles, <span class="keyword">boolean</span> multiArch) &#123;</span><br><span class="line">            <span class="keyword">this</span>.apkHandles = apkHandles;</span><br><span class="line">            <span class="keyword">this</span>.multiArch = multiArch;</span><br><span class="line">            mGuard.open(<span class="string">"close"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//NativeLibraryHelper的nativeOpenApk方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">nativeOpenApk</span><span class="params">(String path)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;经过一系列重载方法调用，最后会调用NativeLibraryHelper的nativeOpenApk方法，打开apk，并将JNI层返回的句柄保留到java层。这个方法的实现位于frameworks/base/core/jni/com_android_internal_content_NativeLibraryHelper.cpp中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jlong</span><br><span class="line"><span class="title">com_android_internal_content_NativeLibraryHelper_openApk</span><span class="params">(JNIEnv *env, jclass, jstring apkPath)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="function">ScopedUtfChars <span class="title">filePath</span><span class="params">(env, apkPath)</span></span>;</span><br><span class="line">    </span><br><span class="line">    ZipFileRO* zipFile = ZipFileRO::open(filePath.c_str());</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(zipFile);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;上述代码调用了ZipFileRO的open方法，并返回一个ZipFileRO类型的指针，然后强转为java层的long型对象返回给java层。open方法实现位于frameworks/base/libs/androidfw/ZipFileRO.cpp中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"> * Open the specified file read-only.  We memory-map the entire thing and</span><br><span class="line"> * close the file before returning.</span><br><span class="line"> */</span></span><br><span class="line"><span class="comment">/* static */</span> ZipFileRO* ZipFileRO::open(<span class="keyword">const</span> <span class="keyword">char</span>* zipFileName)</span><br><span class="line">&#123;</span><br><span class="line">    ZipArchiveHandle handle;</span><br><span class="line">    <span class="comment">//调用ZipArchive库打开zip文件</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int32_t</span> error = OpenArchive(zipFileName, &amp;handle);</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        ALOGW(<span class="string">"Error opening archive %s: %s"</span>, zipFileName, ErrorCodeString(error));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ZipFileRO(handle, strdup(zipFileName));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这些就是JNI层打开apk文件的操作了。我么继续回到scanPackageDirtyLI方法中，接着调用NativeLibraryHelper.copyNativeBinariesForSupportedAbi方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">copyNativeBinariesForSupportedAbi</span><span class="params">(Handle handle, File libraryRoot,</span><br><span class="line">         String[] abiList, <span class="keyword">boolean</span> useIsaSubdir)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">     <span class="comment">//如果目录不存或者是个文件，就重新创建目录    </span></span><br><span class="line">     createNativeLibrarySubdir(libraryRoot);</span><br><span class="line"></span><br><span class="line">     <span class="comment">/*</span><br><span class="line">      * If this is an internal application or our nativeLibraryPath points to</span><br><span class="line">      * the app-lib directory, unpack the libraries if necessary.</span><br><span class="line">      */</span></span><br><span class="line">      <span class="comment">//查找对应的ABI类型</span></span><br><span class="line">     <span class="keyword">int</span> abi = findSupportedAbi(handle, abiList);</span><br><span class="line">     <span class="keyword">if</span> (abi &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">/*</span><br><span class="line">          * If we have a matching instruction set, construct a subdir under the native</span><br><span class="line">          * library root that corresponds to this instruction set.</span><br><span class="line">          */</span></span><br><span class="line">         <span class="comment">//获取so释放之后的目录</span></span><br><span class="line">         <span class="keyword">final</span> String instructionSet = VMRuntime.getInstructionSet(abiList[abi]);</span><br><span class="line">         <span class="keyword">final</span> File subDir;</span><br><span class="line">         <span class="keyword">if</span> (useIsaSubdir) &#123;</span><br><span class="line">             <span class="keyword">final</span> File isaSubdir = <span class="keyword">new</span> File(libraryRoot, instructionSet);</span><br><span class="line">             createNativeLibrarySubdir(isaSubdir);</span><br><span class="line">             subDir = isaSubdir;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             subDir = libraryRoot;</span><br><span class="line">         &#125;</span><br><span class="line"><span class="comment">//拷贝so</span></span><br><span class="line">         <span class="keyword">int</span> copyRet = copyNativeBinaries(handle, subDir, abiList[abi]);</span><br><span class="line">         <span class="keyword">if</span> (copyRet != PackageManager.INSTALL_SUCCEEDED) &#123;</span><br><span class="line">             <span class="keyword">return</span> copyRet;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> abi;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;我们挑一些重要的分析一下。这里先获取abiList的值，这个通过Build.SUPPORTED_ABIS来获取到的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] SUPPORTED_ABIS = getStringList(<span class="string">"ro.product.cpu.abilist"</span>, <span class="string">","</span>);</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;最终是通过获取系统属性ro.product.cpu.abilist的值来得到的，我们可以使用getprop命令来查看这个属性值，或者直接cat一下/system/build.prop文件:<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E8%B5%84%E6%BA%90%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E5%8F%8A%E5%A1%AB%E5%9D%91%E5%A4%84%E7%90%86/adb.png" alt="查看ABI"><br>&#160; &#160; &#160; &#160;这里获取到的值是x86。然后去分析findSupportedAbi方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findSupportedAbi</span><span class="params">(Handle handle, String[] supportedAbis)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> finalRes = NO_NATIVE_LIBRARIES;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">long</span> apkHandle : handle.apkHandles) &#123;</span><br><span class="line">        <span class="comment">//这里调用了native方法</span></span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">int</span> res = nativeFindSupportedAbi(apkHandle, supportedAbis);</span><br><span class="line">           <span class="keyword">if</span> (res == NO_NATIVE_LIBRARIES) &#123;</span><br><span class="line">               <span class="comment">// No native code, keep looking through all APKs.</span></span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (res == INSTALL_FAILED_NO_MATCHING_ABIS) &#123;</span><br><span class="line">               <span class="comment">// Found some native code, but no ABI match; update our final</span></span><br><span class="line">               <span class="comment">// result if we haven't found other valid code.</span></span><br><span class="line">               <span class="keyword">if</span> (finalRes &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                   finalRes = INSTALL_FAILED_NO_MATCHING_ABIS;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (res &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="comment">// Found valid native code, track the best ABI match</span></span><br><span class="line">               <span class="keyword">if</span> (finalRes &lt; <span class="number">0</span> || res &lt; finalRes) &#123;</span><br><span class="line">                   finalRes = res;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// Unexpected error; bail</span></span><br><span class="line">               <span class="keyword">return</span> res;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> finalRes;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nativeFindSupportedAbi</span><span class="params">(<span class="keyword">long</span> handle, String[] supportedAbis)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;NativeLibraryHelper类的findSupportedAbi方法，其实这个方法就是查找系统当前支持的架构型号索引值。调用的本地方法实现为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jint</span><br><span class="line"><span class="title">com_android_internal_content_NativeLibraryHelper_findSupportedAbi</span><span class="params">(JNIEnv *env, jclass clazz,</span><br><span class="line">        jlong apkHandle, jobjectArray javaCpuAbisToSearch)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (jint) findSupportedAbi(env, apkHandle, javaCpuAbisToSearch);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//会调用这个方法</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findSupportedAbi</span><span class="params">(JNIEnv *env, jlong apkHandle, jobjectArray supportedAbisArray)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> numAbis = env-&gt;GetArrayLength(supportedAbisArray);</span><br><span class="line">    Vector&lt;ScopedUtfChars*&gt; supportedAbis;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numAbis; ++i) &#123;</span><br><span class="line">        supportedAbis.add(<span class="keyword">new</span> ScopedUtfChars(env,</span><br><span class="line">            (jstring) env-&gt;GetObjectArrayElement(supportedAbisArray, i)));</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//读取apk文件</span></span><br><span class="line">    ZipFileRO* zipFile = <span class="keyword">reinterpret_cast</span>&lt;ZipFileRO*&gt;(apkHandle);</span><br><span class="line">    <span class="keyword">if</span> (zipFile == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTALL_FAILED_INVALID_APK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    UniquePtr&lt;NativeLibrariesIterator&gt; it(NativeLibrariesIterator::create(zipFile));</span><br><span class="line">    <span class="keyword">if</span> (it.get() == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTALL_FAILED_INVALID_APK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ZipEntryRO entry = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">char</span> fileName[PATH_MAX];</span><br><span class="line">    <span class="keyword">int</span> status = NO_NATIVE_LIBRARIES;</span><br><span class="line">    <span class="comment">//这里开始遍历apk中每一个文件</span></span><br><span class="line">    <span class="keyword">while</span> ((entry = it-&gt;next()) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// We're currently in the lib/ directory of the APK, so it does have some native</span></span><br><span class="line">        <span class="comment">// code. We should return INSTALL_FAILED_NO_MATCHING_ABIS if none of the</span></span><br><span class="line">        <span class="comment">// libraries match.</span></span><br><span class="line">        <span class="keyword">if</span> (status == NO_NATIVE_LIBRARIES) &#123;</span><br><span class="line">            status = INSTALL_FAILED_NO_MATCHING_ABIS;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* fileName = it-&gt;currentEntry();</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* lastSlash = it-&gt;lastSlash();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check to see if this CPU ABI matches what we are looking for.</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* abiOffset = fileName + APK_LIB_LEN;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">size_t</span> abiSize = lastSlash - abiOffset;</span><br><span class="line">        <span class="comment">//遍历apk中的子文件，获取so文件的全路径，如果这个路径包含了cpu架构值，就记录返回索引</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numAbis; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> ScopedUtfChars* abi = supportedAbis[i];</span><br><span class="line">            <span class="keyword">if</span> (abi-&gt;size() == abiSize &amp;&amp; !<span class="built_in">strncmp</span>(abiOffset, abi-&gt;c_str(), abiSize)) &#123;</span><br><span class="line">                <span class="comment">// The entry that comes in first (i.e. with a lower index) has the higher priority.</span></span><br><span class="line">                <span class="keyword">if</span> (((i &lt; status) &amp;&amp; (status &gt;= <span class="number">0</span>)) || (status &lt; <span class="number">0</span>) ) &#123;</span><br><span class="line">                    status = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numAbis; ++i) &#123;</span><br><span class="line">        <span class="keyword">delete</span> supportedAbis[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这里看到了，会先读取apk文件，然后遍历apk文件中的so文件，得到全路径然后在和传递进来的abiList进行比较，得到合适的索引值。我们刚才拿到的abiList为：x86，然后就开始比较apk中有没有这些架构平台的so文件，如果有，就直接返回abiList中的索引值即可。比如apk中libs结构如下：<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E8%B5%84%E6%BA%90%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E5%8F%8A%E5%A1%AB%E5%9D%91%E5%A4%84%E7%90%86/apk.png" alt="apk的libs结构"></p>
<p>&#160; &#160; &#160; &#160;那么这个时候就只有这么一种架构，libs文件下也有相关的ABI类型，就只能返回0了；</p>
<p>&#160; &#160; &#160; &#160;假设我们的abiList为：arm64-v8a,armeabi-v7a,armeabi。那么这时候返回来的索引值就是0，代表的是arm64-v8a架构的。如果apk文件中没有arm64-v8a目录的话，那么就返回1，代表的是armeabi-v7a架构的。依次类推。得到应用支持的架构索引之后就可以获取so释放到设备中的目录了。</p>
<p>&#160; &#160; &#160; &#160;下一步就是获取so释放之后的目录，调用VMRuntime.java中的getInstructionSet方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getInstructionSet</span><span class="params">(String abi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> String instructionSet = ABI_TO_INSTRUCTION_SET_MAP.get(abi);</span><br><span class="line">    <span class="keyword">if</span> (instructionSet == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unsupported ABI: "</span> + abi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> instructionSet;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, String&gt; ABI_TO_INSTRUCTION_SET_MAP</span><br><span class="line">        = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    ABI_TO_INSTRUCTION_SET_MAP.put(<span class="string">"armeabi"</span>, <span class="string">"arm"</span>);</span><br><span class="line">    ABI_TO_INSTRUCTION_SET_MAP.put(<span class="string">"armeabi-v7a"</span>, <span class="string">"arm"</span>);</span><br><span class="line">    ABI_TO_INSTRUCTION_SET_MAP.put(<span class="string">"mips"</span>, <span class="string">"mips"</span>);</span><br><span class="line">    ABI_TO_INSTRUCTION_SET_MAP.put(<span class="string">"mips64"</span>, <span class="string">"mips64"</span>);</span><br><span class="line">    ABI_TO_INSTRUCTION_SET_MAP.put(<span class="string">"x86"</span>, <span class="string">"x86"</span>);</span><br><span class="line">    ABI_TO_INSTRUCTION_SET_MAP.put(<span class="string">"x86_64"</span>, <span class="string">"x86_64"</span>);</span><br><span class="line">    ABI_TO_INSTRUCTION_SET_MAP.put(<span class="string">"arm64-v8a"</span>, <span class="string">"arm64"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这一步主要是对获得的ABI架构字符串做了一下转换，比如从x86—&gt;x86，armeabi—&gt;arm等等。</p>
<p>&#160; &#160; &#160; &#160;最后就是释放so了，调用copyNativeBinaries方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">copyNativeBinaries</span><span class="params">(Handle handle, File sharedLibraryDir, String abi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> apkHandle : handle.apkHandles) &#123;</span><br><span class="line">        <span class="keyword">int</span> res = nativeCopyNativeBinaries(apkHandle, sharedLibraryDir.getPath(), abi);</span><br><span class="line">        <span class="keyword">if</span> (res != INSTALL_SUCCEEDED) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> INSTALL_SUCCEEDED;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nativeCopyNativeBinaries</span><span class="params">(<span class="keyword">long</span> handle,</span><br><span class="line">        String sharedLibraryPath, String abiToCopy)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;JNI层实现如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jint</span><br><span class="line"><span class="title">com_android_internal_content_NativeLibraryHelper_copyNativeBinaries</span><span class="params">(JNIEnv *env, jclass clazz,</span><br><span class="line">        jlong apkHandle, jstring javaNativeLibPath, jstring javaCpuAbi)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">//调用iterateOverNativeFiles方法，copyFileIfChanged是个函数指针，完成释放</span></span><br><span class="line">    <span class="keyword">return</span> (jint) iterateOverNativeFiles(env, apkHandle, javaCpuAbi,</span><br><span class="line">            copyFileIfChanged, &amp;javaNativeLibPath);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> install_status_t</span><br><span class="line"><span class="title">iterateOverNativeFiles</span><span class="params">(JNIEnv *env, jlong apkHandle, jstring javaCpuAbi,</span><br><span class="line">                       iterFunc callFunc, <span class="keyword">void</span>* callArg)</span> </span>&#123;</span><br><span class="line">    ZipFileRO* zipFile = <span class="keyword">reinterpret_cast</span>&lt;ZipFileRO*&gt;(apkHandle);</span><br><span class="line">    <span class="keyword">if</span> (zipFile == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTALL_FAILED_INVALID_APK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    UniquePtr&lt;NativeLibrariesIterator&gt; it(NativeLibrariesIterator::create(zipFile));</span><br><span class="line">    <span class="keyword">if</span> (it.get() == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTALL_FAILED_INVALID_APK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">const</span> ScopedUtfChars <span class="title">cpuAbi</span><span class="params">(env, javaCpuAbi)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (cpuAbi.c_str() == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// This would've thrown, so this return code isn't observable by</span></span><br><span class="line">        <span class="comment">// Java.</span></span><br><span class="line">        <span class="keyword">return</span> INSTALL_FAILED_INVALID_APK;</span><br><span class="line">    &#125;</span><br><span class="line">    ZipEntryRO entry = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> ((entry = it-&gt;next()) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* fileName = it-&gt;currentEntry();</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* lastSlash = it-&gt;lastSlash();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check to make sure the CPU ABI of this file is one we support.</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* cpuAbiOffset = fileName + APK_LIB_LEN;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">size_t</span> cpuAbiRegionSize = lastSlash - cpuAbiOffset;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cpuAbi.size() == cpuAbiRegionSize &amp;&amp; !<span class="built_in">strncmp</span>(cpuAbiOffset, cpuAbi.c_str(), cpuAbiRegionSize)) &#123;</span><br><span class="line">	        <span class="comment">//释放so，这一句才是关键，copyFileIfChanged完成释放</span></span><br><span class="line">            <span class="keyword">install_status_t</span> ret = callFunc(env, callArg, zipFile, entry, lastSlash + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ret != INSTALL_SUCCEEDED) &#123;</span><br><span class="line">                ALOGV(<span class="string">"Failure for entry %s"</span>, lastSlash + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> INSTALL_SUCCEEDED;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;最后的释放工作都交给了copyFileIfChanged函数，我们看看这个函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"> * Copy the native library if needed.</span><br><span class="line"> *</span><br><span class="line"> * This function assumes the library and path names passed in are considered safe.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> install_status_t</span><br><span class="line"><span class="title">copyFileIfChanged</span><span class="params">(JNIEnv *env, <span class="keyword">void</span>* arg, ZipFileRO* zipFile, ZipEntryRO zipEntry, <span class="keyword">const</span> <span class="keyword">char</span>* fileName)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    jstring* javaNativeLibPath = (jstring*) arg;</span><br><span class="line">    <span class="function">ScopedUtfChars <span class="title">nativeLibPath</span><span class="params">(env, *javaNativeLibPath)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> uncompLen;</span><br><span class="line">    <span class="keyword">long</span> when;</span><br><span class="line">    <span class="keyword">long</span> crc;</span><br><span class="line">    <span class="keyword">time_t</span> modTime;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!zipFile-&gt;getEntryInfo(zipEntry, <span class="literal">NULL</span>, &amp;uncompLen, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;when, &amp;crc)) &#123;</span><br><span class="line">        ALOGD(<span class="string">"Couldn't read zip entry info\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> INSTALL_FAILED_INVALID_APK;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">struct</span> tm t;</span><br><span class="line">        ZipUtils::zipTimeToTimespec(when, &amp;t);</span><br><span class="line">        modTime = mktime(&amp;t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Build local file path</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> fileNameLen = <span class="built_in">strlen</span>(fileName);</span><br><span class="line">    <span class="keyword">char</span> localFileName[nativeLibPath.size() + fileNameLen + <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (strlcpy(localFileName, nativeLibPath.c_str(), <span class="keyword">sizeof</span>(localFileName)) != nativeLibPath.size()) &#123;</span><br><span class="line">        ALOGD(<span class="string">"Couldn't allocate local file name for library"</span>);</span><br><span class="line">        <span class="keyword">return</span> INSTALL_FAILED_INTERNAL_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *(localFileName + nativeLibPath.size()) = <span class="string">'/'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (strlcpy(localFileName + nativeLibPath.size() + <span class="number">1</span>, fileName, <span class="keyword">sizeof</span>(localFileName)</span><br><span class="line">                    - nativeLibPath.size() - <span class="number">1</span>) != fileNameLen) &#123;</span><br><span class="line">        ALOGD(<span class="string">"Couldn't allocate local file name for library"</span>);</span><br><span class="line">        <span class="keyword">return</span> INSTALL_FAILED_INTERNAL_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Only copy out the native file if it's different.</span></span><br><span class="line">    <span class="comment">//只有so本地文件改变了才拷贝</span></span><br><span class="line">    <span class="keyword">struct</span> stat64 st;</span><br><span class="line">    <span class="keyword">if</span> (!isFileDifferent(localFileName, uncompLen, modTime, crc, &amp;st)) &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTALL_SUCCEEDED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> localTmpFileName[nativeLibPath.size() + TMP_FILE_PATTERN_LEN + <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> (strlcpy(localTmpFileName, nativeLibPath.c_str(), <span class="keyword">sizeof</span>(localTmpFileName))</span><br><span class="line">            != nativeLibPath.size()) &#123;</span><br><span class="line">        ALOGD(<span class="string">"Couldn't allocate local file name for library"</span>);</span><br><span class="line">        <span class="keyword">return</span> INSTALL_FAILED_INTERNAL_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *(localFileName + nativeLibPath.size()) = <span class="string">'/'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (strlcpy(localTmpFileName + nativeLibPath.size(), TMP_FILE_PATTERN,</span><br><span class="line">                    TMP_FILE_PATTERN_LEN - nativeLibPath.size()) != TMP_FILE_PATTERN_LEN) &#123;</span><br><span class="line">        ALOGI(<span class="string">"Couldn't allocate temporary file name for library"</span>);</span><br><span class="line">        <span class="keyword">return</span> INSTALL_FAILED_INTERNAL_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//生成一个临时文件，用于拷贝</span></span><br><span class="line">    <span class="keyword">int</span> fd = mkstemp(localTmpFileName);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGI(<span class="string">"Couldn't open temporary file name: %s: %s\n"</span>, localTmpFileName, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> INSTALL_FAILED_CONTAINER_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//解压so文件</span></span><br><span class="line">    <span class="keyword">if</span> (!zipFile-&gt;uncompressEntry(zipEntry, fd)) &#123;</span><br><span class="line">        ALOGI(<span class="string">"Failed uncompressing %s to %s\n"</span>, fileName, localTmpFileName);</span><br><span class="line">        close(fd);</span><br><span class="line">        unlink(localTmpFileName);</span><br><span class="line">        <span class="keyword">return</span> INSTALL_FAILED_CONTAINER_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the modification time for this file to the ZIP's mod time.</span></span><br><span class="line">    <span class="keyword">struct</span> timeval times[<span class="number">2</span>];</span><br><span class="line">    times[<span class="number">0</span>].tv_sec = st.st_atime;</span><br><span class="line">    times[<span class="number">1</span>].tv_sec = modTime;</span><br><span class="line">    times[<span class="number">0</span>].tv_usec = times[<span class="number">1</span>].tv_usec = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (utimes(localTmpFileName, times) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGI(<span class="string">"Couldn't change modification time on %s: %s\n"</span>, localTmpFileName, strerror(errno));</span><br><span class="line">        unlink(localTmpFileName);</span><br><span class="line">        <span class="keyword">return</span> INSTALL_FAILED_CONTAINER_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the mode to 755</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">mode_t</span> mode = S_IRUSR | S_IWUSR | S_IXUSR | S_IRGRP |  S_IXGRP | S_IROTH | S_IXOTH;</span><br><span class="line">    <span class="keyword">if</span> (chmod(localTmpFileName, mode) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGI(<span class="string">"Couldn't change permissions on %s: %s\n"</span>, localTmpFileName, strerror(errno));</span><br><span class="line">        unlink(localTmpFileName);</span><br><span class="line">        <span class="keyword">return</span> INSTALL_FAILED_CONTAINER_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Finally, rename it to the final name.</span></span><br><span class="line">    <span class="keyword">if</span> (rename(localTmpFileName, localFileName) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGI(<span class="string">"Couldn't rename %s to %s: %s\n"</span>, localTmpFileName, localFileName, strerror(errno));</span><br><span class="line">        unlink(localTmpFileName);</span><br><span class="line">        <span class="keyword">return</span> INSTALL_FAILED_CONTAINER_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ALOGV(<span class="string">"Successfully moved %s to %s\n"</span>, localTmpFileName, localFileName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> INSTALL_SUCCEEDED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;上述就是解压so文件的实现。先判断so名字合不合法，然后判断是不是文件改变了，再者创建一个临时文件，最后解压，用临时文件拷贝so到指定目录，结尾处关闭一些链接。</p>
<p>&#160; &#160; &#160; &#160;小结一下上述SO释放流程：</p>
<ul>
<li>通过遍历apk文件中的so文件的全路径，然后和系统的abiList中的类型值进行比较，如果匹配到了就返回arch类型的索引值</li>
<li>得到了应用所支持的arch类型之后，就开始获取创建本地释放so的目录</li>
<li>然后开始释放so文件</li>
</ul>
<h1 id="失败的尝试"><a href="#失败的尝试" class="headerlink" title="失败的尝试"></a>失败的尝试</h1><p>&#160; &#160; &#160; &#160;上面我们分析了插件apk中加载so库，必须指定DexClassLoader中第三个参数，这就要我们解压apk中的so了。所以我试着调用系统的NativeLibraryHelper相关方法，做了如下实验：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">@SuppressLint(<span class="string">"NewApi"</span>)</span><br><span class="line">@<span class="function">Override</span><br><span class="line"><span class="keyword">public</span> boolean <span class="title">loadSO</span><span class="params">(File apkFile, File nativeLibraryRoot)</span> </span>&#123;</span><br><span class="line">	NativeLibraryHelper.Handle handle = null;</span><br><span class="line"> 	<span class="keyword">try</span> &#123;</span><br><span class="line">		handle = NativeLibraryHelper.Handle.create(apkFile);</span><br><span class="line"> 		<span class="comment">//private static Handle create(List&lt;String&gt; codePaths, boolean multiArch) throws IOException</span></span><br><span class="line"> 		<span class="comment">/*Method create2 = NativeLibraryHelper.Handle.class.getDeclaredMethod("create", List.class, boolean.class);</span><br><span class="line"> 		create2.setAccessible(true);</span><br><span class="line"> 		List&lt;String&gt; apkList = new ArrayList&lt;String&gt;();</span><br><span class="line"> 		apkList.add(apkFile.getAbsolutePath());</span><br><span class="line"> 		handle = (Handle) create2.invoke(null, apkList, false);*/</span></span><br><span class="line"> 		<span class="comment">/*Method nativeOpenApk = NativeLibraryHelper.class.getDeclaredMethod("nativeOpenApk", String.class);</span><br><span class="line"> 		nativeOpenApk.setAccessible(true);</span><br><span class="line"> 		long apkHandle = (long) nativeOpenApk.invoke(null, apkFile.getAbsolutePath());</span><br><span class="line"> 		</span><br><span class="line"> 		Method nativeClose = NativeLibraryHelper.class.getDeclaredMethod("nativeClose", long.class);</span><br><span class="line"> 		nativeOpenApk.setAccessible(true);</span><br><span class="line"> 		nativeClose.invoke(null, apkHandle);</span><br><span class="line"> 		</span><br><span class="line"> 		Constructor&lt;Handle&gt; constructMethod = NativeLibraryHelper.Handle.class.getConstructor(long[].class, boolean.class);</span><br><span class="line"> 		constructMethod.setAccessible(true);</span><br><span class="line"> 		handle = constructMethod.newInstance(new long[]&#123;apkHandle&#125;, false);*/</span></span><br><span class="line"> 		</span><br><span class="line"> 		NativeLibraryHelper.copyNativeBinariesForSupportedAbi(handle,</span><br><span class="line">                   nativeLibraryRoot, Build.SUPPORTED_ABIS, <span class="literal">false</span>);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;finally&#123;</span><br><span class="line">		<span class="keyword">if</span> (handle != null) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            	handle.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">		&#125;    </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;然而并无卵用。。。。。。还有那些注释的尝试，也毫无作用= 。 =<br>&#160; &#160; &#160; &#160;如果大家知道原因的话，或者对这一块儿还有更好的实现方案，麻烦多多指教，在此提前献上妹子图。<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E8%B5%84%E6%BA%90%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E5%8F%8A%E5%A1%AB%E5%9D%91%E5%A4%84%E7%90%86/meizi.jpg" alt="妹子图"></p>
<h1 id="剩下的坑"><a href="#剩下的坑" class="headerlink" title="剩下的坑"></a>剩下的坑</h1><p>&#160; &#160; &#160; &#160;关于四大组件生命周期的管理也是一个难点，这里限于篇幅只能止步于此。如果以后有时间的话，我会努力补上。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[智能指针简单分析]]></title>
      <url>http://windrunnerlihuan.com/2016/08/23/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<hr>
<p>&#160; &#160; &#160; &#160;前一阵子好忙，忙的根本停不下来。现在还好点，能闲一些。所以抽空把之前没研究完的Android智能指针继续研究。<br><a id="more"></a></p>
<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>&#160; &#160; &#160; &#160;写C++程序时对指针的使用一定要十分谨慎，自己new出来的对象，如果忘记了delete，多次之后就会有比较严重的内存泄露；如果对指针忘记初始化，有时会出现野指针问题；已经释放了申请的内存，但是还在使用指向它的指针，又是一个悬垂指针……其实还有很多使用不当的情况，但是C++又不是java，jvm拥有强大的垃圾回收机制。但是为了避免种种指针使用不当引发的问题，STL标准模板库提供了<strong>智能指针</strong>这个工具。<br>&#160; &#160; &#160; &#160;Google在Android源码中也引入了智能指针这个概念，参考了java垃圾收集器和STL的智能指针，从而自己封装了一套工具类。</p>
<h2 id="设计理念"><a href="#设计理念" class="headerlink" title="设计理念"></a>设计理念</h2><p>&#160; &#160; &#160; &#160;如果要合理管理内存回收，一般的做法就是使用引用计数的方法。每当有一个指针指向了一个new出来的对象时，就对这个对象的引用计数增加1，每当有一个指针不再使用这个对象时，就对这个对象的引用计数减少1，每次减1之后，如果发现引用计数值为0时，那么，就要delete这个对象了，这样就避免了忘记delete对象或者这个对象被delete之后其它地方还在使用的问题了。但是该如何实现这个引用计数呢？我们知道，C++中对象的创建和销毁会分别调用构造函数和析构函数，所以引用计数的工作就落实在他们身上，同时还应该重载一些运算符，重载一些拷贝构造函数，以完善智能指针的功能。</p>
<p>&#160; &#160; &#160; &#160;在计算机科学领域中，提供垃圾收集（Garbage Collection）功能的系统框架，即提供对象托管功能的系统框架，例如Java应用程序框架，也是采用上述的引用计数技术方案来实现的，然而，简单的引用计数技术不能处理系统中对象间循环引用的情况。考虑这样的一个场景，系统中有两个对象A和B，在对象A的内部引用了对象B，而在对象B的内部也引用了对象A。当两个对象A和B都不再使用时，垃圾收集系统会发现无法回收这两个对象的所占据的内存的，因为系统一次只能收集一个对象，而无论系统决定要收回对象A还是要收回对象B时，都会发现这个对象被其它的对象所引用，因而就都回收不了，这样就造成了内存泄漏。这样，就要采取另外的一种引用计数技术了，即对象的引用计数同时存在强引用和弱引用两种计数，例如，Apple公司提出的<code>Cocoa</code>框架，<strong>当父对象要引用子对象时，就对子对象使用强引用计数技术，而当子对象要引用父对象时，就对父对象使用弱引用计数技术，而当垃圾收集系统执行对象回收工作时，只要发现对象的强引用计数为0，而不管它的弱引用计数是否为0，都可以回收这个对象，但是，如果我们只对一个对象持有弱引用计数，当我们要使用这个对象时，就不直接使用了，必须要把这个弱引用升级成为强引用时，才能使用这个对象，在转换的过程中，如果对象已经不存在，那么转换就失败了，这时候就说明这个对象已经被销毁了，不能再使用了</strong>。</p>
<h1 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h1><p>&#160; &#160; &#160; &#160;Android系统提供了强大的智能指针技术供我们使用，这些智能指针实现方案既包括简单的引用计数技术，也包括了复杂的引用计数技术，即对象既有强引用计数，也有弱引用计数。我们最常见的智能指针就是强指针sp（Strong Pointer）和弱指针wp（Weak Pointer）。要实现内存的自动释放，sp、wp必须结合RefBase这个类来使用，在Android中，大多数类的最上层基类都是RefBase类。我们就只看这两种比较重要的吧。</p>
<h2 id="强指针"><a href="#强指针" class="headerlink" title="强指针"></a>强指针</h2><p>&#160; &#160; &#160; &#160;强指针使用的引用计数类为RefBase，我们看看它的定义，位于system/core/include/utils/RefBash.h：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> RefBase</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">            <span class="function"><span class="keyword">void</span>            <span class="title">incStrong</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span> <span class="keyword">const</span></span>;<span class="comment">//增加强引用计数</span></span><br><span class="line">            <span class="function"><span class="keyword">void</span>            <span class="title">decStrong</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span> <span class="keyword">const</span></span>;<span class="comment">//减少强引用计数</span></span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">void</span>            <span class="title">forceIncStrong</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span> <span class="keyword">const</span></span>;<span class="comment">//强制增加强引用计数</span></span><br><span class="line"></span><br><span class="line">			......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> weakref_type <span class="comment">//实现引用计数功能的接口类</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">RefBase*            <span class="title">refBase</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span>                <span class="title">incWeak</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span></span>;<span class="comment">//增加弱引用计数</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span>                <span class="title">decWeak</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span></span>;<span class="comment">//减少弱引用计数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// acquires a strong reference if there is already one.</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span>                <span class="title">attemptIncStrong</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// acquires a weak reference if there is already one.</span></span><br><span class="line">        <span class="comment">// This is not always safe. see ProcessState.cpp and BpBinder.cpp</span></span><br><span class="line">        <span class="comment">// for proper use.</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span>                <span class="title">attemptIncWeak</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span></span>;</span><br><span class="line"></span><br><span class="line">		......</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="function">weakref_type*   <span class="title">createWeak</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="function">weakref_type*   <span class="title">getWeakRefs</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">	......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> RefBase basetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">                            RefBase();</span><br><span class="line">    <span class="keyword">virtual</span>                 ~RefBase();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! Flags for extendObjectLifetime()</span></span><br><span class="line">    <span class="keyword">enum</span> &#123;</span><br><span class="line">        OBJECT_LIFETIME_STRONG  = <span class="number">0x0000</span>,</span><br><span class="line">        OBJECT_LIFETIME_WEAK    = <span class="number">0x0001</span>,</span><br><span class="line">        OBJECT_LIFETIME_MASK    = <span class="number">0x0001</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">void</span>            <span class="title">extendObjectLifetime</span><span class="params">(<span class="keyword">int32_t</span> mode)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! Flags for onIncStrongAttempted()</span></span><br><span class="line">    <span class="keyword">enum</span> &#123;</span><br><span class="line">        FIRST_INC_STRONG = <span class="number">0x0001</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span>            <span class="title">onFirstRef</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span>            <span class="title">onLastStrongRef</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span>            <span class="title">onIncStrongAttempted</span><span class="params">(<span class="keyword">uint32_t</span> flags, <span class="keyword">const</span> <span class="keyword">void</span>* id)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span>            <span class="title">onLastWeakRef</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span></span>;</span><br><span class="line"></span><br><span class="line">	......</span><br><span class="line">	</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> weakref_type; <span class="comment">//将辅助类设为友元，方便操作完成计数功能</span></span><br><span class="line">    <span class="keyword">class</span> weakref_impl;</span><br><span class="line"></span><br><span class="line">                            RefBase(<span class="keyword">const</span> RefBase&amp; o); <span class="comment">//重载拷贝构造函数，避免默认拷贝构造函数的浅拷贝现象，因此实现类里要实现深拷贝</span></span><br><span class="line">            RefBase&amp;        <span class="keyword">operator</span>=(<span class="keyword">const</span> RefBase&amp; o);<span class="comment">//赋值运算符重载</span></span><br><span class="line"></span><br><span class="line">        weakref_impl* <span class="keyword">const</span> mRefs;<span class="comment">//通过这个类实现引用计数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;RefBase类提供了incStrong和decStrong成员函数来操作它的引用计数器，复杂的引用计数技术同时支持强引用计数和弱引用计数，在RefBase类中，这两种计数功能是通过其成员变量mRefs来提供的。<br>&#160; &#160; &#160; &#160;RefBase类的成员变量mRefs的类型为weakref_impl指针，从weakref_impl的类名来看，它应该是一个实现类，那么，就必然有一个对应的接口类，这个对应的接口类的就是RefBase类内部定义的weakref_type类了，这是一种把类的实现与接口定义分离的设计方法，也是一种多态的展现。weakref_impl的实现位于system/core/libutils/RefBash.cpp中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> RefBase::weakref_impl : <span class="keyword">public</span> RefBase::weakref_type</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int32_t</span>    mStrong;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int32_t</span>    mWeak;</span><br><span class="line">    RefBase* <span class="keyword">const</span>      mBase;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int32_t</span>    mFlags;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !DEBUG_REFS <span class="comment">//如果是Release版本，</span></span></span><br><span class="line"></span><br><span class="line">    weakref_impl(RefBase* base)</span><br><span class="line">        : mStrong(INITIAL_STRONG_VALUE)</span><br><span class="line">        , mWeak(<span class="number">0</span>)</span><br><span class="line">        , mBase(base)</span><br><span class="line">        , mFlags(<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addStrongRef</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* <span class="comment">/*id*/</span>)</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeStrongRef</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* <span class="comment">/*id*/</span>)</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addWeakRef</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* <span class="comment">/*id*/</span>)</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeWeakRef</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* <span class="comment">/*id*/</span>)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">//那就只有这么多，下面都是Debug版本的</span></span></span><br><span class="line"></span><br><span class="line">    weakref_impl(RefBase* base)</span><br><span class="line">        : mStrong(INITIAL_STRONG_VALUE)</span><br><span class="line">        , mWeak(<span class="number">0</span>)</span><br><span class="line">        , mBase(base)</span><br><span class="line">        , mFlags(<span class="number">0</span>)</span><br><span class="line">        , mStrongRefs(<span class="literal">NULL</span>)</span><br><span class="line">        , mWeakRefs(<span class="literal">NULL</span>)</span><br><span class="line">        , mTrackEnabled(!!DEBUG_REFS_ENABLED_BY_DEFAULT)</span><br><span class="line">        , mRetain(<span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~weakref_impl()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">bool</span> dumpStack = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (!mRetain &amp;&amp; mStrongRefs != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            dumpStack = <span class="literal">true</span>;</span><br><span class="line">            ref_entry* refs = mStrongRefs;</span><br><span class="line">            <span class="keyword">while</span> (refs) &#123;</span><br><span class="line">                refs = refs-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!mRetain &amp;&amp; mWeakRefs != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            dumpStack = <span class="literal">true</span>;</span><br><span class="line">            ref_entry* refs = mWeakRefs;</span><br><span class="line">            <span class="keyword">while</span> (refs) &#123;</span><br><span class="line"></span><br><span class="line">                refs = refs-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addStrongRef</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        addRef(&amp;mStrongRefs, id, mStrong);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeStrongRef</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!mRetain) &#123;</span><br><span class="line">            removeRef(&amp;mStrongRefs, id);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            addRef(&amp;mStrongRefs, id, -mStrong);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addWeakRef</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span> </span>&#123;</span><br><span class="line">        addRef(&amp;mWeakRefs, id, mWeak);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeWeakRef</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!mRetain) &#123;</span><br><span class="line">            removeRef(&amp;mWeakRefs, id);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            addRef(&amp;mWeakRefs, id, -mWeak);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> ref_entry</span><br><span class="line">    &#123;</span><br><span class="line">        ref_entry* next;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">void</span>* id;</span><br><span class="line">        <span class="keyword">int32_t</span> ref;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addRef</span><span class="params">(ref_entry** refs, <span class="keyword">const</span> <span class="keyword">void</span>* id, <span class="keyword">int32_t</span> mRef)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mTrackEnabled) &#123;</span><br><span class="line">            AutoMutex _l(mMutex);</span><br><span class="line"></span><br><span class="line">            ref_entry* ref = <span class="keyword">new</span> ref_entry;</span><br><span class="line">            <span class="comment">// Reference count at the time of the snapshot, but before the</span></span><br><span class="line">            <span class="comment">// update.  Positive value means we increment, negative--we</span></span><br><span class="line">            <span class="comment">// decrement the reference count.</span></span><br><span class="line">            ref-&gt;ref = mRef;</span><br><span class="line">            ref-&gt;id = id;</span><br><span class="line"></span><br><span class="line">            ref-&gt;next = *refs;</span><br><span class="line">            *refs = ref;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeRef</span><span class="params">(ref_entry** refs, <span class="keyword">const</span> <span class="keyword">void</span>* id)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mTrackEnabled) &#123;</span><br><span class="line">            AutoMutex _l(mMutex);</span><br><span class="line">            </span><br><span class="line">            ref_entry* <span class="keyword">const</span> head = *refs;</span><br><span class="line">            ref_entry* ref = head;</span><br><span class="line">            <span class="keyword">while</span> (ref != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ref-&gt;id == id) &#123;</span><br><span class="line">                    *refs = ref-&gt;next;</span><br><span class="line">                    <span class="keyword">delete</span> ref;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                refs = &amp;ref-&gt;next;</span><br><span class="line">                ref = *refs;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ref = head;</span><br><span class="line">            <span class="keyword">while</span> (ref) &#123;</span><br><span class="line">                ref = ref-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">mutable</span> Mutex mMutex;</span><br><span class="line">    ref_entry* mStrongRefs;</span><br><span class="line">    ref_entry* mWeakRefs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> mTrackEnabled;</span><br><span class="line">    <span class="comment">// Collect stack traces on addref and removeref, instead of deleting the stack references</span></span><br><span class="line">    <span class="comment">// on removeref that match the address ones.</span></span><br><span class="line">    <span class="keyword">bool</span> mRetain;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span><span class="comment">//Debug版本结束</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这个类看起来很复杂，其实分为两部分看，还是很简单的。我们可以看到将它一分为二的条件宏：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !DEBUG_REFS  </span></span><br><span class="line">...Release版本...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">...Debug版本...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;if宏里面的都是Release版本的，它的函数都是空实现；else宏下面的是Debug版本代码，它的成员函数都是有实现的，实现这些函数的目的都是为了方便开发人员调试引用计数用的，除此之外，还在内部实现了一个结构体ref_entry：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ref_entry</span><br><span class="line">&#123;</span><br><span class="line">    ref_entry* next;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span>* id;</span><br><span class="line">    <span class="keyword">int32_t</span> ref;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这个结构体也是为了方便调试的，这是一个链表的节点，那么我猜测Debug版本的引用计数调试时应该用的链表实现的。本来Debug版本我们可以不用关注，但这里本着学习C++的态度还是稍微看一看。比如我们先挑一个addRef(ref_entry<em>* refs, const void</em> id, int32_t mRef)函数看看：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addRef</span><span class="params">(ref_entry** refs, <span class="keyword">const</span> <span class="keyword">void</span>* id, <span class="keyword">int32_t</span> mRef)</span><span class="comment">//要改变一个指针，必须用到二级指针</span></span><br><span class="line">   </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (mTrackEnabled) &#123;<span class="comment">//ture</span></span><br><span class="line">           AutoMutex _l(mMutex);</span><br><span class="line"></span><br><span class="line">           ref_entry* ref = <span class="keyword">new</span> ref_entry; <span class="comment">//新建一个节点</span></span><br><span class="line">           <span class="comment">// Reference count at the time of the snapshot, but before the</span></span><br><span class="line">           <span class="comment">// update.  Positive value means we increment, negative--we</span></span><br><span class="line">           <span class="comment">// decrement the reference count.</span></span><br><span class="line">           <span class="comment">//填充节点数据</span></span><br><span class="line">           ref-&gt;ref = mRef;</span><br><span class="line">           ref-&gt;id = id;</span><br><span class="line">		<span class="comment">//头插法插入</span></span><br><span class="line">           ref-&gt;next = *refs;<span class="comment">//将新节点的next指针指向头指针的地址</span></span><br><span class="line">           *refs = ref; <span class="comment">//将头指针重新指向新节点</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这个应该很随意吧，就是头插法插入新节点。先把需要插入的节点的next域直线目标链表的头节点内容，然后把头结点重新指向新节点即可。接着我们再看看removeRef(ref_entry<em>* refs, const void</em> id)函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeRef</span><span class="params">(ref_entry** refs, <span class="keyword">const</span> <span class="keyword">void</span>* id)</span><span class="comment">///要改变一个指针，必须用到二级指针</span></span><br><span class="line">   </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (mTrackEnabled) &#123;<span class="comment">//true</span></span><br><span class="line">           AutoMutex _l(mMutex);</span><br><span class="line">           </span><br><span class="line">           ref_entry* <span class="keyword">const</span> head = *refs;<span class="comment">//拿到指向目标指针的地址的指针</span></span><br><span class="line">           ref_entry* ref = head;<span class="comment">//拿到这个指针的头结点</span></span><br><span class="line">           <span class="keyword">while</span> (ref != <span class="literal">NULL</span>) &#123;<span class="comment">//从头往后遍历</span></span><br><span class="line">               <span class="keyword">if</span> (ref-&gt;id == id) &#123;<span class="comment">//如果发现指定节点</span></span><br><span class="line">                   *refs = ref-&gt;next;<span class="comment">//则跳过这个节点的指向，直接指向下一个节点</span></span><br><span class="line">                   <span class="keyword">delete</span> ref;<span class="comment">//然后删除指定节点</span></span><br><span class="line">                   <span class="keyword">return</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//如果没有找到指定项，则继续向后遍历</span></span><br><span class="line">               refs = &amp;ref-&gt;next;</span><br><span class="line">               ref = *refs;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           ref = head;</span><br><span class="line">           <span class="keyword">while</span> (ref) &#123;</span><br><span class="line">               ref = ref-&gt;next;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这一段应该也不难，就是从头到尾依次遍历每个链表节点，发现了指定项就把指向它的节点跳过指向它，直接指向它的下一个节点，然后删除指定项ok。</p>
<p> &#160; &#160; &#160; &#160;总的来说，weakref_impl类只要提供了以下四个成员变量来维护对象的引用计数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int32_t</span>    mStrong;</span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int32_t</span>    mWeak;</span><br><span class="line">RefBase* <span class="keyword">const</span>      mBase;</span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int32_t</span>    mFlags;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;其中mStrong和mWeak分别表示对象的强引用计数和弱引用计数；RefBase类包含了一个weakref_impl类指针mRefs，而这里的 weakref_impl类也有一个成员变量mBase来指向它的宿主类RefBase；mFlags是一个标志位，它指示了维护对象引用计数所使用的策略，它的取值为0，或者以下的枚举值：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//! Flags for extendObjectLifetime()</span></span><br><span class="line"><span class="keyword">enum</span> &#123;  </span><br><span class="line">    OBJECT_LIFETIME_STRONG  = <span class="number">0x0000</span>,</span><br><span class="line">    OBJECT_LIFETIME_WEAK    = <span class="number">0x0001</span>,</span><br><span class="line">    OBJECT_LIFETIME_MASK    = <span class="number">0x0001</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;引用计数器的类RefBase我们就暂时介绍到这里,现在先来看看强指针类和弱指针类的定义。强指针就是sp类，位于system/core/include/utils/StrongPointer.h下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">class sp &#123;</span><br><span class="line">public:</span><br><span class="line">    inline sp() : m_ptr(0) &#123; &#125;//构造函数</span><br><span class="line">	//拷贝构造函数</span><br><span class="line">    sp(T* other);</span><br><span class="line">    sp(const sp&lt;T&gt;&amp; other);</span><br><span class="line">    template&lt;typename U&gt; sp(U* other);</span><br><span class="line">    template&lt;typename U&gt; sp(const sp&lt;U&gt;&amp; other);</span><br><span class="line"></span><br><span class="line">    ~sp();</span><br><span class="line"></span><br><span class="line">    // Assignment</span><br><span class="line">	//赋值运算符重载</span><br><span class="line">    sp&amp; operator = (T* other);</span><br><span class="line">    sp&amp; operator = (const sp&lt;T&gt;&amp; other);</span><br><span class="line"></span><br><span class="line">    template&lt;typename U&gt; sp&amp; operator = (const sp&lt;U&gt;&amp; other);</span><br><span class="line">    template&lt;typename U&gt; sp&amp; operator = (U* other);</span><br><span class="line"></span><br><span class="line">    //! Special optimization for use by ProcessState (and nobody else).</span><br><span class="line">    void force_set(T* other);</span><br><span class="line"></span><br><span class="line">    // Reset</span><br><span class="line"></span><br><span class="line">    void clear();</span><br><span class="line"></span><br><span class="line">    // Accessors</span><br><span class="line">	//地址相关运算符重载</span><br><span class="line">    inline  T&amp;      operator* () const  &#123; return *m_ptr; &#125;</span><br><span class="line">    inline  T*      operator-&gt; () const &#123; return m_ptr;  &#125;</span><br><span class="line">    inline  T*      get() const         &#123; return m_ptr; &#125;</span><br><span class="line"></span><br><span class="line">    // Operators</span><br><span class="line"></span><br><span class="line">    COMPARE(==)</span><br><span class="line">    COMPARE(!=)</span><br><span class="line">    COMPARE(&gt;)</span><br><span class="line">    COMPARE(&lt;)</span><br><span class="line">    COMPARE(&lt;=)</span><br><span class="line">    COMPARE(&gt;=)</span><br><span class="line"></span><br><span class="line">private:    </span><br><span class="line">	//友元类</span><br><span class="line">    template&lt;typename Y&gt; friend class sp;</span><br><span class="line">    template&lt;typename Y&gt; friend class wp;</span><br><span class="line">    void set_pointer(T* ptr);</span><br><span class="line">    T* m_ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;上面是对sp类的一些定义，对于实现我们一个个来看。先看看拷贝构造函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;  </span><br><span class="line">sp&lt;T&gt;::sp(T* other)  </span><br><span class="line">    : m_ptr(other)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">if</span> (other) other-&gt;incStrong(<span class="keyword">this</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这里传进来的参数other一定是继承于RefBase类的，因此，在函数的内部，它调用的是RefBase类的incStrong函数，它定义在system/core/libutils/RefBash.cpp文件中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> RefBase::incStrong(<span class="keyword">const</span> <span class="keyword">void</span>* id) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    weakref_impl* <span class="keyword">const</span> refs = mRefs;</span><br><span class="line">    refs-&gt;incWeak(id);<span class="comment">//增加弱引用计数</span></span><br><span class="line">    </span><br><span class="line">    refs-&gt;addStrongRef(id);<span class="comment">//这玩意儿在Release版本是空实现，上面分析过</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int32_t</span> c = android_atomic_inc(&amp;refs-&gt;mStrong);<span class="comment">//增加强引用计数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c != INITIAL_STRONG_VALUE)  &#123;<span class="comment">//如果不是第一调用则返回</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//如果是第一次调用，则要减去mStrong的初始化值</span></span><br><span class="line">    android_atomic_add(-INITIAL_STRONG_VALUE, &amp;refs-&gt;mStrong);</span><br><span class="line">    refs-&gt;mBase-&gt;onFirstRef();<span class="comment">//第一次调用的回调方法，可自己重写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这个IncStrong函数主要做了三件事：1.增加若引用计数；2.增加强引用计数；3.如果发现是首次调用这个对象的incStrong函数，就会调用一个这个对象的onFirstRef函数，让对象有机会在对象被首次引用时做一些处理逻辑。<br>&#160; &#160; &#160; &#160;android_atomic_inc函数相当于i++表达式，会对变量加一，但是返回的是加一前的值。这里的c返回的是refs-&gt;mStrong加1前的值，如果发现等于INITIAL_STRONG_VALUE，就说明这个对象的强引用计数是第一次被增加，因此，refs-&gt;mStrong就是初始化为INITIAL_STRONG_VALUE的，它的值为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INITIAL_STRONG_VALUE (1<span class="meta-string">&lt;&lt;28)</span></span></span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;因为首次调用初始值为INITIAL_STRONG_VALUE，所以为了以后能够正确计数，因此首次需要减去它的初始值，所以才有了—INITIAL_STRONG_VALUE操作，然后android_atomic_inc函数会自动加一，所以首次调用后引用计数为1，逻辑正确。</p>
<p>&#160; &#160; &#160; &#160;然后我们继续回到incStrong函数中，看看弱引用计数是如何增加的。首先是调用weakref_impl类的addWeakRef函数，我们知道，在Release版本中，这个函数也不做，而在Debug版本中，这个函数增加了一个ref_entry对象到了weakref_impl对象的mWeakRefs列表中，表示此weakref_impl对象的弱引用计数被增加了一次。接着又调用了weakref_impl类的incWeak函数，真正增加弱引用计数值就是在这个函数实现的了，weakref_impl类的incWeak函数继承于其父类weakref_type的incWeak函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> RefBase::weakref_type::incWeak(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span><br><span class="line">&#123;</span><br><span class="line">    weakref_impl* <span class="keyword">const</span> impl = <span class="keyword">static_cast</span>&lt;weakref_impl*&gt;(<span class="keyword">this</span>);<span class="comment">//强制类型转换</span></span><br><span class="line">    impl-&gt;addWeakRef(id);<span class="comment">//及时是Debug版本，为啥这儿又多调了一遍这个调试方法？excuse me？</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int32_t</span> c __unused = android_atomic_inc(&amp;impl-&gt;mWeak);<span class="comment">//增加弱引用计数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;可以看到最后一行增加了弱引用计数。不过第二行那个再次增加一次Debug版本的调试链表节点很诡异唉，不知为何。有人问过Android源码Binder通信机制模块的作者<a href="http://www.angryredplanet.com/~hackbod/" target="_blank" rel="external">Dianne Hackborn</a> ，他是这样<a href="http://groups.google.com/group/android-platform/browse_thread/thread/cc641db8487dd83" target="_blank" rel="external">回答</a>的：</p>
<blockquote>
<p>Ah I see.  Well the debug code may be broken, though I wouldn’t leap to that<br>        conclusion without actually testing it; I know it has been used in the<br>        past.  Anyway, these things get compiled out in non-debug builds, so there<br>        is no reason to change them unless you are actually trying to use this debug<br>        code and it isn’t working and need to do this to fix it. </p>
</blockquote>
<p>&#160; &#160; &#160; &#160;然而大神也不知道，那我们也不用管了=  。=</p>
<p>&#160; &#160; &#160; &#160;所以sp在其构造函数里面所做的事情就是分别为目标对象的强引用计数和弱引和计数增加了1。</p>
<p>&#160; &#160; &#160; &#160;然后我们再看看析构函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;  </span><br><span class="line">sp&lt;T&gt;::~sp()  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">if</span> (m_ptr) m_ptr-&gt;decStrong(<span class="keyword">this</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;同样，这里的m_ptr指向的目标对象一定是继承了RefBase类的，因此，这里调用的是RefBase类的decStrong函数，这也是定义在system/core/libutils/RefBash.cpp文件中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> RefBase::decStrong(<span class="keyword">const</span> <span class="keyword">void</span>* id) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    weakref_impl* <span class="keyword">const</span> refs = mRefs;</span><br><span class="line">    refs-&gt;removeStrongRef(id);<span class="comment">//Debug版本的，没什么卵用</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int32_t</span> c = android_atomic_dec(&amp;refs-&gt;mStrong);<span class="comment">//减少强引用计数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">1</span>) &#123;<span class="comment">//如果强引用计数减为0了</span></span><br><span class="line">        refs-&gt;mBase-&gt;onLastStrongRef(id);<span class="comment">//最后以一次引用了的回调</span></span><br><span class="line">        <span class="keyword">if</span> ((refs-&gt;mFlags&amp;OBJECT_LIFETIME_MASK) == OBJECT_LIFETIME_STRONG) &#123;<span class="comment">//如果是强引用主导生命周期</span></span><br><span class="line">            <span class="keyword">delete</span> <span class="keyword">this</span>;<span class="comment">//则直接回收这个对象</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    refs-&gt;decWeak(id); <span class="comment">//减少弱引用计数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;decStrong函数每次先减少强引用计数；然后判断是不是强引用计数是否为0，如果为0则看看标志位是不是设了OBJECT_LIFETIME_WEAK或者其他的，如果没有设置，则直接delete对象；如果受OBJECT_LIFETIME_WEAK等标志位影响，比如受弱应用计数主导生命周期，则等到弱引用计数也为0才能delete对象；最后在减少弱引用计数。<br>&#160; &#160; &#160; &#160;真正实现强引用计数减1的操作下面的refs-&gt;decWeak函数，weakref_impl类没有实现自己的decWeak函数，它继承了weakref_type类的decWeak函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> RefBase::weakref_type::decWeak(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span><br><span class="line">&#123;</span><br><span class="line">    weakref_impl* <span class="keyword">const</span> impl = <span class="keyword">static_cast</span>&lt;weakref_impl*&gt;(<span class="keyword">this</span>);<span class="comment">//强制类型转换</span></span><br><span class="line">    impl-&gt;removeWeakRef(id);<span class="comment">//这个和上面那个为毛一个道理，Google大神都不知道，不用鸟</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int32_t</span> c = android_atomic_dec(&amp;impl-&gt;mWeak);<span class="comment">//减少弱引用计数</span></span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">1</span>) <span class="keyword">return</span>;<span class="comment">//如果没有减少到0，则直接返回</span></span><br><span class="line">	<span class="comment">//如果弱引用计数减到0了</span></span><br><span class="line">    <span class="keyword">if</span> ((impl-&gt;mFlags&amp;OBJECT_LIFETIME_WEAK) == OBJECT_LIFETIME_STRONG) &#123;<span class="comment">//如果生命周期是强引用主导，则直接删除对象</span></span><br><span class="line">        <span class="comment">// This is the regular lifetime case. The object is destroyed</span></span><br><span class="line">        <span class="comment">// when the last strong reference goes away. Since weakref_impl</span></span><br><span class="line">        <span class="comment">// outlive the object, it is not destroyed in the dtor, and</span></span><br><span class="line">        <span class="comment">// we'll have to do it here.</span></span><br><span class="line">        <span class="keyword">if</span> (impl-&gt;mStrong == INITIAL_STRONG_VALUE) &#123;</span><br><span class="line">            <span class="comment">// Special case: we never had a strong reference, so we need to</span></span><br><span class="line">            <span class="comment">// destroy the object now.</span></span><br><span class="line">            <span class="keyword">delete</span> impl-&gt;mBase;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// ALOGV("Freeing refs %p of old RefBase %p\n", this, impl-&gt;mBase);</span></span><br><span class="line">            <span class="keyword">delete</span> impl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果生命周期受弱引用或者FOREVER类型主导</span></span><br><span class="line">        <span class="comment">// less common case: lifetime is OBJECT_LIFETIME_&#123;WEAK|FOREVER&#125;</span></span><br><span class="line">        impl-&gt;mBase-&gt;onLastWeakRef(id);</span><br><span class="line">        <span class="keyword">if</span> ((impl-&gt;mFlags&amp;OBJECT_LIFETIME_MASK) == OBJECT_LIFETIME_WEAK) &#123;<span class="comment">//如果生命周期受弱引用主导</span></span><br><span class="line">            <span class="comment">// this is the OBJECT_LIFETIME_WEAK case. The last weak-reference</span></span><br><span class="line">            <span class="comment">// is gone, we can destroy the object.</span></span><br><span class="line">            <span class="keyword">delete</span> impl-&gt;mBase;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果是FOREVER，则需要手动删除</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这里减少了弱引用计数，  减1前如果发现不等于1，那么就什么也不用做就返回了，如果发现等于1，就说明当前对象的弱引用计数值为0了，这时候，就要看看是否要delete这个对象了：<br>&#160; &#160; &#160; &#160;1. 如果目标对象的如果生命周期是强引用主导，就执行下面语句：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This is the regular lifetime case. The object is destroyed</span></span><br><span class="line"><span class="comment">// when the last strong reference goes away. Since weakref_impl</span></span><br><span class="line"><span class="comment">// outlive the object, it is not destroyed in the dtor, and</span></span><br><span class="line"><span class="comment">// we'll have to do it here.</span></span><br><span class="line"><span class="keyword">if</span> (impl-&gt;mStrong == INITIAL_STRONG_VALUE) &#123;</span><br><span class="line">    <span class="comment">// Special case: we never had a strong reference, so we need to</span></span><br><span class="line">    <span class="comment">// destroy the object now.</span></span><br><span class="line">    <span class="keyword">delete</span> impl-&gt;mBase;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ALOGV("Freeing refs %p of old RefBase %p\n", this, impl-&gt;mBase);</span></span><br><span class="line">    <span class="keyword">delete</span> impl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这一段的注释很重要，通过看注释，这段意思是：这里是减少对象的弱引用计数的地方，如果调用到这里，那么就说明前面一定有增加过此对象的弱引用计数，而增加对象的弱引用计数有两种场景的，一种场景是增加对象的强引用计数的时候，会同时增加对象的弱引用计数，另一种场景是当我们使用一个弱指针来指向对象时，在弱指针对象的构造函数里面，也会增加对象的弱引用计数，不过这时候，就只是增加对象的弱引用计数了，并没有同时增加对象的强引用计数。因此，这里在减少对象的弱引用计数时，就要分两种情况来考虑。</p>
<p>&#160; &#160; &#160; &#160;如果是前一种场景，这里的impl-&gt;mStrong就必然等于0，而不会等于INITIAL_STRONG_VALUE值，因此，这里就不需要delete目标对象了（impl-&gt;mBase），因为前面的RefBase::decStrong函数会负责delete这个对象。这里唯一需要做的就是把weakref_impl对象delete掉，但是，为什么要在这里delete这个weakref_impl对象呢？这里的weakref_impl对象是在RefBase的构造函数里面new出来的，理论上说应该在在RefBase的析构函数里delete掉这个weakref_impl对象的。在RefBase的析构函数里面，的确是会做这件事情：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">RefBase::~RefBase()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (mRefs-&gt;mStrong == INITIAL_STRONG_VALUE) &#123;</span><br><span class="line">        <span class="comment">// we never acquired a strong (and/or weak) reference on this object.</span></span><br><span class="line">        <span class="keyword">delete</span> mRefs;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// life-time of this object is extended to WEAK or FOREVER, in</span></span><br><span class="line">        <span class="comment">// which case weakref_impl doesn't out-live the object and we</span></span><br><span class="line">        <span class="comment">// can free it now.</span></span><br><span class="line">        <span class="keyword">if</span> ((mRefs-&gt;mFlags &amp; OBJECT_LIFETIME_MASK) != OBJECT_LIFETIME_STRONG) &#123;</span><br><span class="line">            <span class="comment">// It's possible that the weak count is not 0 if the object</span></span><br><span class="line">            <span class="comment">// re-acquired a weak reference in its destructor</span></span><br><span class="line">            <span class="keyword">if</span> (mRefs-&gt;mWeak == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">delete</span> mRefs;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for debugging purposes, clear this.</span></span><br><span class="line">    <span class="keyword">const_cast</span>&lt;weakref_impl*&amp;&gt;(mRefs) = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> &#160; &#160; &#160; &#160;但是不要忘记，在这个场景下，目标对象是前面的RefBase::decStrong函数delete掉的，这时候目标对象就会被析构，但是它的弱引用计数值尚未执行减1操作，因此，这里的mRefs-&gt;mWeak == 0条件就不成立，于是就不会delete这个weakref_impl对象，因此，就延迟到执行这里decWeak函数时再执行。</p>
<p> &#160; &#160; &#160; &#160;如果是后一种情景，这里的impl-&gt;mStrong值就等于INITIAL_STRONG_VALUE了，这时候由于没有地方会负责delete目标对象，因此，就需要把目标对象（imp-&gt;mBase）delete掉了，否则就会造成内存泄漏。在delete这个目标对象的时候，就会执行RefBase类的析构函数，这时候目标对象的弱引用计数等于0，于是，就会把weakref_impl对象也一起delete掉了。</p>
<p> &#160; &#160; &#160; &#160;2. 然后回到else逻辑中，如果目标对象的生命周期是受弱引用计数或者OBJECT_LIFETIME_FOREVER控制的：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">impl-&gt;mBase-&gt;onLastWeakRef(id);</span><br><span class="line">        <span class="keyword">if</span> ((impl-&gt;mFlags&amp;OBJECT_LIFETIME_MASK) == OBJECT_LIFETIME_WEAK) &#123;<span class="comment">//如果生命周期受弱引用主导</span></span><br><span class="line">            <span class="comment">// this is the OBJECT_LIFETIME_WEAK case. The last weak-reference</span></span><br><span class="line">            <span class="comment">// is gone, we can destroy the object.</span></span><br><span class="line">            <span class="keyword">delete</span> impl-&gt;mBase;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="comment">//如果是FOREVER，则需要手动删除</span></span><br></pre></td></tr></table></figure></p>
<p> &#160; &#160; &#160; &#160;理论上说，如果目标对象的生命周期是受弱引用计数控制的，那么当强引用计数和弱引用计数都为0的时候，这时候就应该delete目标对象了，但是这里还有另外一层控制，我们可以设置目标对象的标志值为OBJECT_LIFETIME_FOREVER，即目标对象的生命周期完全不受强引用计数和弱引用计数控制，在这种情况下，即使目标对象的强引用计数和弱引用计数都同时为0，这里也不能delete这个目标对象，那么，由谁来delete掉呢？当然是谁new出来的，就谁来delete掉了，这时候智能指针就完全退化为普通指针了，这里的智能指针设计的非常强大。</p>
<p>&#160; &#160; &#160; &#160;强指针这里就分析完了，小结一下：</p>
<ul>
<li>如果对象的标志位被设置为0，那么只要发现对象的强引用计数值为0，那就会自动delete掉这个对象；</li>
<li>如果对象的标志位被设置为OBJECT_LIFETIME_WEAK，那么只有当对象的强引用计数和弱引用计数都为0的时候，才会自动delete掉这个对象；</li>
<li>如果对象的标志位被设置为OBJECT_LIFETIME_FOREVER，那么对象就永远不会自动被delete掉，谁new出来的对象谁来delete掉。</li>
</ul>
<h2 id="弱指针"><a href="#弱指针" class="headerlink" title="弱指针"></a>弱指针</h2><p>&#160; &#160; &#160; &#160;弱指针所使用的引用计数类与强指针一样，都是RefBase类。我们直接看弱指针的实现，即wp类，位于system/core/include/utils/RefBase.h中：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">class wp</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    typedef typename RefBase::weakref_type weakref_type;</span><br><span class="line">    </span><br><span class="line">    inline wp() : m_ptr(0) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    wp(T* other);</span><br><span class="line">    wp(const wp&lt;T&gt;&amp; other);</span><br><span class="line">    wp(const sp&lt;T&gt;&amp; other);</span><br><span class="line">    template&lt;typename U&gt; wp(U* other);</span><br><span class="line">    template&lt;typename U&gt; wp(const sp&lt;U&gt;&amp; other);</span><br><span class="line">    template&lt;typename U&gt; wp(const wp&lt;U&gt;&amp; other);</span><br><span class="line"></span><br><span class="line">    ~wp();</span><br><span class="line">    </span><br><span class="line">    // Assignment</span><br><span class="line"></span><br><span class="line">    wp&amp; operator = (T* other);</span><br><span class="line">    wp&amp; operator = (const wp&lt;T&gt;&amp; other);</span><br><span class="line">    wp&amp; operator = (const sp&lt;T&gt;&amp; other);</span><br><span class="line">    </span><br><span class="line">    template&lt;typename U&gt; wp&amp; operator = (U* other);</span><br><span class="line">    template&lt;typename U&gt; wp&amp; operator = (const wp&lt;U&gt;&amp; other);</span><br><span class="line">    template&lt;typename U&gt; wp&amp; operator = (const sp&lt;U&gt;&amp; other);</span><br><span class="line">    </span><br><span class="line">    void set_object_and_refs(T* other, weakref_type* refs);</span><br><span class="line"></span><br><span class="line">    // promotion to sp</span><br><span class="line">    </span><br><span class="line">    sp&lt;T&gt; promote() const;</span><br><span class="line"></span><br><span class="line">    // Reset</span><br><span class="line">    </span><br><span class="line">    void clear();</span><br><span class="line"></span><br><span class="line">    // Accessors</span><br><span class="line">    </span><br><span class="line">    inline  weakref_type* get_refs() const &#123; return m_refs; &#125;</span><br><span class="line">    </span><br><span class="line">    inline  T* unsafe_get() const &#123; return m_ptr; &#125;</span><br><span class="line"></span><br><span class="line">    // Operators</span><br><span class="line"></span><br><span class="line">    COMPARE_WEAK(==)</span><br><span class="line">    COMPARE_WEAK(!=)</span><br><span class="line">    COMPARE_WEAK(&gt;)</span><br><span class="line">    COMPARE_WEAK(&lt;)</span><br><span class="line">    COMPARE_WEAK(&lt;=)</span><br><span class="line">    COMPARE_WEAK(&gt;=)</span><br><span class="line"></span><br><span class="line">    inline bool operator == (const wp&lt;T&gt;&amp; o) const &#123;</span><br><span class="line">        return (m_ptr == o.m_ptr) &amp;&amp; (m_refs == o.m_refs);</span><br><span class="line">    &#125;</span><br><span class="line">    template&lt;typename U&gt;</span><br><span class="line">    inline bool operator == (const wp&lt;U&gt;&amp; o) const &#123;</span><br><span class="line">        return m_ptr == o.m_ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    inline bool operator &gt; (const wp&lt;T&gt;&amp; o) const &#123;</span><br><span class="line">        return (m_ptr == o.m_ptr) ? (m_refs &gt; o.m_refs) : (m_ptr &gt; o.m_ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    template&lt;typename U&gt;</span><br><span class="line">    inline bool operator &gt; (const wp&lt;U&gt;&amp; o) const &#123;</span><br><span class="line">        return (m_ptr == o.m_ptr) ? (m_refs &gt; o.m_refs) : (m_ptr &gt; o.m_ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    inline bool operator &lt; (const wp&lt;T&gt;&amp; o) const &#123;</span><br><span class="line">        return (m_ptr == o.m_ptr) ? (m_refs &lt; o.m_refs) : (m_ptr &lt; o.m_ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    template&lt;typename U&gt;</span><br><span class="line">    inline bool operator &lt; (const wp&lt;U&gt;&amp; o) const &#123;</span><br><span class="line">        return (m_ptr == o.m_ptr) ? (m_refs &lt; o.m_refs) : (m_ptr &lt; o.m_ptr);</span><br><span class="line">    &#125;</span><br><span class="line">                         inline bool operator != (const wp&lt;T&gt;&amp; o) const &#123; return m_refs != o.m_refs; &#125;</span><br><span class="line">    template&lt;typename U&gt; inline bool operator != (const wp&lt;U&gt;&amp; o) const &#123; return !operator == (o); &#125;</span><br><span class="line">                         inline bool operator &lt;= (const wp&lt;T&gt;&amp; o) const &#123; return !operator &gt; (o); &#125;</span><br><span class="line">    template&lt;typename U&gt; inline bool operator &lt;= (const wp&lt;U&gt;&amp; o) const &#123; return !operator &gt; (o); &#125;</span><br><span class="line">                         inline bool operator &gt;= (const wp&lt;T&gt;&amp; o) const &#123; return !operator &lt; (o); &#125;</span><br><span class="line">    template&lt;typename U&gt; inline bool operator &gt;= (const wp&lt;U&gt;&amp; o) const &#123; return !operator &lt; (o); &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    template&lt;typename Y&gt; friend class sp;</span><br><span class="line">    template&lt;typename Y&gt; friend class wp;</span><br><span class="line"></span><br><span class="line">    T*              m_ptr;</span><br><span class="line">    weakref_type*   m_refs;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p> &#160; &#160; &#160; &#160;与强指针类相比，它们都有一个成员变量m_ptr指向目标对象，但是弱指针还有一个额外的成员变量m_refs，它的类型是weakref_type指针，下面我们分析弱指针的构造函数时再看看它是如果初始化的。这里我们需要关注的仍然是弱指针的构造函数和析构函数。</p>
<p> &#160; &#160; &#160; &#160;先看拷贝构造函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;  </span><br><span class="line">wp&lt;T&gt;::wp(T* other)  </span><br><span class="line">    : m_ptr(other)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">if</span> (other) m_refs = other-&gt;createWeak(<span class="keyword">this</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> &#160; &#160; &#160; &#160;这里的参数other一定是继承了RefBase类，因此，这里调用了RefBase类的createWeak函数，它定义在system/core/libutils/RefBase.cpp文件中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RefBase::weakref_type* RefBase::createWeak(<span class="keyword">const</span> <span class="keyword">void</span>* id) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    mRefs-&gt;incWeak(id);</span><br><span class="line">    <span class="keyword">return</span> mRefs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这里的成员变量mRefs的类型为weakref_impl指针，weakref_impl类的incWeak函数我们在前面已经看过了，它的作用就是增加对象的弱引用计数。函数最后返回mRefs，于是，弱指针对象的成员变量m_refs就指向目标对象的weakref_impl对象了。</p>
<p>&#160; &#160; &#160; &#160;再看看析构函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">wp&lt;T&gt;::~wp()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_ptr) m_refs-&gt;decWeak(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这里，弱指针在析构的时候，与强指针析构不一样，它直接就调用目标对象的weakref_impl对象的decWeak函数来减少弱引用计数了，当弱引用计数为0的时候，就会根据在目标对象的标志位（0、OBJECT_LIFETIME_WEAK或者OBJECT_LIFETIME_FOREVER）来决定是否要delete目标对象，前面我们已经介绍过了，这里就不再介绍了。</p>
<p>&#160; &#160; &#160; &#160;分析到这里，弱指针还没介绍完，它最重要的特性我们还没有分析到。前面我们说过，弱指针的最大特点是它不能直接操作目标对象，这是怎么样做到的呢？秘密就在于弱指针类没有重载*和-&gt;操作符号，而强指针重载了这两个操作符号。但是，如果我们要操作目标对象，应该怎么办呢，这就要把弱指针升级为强指针了：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">sp&lt;T&gt; wp&lt;T&gt;::promote() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;T&gt; result;</span><br><span class="line">    <span class="keyword">if</span> (m_ptr &amp;&amp; m_refs-&gt;attemptIncStrong(&amp;result)) &#123;</span><br><span class="line">        result.set_pointer(m_ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;升级的方式就使用成员变量m_ptr和m_refs来构造一个强指针sp，这里的m_ptr为指目标对象的一个指针，而m_refs则是指向目标对象里面的weakref_impl对象。主要就是初始化指向目标对象的成员变量m_ptr了，如果目标对象还存在，这个m_ptr就指向目标对象，如果目标对象已经不存在，m_ptr就为NULL，升级成功与否就要看refs-&gt;attemptIncStrong函数的返回结果了：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">bool</span> RefBase::weakref_type::attemptIncStrong(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span><br><span class="line">&#123;</span><br><span class="line">    incWeak(id);<span class="comment">//先增加弱引用计数</span></span><br><span class="line">    </span><br><span class="line">    weakref_impl* <span class="keyword">const</span> impl = <span class="keyword">static_cast</span>&lt;weakref_impl*&gt;(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">int32_t</span> curCount = impl-&gt;mStrong;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (curCount &gt; <span class="number">0</span> &amp;&amp; curCount != INITIAL_STRONG_VALUE) &#123;<span class="comment">//如果强引用计数大于0，且不是第一次引用，直接强引用计数加一</span></span><br><span class="line">        <span class="comment">// we're in the easy/common case of promoting a weak-reference</span></span><br><span class="line">        <span class="comment">// from an existing strong reference.</span></span><br><span class="line">        <span class="keyword">if</span> (android_atomic_cmpxchg(curCount, curCount+<span class="number">1</span>, &amp;impl-&gt;mStrong) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// the strong count has changed on us, we need to re-assert our</span></span><br><span class="line">        <span class="comment">// situation.</span></span><br><span class="line">        curCount = impl-&gt;mStrong;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (curCount &lt;= <span class="number">0</span> || curCount == INITIAL_STRONG_VALUE) &#123;<span class="comment">//强引用计数小于等于0，或者从未被强指针引用过</span></span><br><span class="line">        <span class="comment">// we're now in the harder case of either:</span></span><br><span class="line">        <span class="comment">// - there never was a strong reference on us</span></span><br><span class="line">        <span class="comment">// - or, all strong references have been released</span></span><br><span class="line">        <span class="keyword">if</span> ((impl-&gt;mFlags&amp;OBJECT_LIFETIME_WEAK) == OBJECT_LIFETIME_STRONG) &#123;<span class="comment">//如果生命周期是强引用计数导向</span></span><br><span class="line">            <span class="comment">// this object has a "normal" life-time, i.e.: it gets destroyed</span></span><br><span class="line">            <span class="comment">// when the last strong reference goes away</span></span><br><span class="line">            <span class="keyword">if</span> (curCount &lt;= <span class="number">0</span>) &#123;<span class="comment">//强引用计数为0，说明对象已被销毁，则升级失败</span></span><br><span class="line">                <span class="comment">// the last strong-reference got released, the object cannot</span></span><br><span class="line">                <span class="comment">// be revived.</span></span><br><span class="line">                decWeak(id);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// here, curCount == INITIAL_STRONG_VALUE, which means</span></span><br><span class="line">            <span class="comment">// there never was a strong-reference, so we can try to</span></span><br><span class="line">            <span class="comment">// promote this object; we need to do that atomically.</span></span><br><span class="line">            <span class="keyword">while</span> (curCount &gt; <span class="number">0</span>) &#123;<span class="comment">//从未被强指针引用过，则强引用计数+1</span></span><br><span class="line">                <span class="keyword">if</span> (android_atomic_cmpxchg(curCount, curCount + <span class="number">1</span>,</span><br><span class="line">                        &amp;impl-&gt;mStrong) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// the strong count has changed on us, we need to re-assert our</span></span><br><span class="line">                <span class="comment">// situation (e.g.: another thread has inc/decStrong'ed us)</span></span><br><span class="line">                curCount = impl-&gt;mStrong;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (curCount &lt;= <span class="number">0</span>) &#123;如果多线程操作，入另一个线程销毁了这个对象，则升级失败</span><br><span class="line">                <span class="comment">// promote() failed, some other thread destroyed us in the</span></span><br><span class="line">                <span class="comment">// meantime (i.e.: strong count reached zero).</span></span><br><span class="line">                decWeak(id);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果生命周期收弱引用计数导向，或者是BJECT_LIFETIME_FOREVER</span></span><br><span class="line">            <span class="comment">// this object has an "extended" life-time, i.e.: it can be</span></span><br><span class="line">            <span class="comment">// revived from a weak-reference only.</span></span><br><span class="line">            <span class="comment">// Ask the object's implementation if it agrees to be revived</span></span><br><span class="line">            <span class="keyword">if</span> (!impl-&gt;mBase-&gt;onIncStrongAttempted(FIRST_INC_STRONG, id)) &#123;<span class="comment">//尝试升级，默认为true</span></span><br><span class="line">                <span class="comment">// it didn't so give-up.</span></span><br><span class="line">                decWeak(id);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// grab a strong-reference, which is always safe due to the</span></span><br><span class="line">            <span class="comment">// extended life-time.</span></span><br><span class="line">            curCount = android_atomic_inc(&amp;impl-&gt;mStrong);<span class="comment">//升级后强引用计数+1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If the strong reference count has already been incremented by</span></span><br><span class="line">        <span class="comment">// someone else, the implementor of onIncStrongAttempted() is holding</span></span><br><span class="line">        <span class="comment">// an unneeded reference.  So call onLastStrongRef() here to remove it.</span></span><br><span class="line">        <span class="comment">// (No, this is not pretty.)  Note that we MUST NOT do this if we</span></span><br><span class="line">        <span class="comment">// are in fact acquiring the first reference.</span></span><br><span class="line">        <span class="keyword">if</span> (curCount &gt; <span class="number">0</span> &amp;&amp; curCount &lt; INITIAL_STRONG_VALUE) &#123;</span><br><span class="line">            impl-&gt;mBase-&gt;onLastStrongRef(id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    impl-&gt;addStrongRef(id);<span class="comment">//没什么卵用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// now we need to fix-up the count if it was INITIAL_STRONG_VALUE</span></span><br><span class="line">    <span class="comment">// this must be done safely, i.e.: handle the case where several threads</span></span><br><span class="line">    <span class="comment">// were here in attemptIncStrong().</span></span><br><span class="line">    curCount = impl-&gt;mStrong;</span><br><span class="line">    <span class="keyword">while</span> (curCount &gt;= INITIAL_STRONG_VALUE) &#123;<span class="comment">//如果此弱指针是允计提升为强指针的，并且此目标对象是第一次被强指针引用，还需要调整一下目标对象的强引用计数值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (android_atomic_cmpxchg(curCount, curCount-INITIAL_STRONG_VALUE,</span><br><span class="line">                &amp;impl-&gt;mStrong) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// the strong-count changed on us, we need to re-assert the situation,</span></span><br><span class="line">        <span class="comment">// for e.g.: it's possible the fix-up happened in another thread.</span></span><br><span class="line">        curCount = impl-&gt;mStrong;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这个函数的作用是试图增加目标对象的强引用计数，但是有可能会失败，失败的原因可能是因为目标对象已经被delete掉了，或者是其它的原因，下面会分析到。前面我们在讨论强指针的时候说到，增加目标对象的强引用计数的同时，也会增加目标对象的弱引用计数，因此，函数在开始的地方首先就是调用incWeak函数来先增加目标对象的引用计数，如果后面试图增加目标对象的强引用计数失败时，会调用decWeak函数来回滚前面的incWeak操作。</p>
<p>&#160; &#160; &#160; &#160;这里试图增加目标对象的强引用计数时，分两种情况讨论，一种情况是此时目标对象正在被其它强指针引用，即它的强引用计数大于0，并且不等于INITIAL_STRONG_VALUE，另一种情况是此时目标对象没有被任何强指针引用，即它的强引用计数小于等于0，或者等于INITIAL_STRONG_VALUE。</p>
<p>&#160; &#160; &#160; &#160; 第一种情况比较简单，因为这时候说明目标对象一定存在，因此，是可以将这个弱指针提升为强指针的，在这种情况下，只要简单地增加目标对象的强引用计数值就行了：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (curCount &gt; <span class="number">0</span> &amp;&amp; curCount != INITIAL_STRONG_VALUE) &#123;<span class="comment">//如果强引用计数大于0，且不是第一次引用，直接强引用计数加一</span></span><br><span class="line">       <span class="comment">// we're in the easy/common case of promoting a weak-reference</span></span><br><span class="line">       <span class="comment">// from an existing strong reference.</span></span><br><span class="line">       <span class="keyword">if</span> (android_atomic_cmpxchg(curCount, curCount+<span class="number">1</span>, &amp;impl-&gt;mStrong) == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// the strong count has changed on us, we need to re-assert our</span></span><br><span class="line">       <span class="comment">// situation.</span></span><br><span class="line">       curCount = impl-&gt;mStrong;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;当我们在这里对目标对象的强引用计数执行加1操作时，要保证原子性，因为其它地方也有可能正在对这个目标对象的强引用计数执行加1的操作，前面我们一般是调用android_atomic_inc函数来完成，但是这里是通过调用android_atomic_cmpxchg函数来完成，android_atomic_cmpxchg函数是体系结构相关的函数，在提供了一些特殊的指令的体系结构上，调用android_atomic_cmpxchg函数来执行加1操作的效率会比调用android_atomic_inc函数更高一些。函数android_atomic_cmpxchg是在system/core/include/cutils/atomic.h文件中定义的一个宏：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">android_atomic_release_cas</span><span class="params">(<span class="keyword">int32_t</span> oldvalue, <span class="keyword">int32_t</span> newvalue,  </span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int32_t</span>* addr)</span></span>;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> android_atomic_cmpxchg android_atomic_release_cas</span></span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;它实际执行的函数是android_atomic_release_cas，这个函数的工作原理大概是这样的：如果它发现<em>addr == oldvalue，就会执行</em>addr = newvalue的操作，然后返回0，否则什么也不做，返回1。在我们讨论的这个场景中，oldvalue等于curCount，而newvalue等于curCount + 1，于是，在<em>addr == oldvalue的条件下，就相当于是对目标对象的强引用计数值增加了1。什么情况下</em>addr != oldvalue呢？在调用android_atomic_release_cas函数之前，oldvalue和值就是从地址addr读出来的，如果在执行android_atomic_release_cas函数的时候，有其它地方也对地址addr进行操作，那么就会有可能出现*addr != oldvalue的情况，这时候就说明其它地方也在操作目标对象的强引用计数了，因此，这里就不能执行增加目标对象的强引用计数的操作了，它必须要等到其它地方操作完目标对象的强引用计数之后再重新执行，这就是为什么要通过一个while循环来执行了。</p>
<p>&#160; &#160; &#160; &#160;第二种情况比较复杂一点，因为这时候目标对象可能还存在，也可能不存了，这要根据实际情况来判断。如果此时目标对象的强引用计数值等于INITIAL_STRONG_VALUE，说明此目标对象还从未被强指针引用过，这时候弱指针能够被提升为强指针的条件就为:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (curCount &lt;= <span class="number">0</span> || curCount == INITIAL_STRONG_VALUE) &#123;<span class="comment">//强引用计数小于等于0，或者从未被强指针引用过</span></span><br><span class="line">    <span class="comment">// we're now in the harder case of either:</span></span><br><span class="line">    <span class="comment">// - there never was a strong reference on us</span></span><br><span class="line">    <span class="comment">// - or, all strong references have been released</span></span><br><span class="line">    <span class="keyword">if</span> ((impl-&gt;mFlags&amp;OBJECT_LIFETIME_WEAK) == OBJECT_LIFETIME_STRONG) &#123;<span class="comment">//如果生命周期是强引用计数导向</span></span><br><span class="line">        <span class="comment">// this object has a "normal" life-time, i.e.: it gets destroyed</span></span><br><span class="line">        <span class="comment">// when the last strong reference goes away</span></span><br><span class="line">        <span class="keyword">if</span> (curCount &lt;= <span class="number">0</span>) &#123;<span class="comment">//强引用计数为0，说明对象已被销毁，则升级失败</span></span><br><span class="line">            <span class="comment">// the last strong-reference got released, the object cannot</span></span><br><span class="line">            <span class="comment">// be revived.</span></span><br><span class="line">            decWeak(id);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// here, curCount == INITIAL_STRONG_VALUE, which means</span></span><br><span class="line">        <span class="comment">// there never was a strong-reference, so we can try to</span></span><br><span class="line">        <span class="comment">// promote this object; we need to do that atomically.</span></span><br><span class="line">        <span class="keyword">while</span> (curCount &gt; <span class="number">0</span>) &#123;<span class="comment">//从未被强指针引用过，则强引用计数+1</span></span><br><span class="line">            <span class="keyword">if</span> (android_atomic_cmpxchg(curCount, curCount + <span class="number">1</span>,</span><br><span class="line">                    &amp;impl-&gt;mStrong) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// the strong count has changed on us, we need to re-assert our</span></span><br><span class="line">            <span class="comment">// situation (e.g.: another thread has inc/decStrong'ed us)</span></span><br><span class="line">            curCount = impl-&gt;mStrong;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (curCount &lt;= <span class="number">0</span>) &#123;如果多线程操作，入另一个线程销毁了这个对象，则升级失败</span><br><span class="line">            <span class="comment">// promote() failed, some other thread destroyed us in the</span></span><br><span class="line">            <span class="comment">// meantime (i.e.: strong count reached zero).</span></span><br><span class="line">            decWeak(id);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果生命周期收弱引用计数导向，或者是BJECT_LIFETIME_FOREVER</span></span><br><span class="line">        <span class="comment">// this object has an "extended" life-time, i.e.: it can be</span></span><br><span class="line">        <span class="comment">// revived from a weak-reference only.</span></span><br><span class="line">        <span class="comment">// Ask the object's implementation if it agrees to be revived</span></span><br><span class="line">        <span class="keyword">if</span> (!impl-&gt;mBase-&gt;onIncStrongAttempted(FIRST_INC_STRONG, id)) &#123;<span class="comment">//尝试升级，默认为true</span></span><br><span class="line">            <span class="comment">// it didn't so give-up.</span></span><br><span class="line">            decWeak(id);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// grab a strong-reference, which is always safe due to the</span></span><br><span class="line">        <span class="comment">// extended life-time.</span></span><br><span class="line">        curCount = android_atomic_inc(&amp;impl-&gt;mStrong);<span class="comment">//升级后强引用计数+1</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;1) 即如果目标对象的生命周期只受到强引用计数控制或者在目标对象的具体实现中总是允许这种情况发生。怎么理解呢？如果目标对象的生命周期只受强引用计数控制（它的标志位mFlags为0），而这时目标对象又还未被强指针引用过，它自然就不会被delete掉，因此，这时候可以判断出目标对象是存在的；如果目标对象的生命周期受弱引用计数控制（OBJECT_LIFETIME_WEAK），这时候由于目标对象正在被弱指针引用，因此，弱引用计数一定不为0，目标对象一定存在；如果目标对象的生命周期不受引用计数控制（BJECT_LIFETIME_FOREVER），这时候目标对象也是下在被弱指针引用，因此，目标对象的所有者必须保证这个目标对象还没有被delete掉，否则就会出问题了。</p>
<p>&#160; &#160; &#160; &#160;在后面两种场景下，因为目标对象的生命周期都是不受强引用计数控制的，而现在又要把弱指针提升为强指针，就需要进一步调用目标对象的onIncStrongAttempted来看看是否允许这种情况发生，这又该怎么理解呢？可以这样理解，目标对象的设计者可能本身就不希望这个对象被强指针引用，只能通过弱指针来引用它，因此，这里它就可以重载其父类的onIncStrongAttempted函数，然后返回false，这样就可以阻止弱指针都被提升为强指针。在RefBase类中，其成员函数onIncStrongAttempted默认是返回true的：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> RefBase::onIncStrongAttempted(<span class="keyword">uint32_t</span> flags, <span class="keyword">const</span> <span class="keyword">void</span>* id)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">return</span> (flags&amp;FIRST_INC_STRONG) ? <span class="literal">true</span> : <span class="literal">false</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;2) 如果此时目标对象的强引用计数值小于等于0，那就说明该对象之前一定被强指针引用过，这时候就必须保证目标对象是被弱引用计数控制的（BJECT_LIFETIME_WEAK），否则的话，目标对象就已经被delete了。同样，这里也要调用一下目标对象的onIncStrongAttempted成员函数，来询问一下目标对象在强引用计数值小于等于0的时候，是否允计将弱指针提升为强指针。</p>
<p>&#160; &#160; &#160; &#160;然后将强引用计数加一，还有一些收尾处理，函数的最后，如果此弱指针是允计提升为强指针的，并且此目标对象是第一次被强指针引用，还需要调整一下目标对象的强引用计数值。</p>
<p>&#160; &#160; &#160; &#160;到这里弱指针就分析完了，它和强指针逻辑大同小异。</p>
<h1 id="使用前提"><a href="#使用前提" class="headerlink" title="使用前提"></a>使用前提</h1><p>&#160; &#160; &#160; &#160;说了这么多原理，下面该看看智能指针该如何使用了。假设现在有一个类MyClass，如果要使用智能指针来引用这个类的对象，那么这个类需满足下列两个前提条件：<br>1：这个类是基类RefBase的子类或间接子类；<br>2：这个类必须定义虚构造函数，即它的构造函数需要这样定义：<br>&#160; &#160; &#160; &#160;virtual ~MyClass();<br>&#160; &#160; &#160; &#160;满足了上述条件的类就可以定义为Android智能指针了，定义方法和普通指针类似。比如&#160; &#160; &#160; &#160;普通指针是这样定义：<br>&#160; &#160; &#160; &#160;MyClass<em> p_obj;<br>&#160; &#160; &#160; &#160;智能指针是这样定义：<br>&#160; &#160; &#160; &#160;sp<myclass> p_obj;<br>&#160; &#160; &#160; &#160;注意不要定义成sp<myclass></myclass></myclass></em> p_obj。这是初学者很容易犯的错误，这样其实相当于定义了一个指针的指针。尽管在语法上没有问题，但是最好不要这样定义。<br>&#160; &#160; &#160; &#160;定义了一个智能指针的变量，就可以象普通指针那样使用它，包括赋值、访问对象成员、作为函数的返回值、作为函数的参数等。比如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p_obj = <span class="keyword">new</span> MyClass(); <span class="comment">// 注意不要写成 p_obj = new sp&lt;MyClass&gt; </span></span><br><span class="line">sp&lt;MyClass&gt; p_obj2 = p_obj; </span><br><span class="line">p_obj-&gt;func(); </span><br><span class="line">p_obj = create_obj(); </span><br><span class="line">some_func(p_obj);</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;注意不要试图delete一个智能指针，即 delete p_obj。不要担心对象的销毁问题，智能指针的最大作用就是自动销毁不再使用的对象。不需要再使用一个对象后，直接将指针赋值为NULL即可：<br>&#160; &#160; &#160; &#160;p_obj = NULL;<br>&#160; &#160; &#160; &#160;上面说的都是强指针，弱指针的定义方法和强指针类似，但是不能通过弱指针来访问对象的成员。下面是弱指针的示例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wp&lt;MyClass&gt; wp_obj = <span class="keyword">new</span> MyClass(); </span><br><span class="line">p_obj = wp_obj.promote(); <span class="comment">// 升级为强指针。不过这里要用.而不是-&gt;，真是有负其指针之名啊 </span></span><br><span class="line">wp_obj = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure></p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>&#160; &#160; &#160; &#160;至此，智能指针部分就分析完了，我们不得不赞叹Google设计的强大。<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/meizi.jpg" alt="结语"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android消息处理零散分析]]></title>
      <url>http://windrunnerlihuan.com/2016/07/31/Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E9%9B%B6%E6%95%A3%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<hr>
<p>&#160; &#160; &#160; &#160;Android消息机制是开发人员用滥的内容，不过内部原理比较复杂，因此今天抽空从头到位彻底分析一下。<br><a id="more"></a></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&#160; &#160; &#160; &#160;我们知道，Android应用程序是通过消息来驱动的。Google参考了Windows的消息处理机制，在Android系统中实现了一套类似的消息处理机制。<br>&#160; &#160; &#160; &#160;了解过Win32开发的同学应该都知道windows是事件驱动的，事件驱动围绕着消息的产生与处理展开，事件驱动是靠消息循环机制来实现的。消息机制的三大要点：消息队列、消息循环(分发)、消息处理。其结构如下：<br> <div align="center"><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E9%9B%B6%E6%95%A3%E5%88%86%E6%9E%90/looper.jpg"></div></p>
<ul>
<li><strong>消息队列</strong>就是存放消息的一种队列，具有先进先出的特点。每产生一个消息都会添加进消息队列中，在Windows中消息队列是在操作系统中定义的。消息队列就如同一群排队打饭的同学，这群人中光景较好的排在前面，光景较差的排在后面，可以理解成是一种优先级队列！</li>
<li><strong>消息循环</strong>就是通过循环(如while)不断地从消息队列中取得队首的消息，并将消息分发出去。类似于食堂打饭的阿姨。</li>
<li><strong>消息处理</strong>就是在接收到消息之后根据不同的消息类型做出不同的处理。食堂阿姨根据学生点的不同类型的菜名给他们打不同的饭菜就是消息处理，学生手点的菜名就是消息所携带的信息</li>
<li><strong>事件</strong>是根据接收到的消息的具体信息做出的特定的处理，放在代码中是事件响应函数。上面的例子中学生拿到饭菜后吃饭就是具体的事件。</li>
</ul>
<p>&#160; &#160; &#160; &#160;Android的消息处理机制也是基于上述模型的，实现消息驱动对应模型为：</p>
<ul>
<li>Message：消息，理解为线程间通讯的数据单元。</li>
<li>MessageQueue：消息队列，用来存放通过Handler发布的消息，按照先进先出执行。</li>
<li>Looper：消息循环，扮演MessageQueue和Handler之间桥梁的角色，循环取出MessageQueue里面的Message，并交付给相应的Handler进行处理。</li>
<li>Handler：Handler是Message的主要处理者，负责将Message添加到消息队列以及对消息队列中的Message进行处理。</li>
</ul>
<h1 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h1><h2 id="初始化消息队列"><a href="#初始化消息队列" class="headerlink" title="初始化消息队列"></a>初始化消息队列</h2><p>&#160; &#160; &#160; &#160;Android应用程序进程在启动时，会在进程中加载ActivityThread类，并且执行这个类的main方法，应用程序的消息循环过程就是在这个main方法里面实现的。ActivityThread位于frameworks/base/core/java/android/app/ActivityThread.java：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		......</span><br><span class="line">        Looper.prepareMainLooper();</span><br><span class="line">        </span><br><span class="line">        ActivityThread thread = <span class="keyword">new</span> ActivityThread();</span><br><span class="line">        thread.attach(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">		......</span><br><span class="line">        Looper.loop();</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;main方法做了两件事，一是在主线程创建了一个ActivityThread实例，二是通过Looper类使主线程进入消息循环。我们只关注后者。先看Looper.prepareMainLooper方法：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;();</span><br><span class="line">    private static Looper sMainLooper;</span><br><span class="line">    final MessageQueue mQueue;//消息队列</span><br><span class="line">    final Thread mThread;//当前线程，这里是主线程</span><br><span class="line">    </span><br><span class="line">    public static void prepareMainLooper() &#123;</span><br><span class="line">        prepare(false);//调用prepare(false)方法</span><br><span class="line">        synchronized (Looper.class) &#123;</span><br><span class="line">            if (sMainLooper != null) &#123;</span><br><span class="line">                throw new IllegalStateException("The main Looper has already </span><br><span class="line">been prepared.");</span><br><span class="line">            &#125;</span><br><span class="line">            sMainLooper = myLooper();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //带参数prepare方法，参数quitAllowed表示是否可以退出消息循环</span><br><span class="line">    private static void prepare(boolean quitAllowed) &#123;</span><br><span class="line">        if (sThreadLocal.get() != null) &#123;</span><br><span class="line">            throw new RuntimeException("Only one Looper may be created per </span><br><span class="line">thread");</span><br><span class="line">        &#125;</span><br><span class="line">        sThreadLocal.set(new Looper(quitAllowed));//存入sThreadLocal</span><br><span class="line">线程局部变量</span><br><span class="line">    &#125; </span><br><span class="line">    private Looper(boolean quitAllowed) &#123;</span><br><span class="line">        mQueue = new MessageQueue(quitAllowed);//初始化一个消息队列</span><br><span class="line">        mThread = Thread.currentThread();</span><br><span class="line">    &#125;       </span><br><span class="line">    public static Looper myLooper() &#123;</span><br><span class="line">        return sThreadLocal.get();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;prepareMainLooper方法其实就是在线程中创建了一个Looper对象，这个Looper对象存放在类型为ThreadLocal的sThreadLocal线程局部变量中，保证每一个调用prepareMainLooper方法的线程只有一个独立的Looper对象。<br>&#160; &#160; &#160; &#160;Looper对象的构造方法里又创建了一个消息队列MessageQueue，后续消息Message就是存放在这个队列中。我们看看它的创建过程：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// True if the message queue can be quit.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> mQuitAllowed;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> mPtr; <span class="comment">// used by native code</span></span><br><span class="line"></span><br><span class="line">MessageQueue(<span class="keyword">boolean</span> quitAllowed) &#123;<span class="comment">//quitAllowed为false，说明main线程消息循环不允许退出</span></span><br><span class="line">    mQuitAllowed = quitAllowed;</span><br><span class="line">    mPtr = nativeInit();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">nativeInit</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;MessageQueue的初始化都交给了nativeInit这个本地方法，我们看看它的具体实现，位于frameworks/base/core/jni/android_os_MessageQueue.cpp文件中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">android_os_MessageQueue_nativeInit</span><span class="params">(JNIEnv* env, jclass clazz)</span> </span>&#123;</span><br><span class="line">    NativeMessageQueue* nativeMessageQueue = <span class="keyword">new</span> NativeMessageQueue();<span class="comment">//建立一个NativeMessageQueue消息队列对象</span></span><br><span class="line">    <span class="keyword">if</span> (!nativeMessageQueue) &#123;</span><br><span class="line">        jniThrowRuntimeException(env, <span class="string">"Unable to allocate native queue"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nativeMessageQueue-&gt;incStrong(env);<span class="comment">//强引用计数+1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(nativeMessageQueue);<span class="comment">//强转为java层long类型变量，返回给java层mPtr变量保存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;在JNI层也相应建立一个消息队列NativeMessageQueue，建立成功后会将它的强引用计数加一，Google的智能指针需要这么干；然后通过C++操作符reinterpret_cast将NativeMessageQueue类型变量强转为jlong类型，并返回到java层，方便java层操作。 NativeMessageQueue同样定义在frameworks/base/core/jni/android_os_MessageQueue.cpp中，我们看看它的构造函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NativeMessageQueue::NativeMessageQueue() : mInCallback(<span class="literal">false</span>), mExceptionObj(<span class="literal">NULL</span>) &#123;</span><br><span class="line">    mLooper = Looper::getForThread();</span><br><span class="line">    <span class="keyword">if</span> (mLooper == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mLooper = <span class="keyword">new</span> Looper(<span class="literal">false</span>);<span class="comment">//创建一个JNI层的Looper对象</span></span><br><span class="line">        Looper::setForThread(mLooper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;它主要就是在内部创建了一个Looper对象，注意，这个Looper对象是实现在JNI层的，它与上面Java层中的Looper是不一样的，不过它们是对应的，下面我们进一步分析消息循环的过程的时候，就会清楚地了解到它们之间的关系。我们接着看JNI层Looper的构造函数实现，位于system/core/libutils/Looper.cpp中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Looper::Looper(<span class="keyword">bool</span> allowNonCallbacks) :</span><br><span class="line">        mAllowNonCallbacks(allowNonCallbacks), mSendingMessage(<span class="literal">false</span>),</span><br><span class="line">        mResponseIndex(<span class="number">0</span>), mNextMessageUptime(LLONG_MAX) &#123;</span><br><span class="line">    <span class="keyword">int</span> wakeFds[<span class="number">2</span>];<span class="comment">//准备两个文件描述符</span></span><br><span class="line">    <span class="keyword">int</span> result = pipe(wakeFds);<span class="comment">//创建一个管道</span></span><br><span class="line">    LOG_ALWAYS_FATAL_IF(result != <span class="number">0</span>, <span class="string">"Could not create wake pipe.  errno=%d"</span>, errno);</span><br><span class="line"></span><br><span class="line">    mWakeReadPipeFd = wakeFds[<span class="number">0</span>];<span class="comment">//管道读端</span></span><br><span class="line">    mWakeWritePipeFd = wakeFds[<span class="number">1</span>];<span class="comment">//管道写端</span></span><br><span class="line"></span><br><span class="line">    result = fcntl(mWakeReadPipeFd, F_SETFL, O_NONBLOCK);<span class="comment">//将管道读端设为非阻塞模式</span></span><br><span class="line">    LOG_ALWAYS_FATAL_IF(result != <span class="number">0</span>, <span class="string">"Could not make wake read pipe non-blocking.  errno=%d"</span>,</span><br><span class="line">            errno);</span><br><span class="line"></span><br><span class="line">    result = fcntl(mWakeWritePipeFd, F_SETFL, O_NONBLOCK);<span class="comment">//管道写端同样设为非阻塞</span></span><br><span class="line">    LOG_ALWAYS_FATAL_IF(result != <span class="number">0</span>, <span class="string">"Could not make wake write pipe non-blocking.  errno=%d"</span>,</span><br><span class="line">            errno);</span><br><span class="line"></span><br><span class="line">    mIdling = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate the epoll instance and register the wake pipe.</span></span><br><span class="line">    mEpollFd = epoll_create(EPOLL_SIZE_HINT);<span class="comment">//创建一个epoll专用的文件描述符</span></span><br><span class="line">    LOG_ALWAYS_FATAL_IF(mEpollFd &lt; <span class="number">0</span>, <span class="string">"Could not create epoll instance.  errno=%d"</span>, errno);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//epoll其中一个专用结构体</span></span><br><span class="line">    <span class="keyword">struct</span> epoll_event eventItem;</span><br><span class="line">    <span class="comment">//把结构体清零</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp; eventItem, <span class="number">0</span>, <span class="keyword">sizeof</span>(epoll_event)); <span class="comment">// zero out unused members of data field union</span></span><br><span class="line">    <span class="comment">//重新赋值</span></span><br><span class="line">    eventItem.events = EPOLLIN;<span class="comment">//EPOLLIN ：表示对应的文件描述符可以读；</span></span><br><span class="line">    eventItem.data.fd = mWakeReadPipeFd;<span class="comment">//fd：关联的文件描述符；</span></span><br><span class="line">    <span class="comment">//epoll_ctl函数用于控制某个epoll文件描述符上的事件，可以注册事件，修改事件，删除事件。这里是添加事件 </span></span><br><span class="line">    result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeReadPipeFd, &amp; eventItem);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(result != <span class="number">0</span>, <span class="string">"Could not add wake read pipe to epoll instance.  errno=%d"</span>,</span><br><span class="line">            errno);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这个构造函数做的事情非常重要，它跟我们后面要介绍的应用程序主线程在消息队列中没有消息时要进入等待状态以及当消息队列有消息时要把应用程序主线程唤醒的这两个知识点息息相关。<br>&#160; &#160; &#160; &#160;它主要做了两件事：<br>&#160; &#160; &#160; &#160;（1）通过pipe系统调用来创建了一个管道了：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> wakeFds[<span class="number">2</span>];  </span><br><span class="line"><span class="keyword">int</span> result = pipe(wakeFds);  </span><br><span class="line">......  </span><br><span class="line">  </span><br><span class="line">mWakeReadPipeFd = wakeFds[<span class="number">0</span>];  </span><br><span class="line">mWakeWritePipeFd = wakeFds[<span class="number">1</span>];</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;管道是Linux系统中的一种进程间通信机制。<strong>简单来说，管道就是一个文件，在管道的两端，分别是两个打开文件文件描述符，这两个打开文件描述符都是对应同一个文件，其中一个是用来读的，另一个是用来写的。一般的使用方式就是，一个线程通过读文件描述符中来读管道的内容，当管道没有内容时，这个线程就会进入等待状态；而另外一个线程通过写文件描述符来向管道中写入内容，写入内容的时候，如果另一端正有线程正在等待管道中的内容，那么这个线程就会被唤醒。</strong>这个等待和唤醒的操作是如何进行的呢，这就要借助Linux系统中的epoll机制了。<br>&#160; &#160; &#160; &#160;Linux系统中的epoll机制为处理大批量句柄而作了改进的poll，是Linux下多路复用I/O接口select/poll的增强版本，它能显著减少程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率。但是这里我们其实只需要监控的I/O接口只有mWakeReadPipeFd一个，即前面我们所创建的管道的读端，为什么还需要用到epoll呢？有点用牛刀来杀鸡的味道。其实不然，这个Looper类是非常强大的，它除了监控内部所创建的管道接口之外，还提供了addFd接口供外界面调用，外界可以通过这个接口把自己想要监控的I/O事件一并加入到这个Looper对象中去，当所有这些被监控的I/O接口上面有事件发生时，就会唤醒相应的线程来处理，不过这里我们只关心刚才所创建的管道的I/O事件的发生。</p>
<p>&#160; &#160; &#160; &#160;（2）epoll机制相关初始化：<br>&#160; &#160; &#160; &#160;要使用Linux系统的epoll机制，首先要通过epoll_create来创建一个epoll专用的文件描述符：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mEpollFd = epoll_create(EPOLL_SIZE_HINT);</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;epoll_create(int size)函数生成一个epoll专用的文件描述符。它其实是在内核申请一空间，用来存放你想关注的fd上是否发生以及发生了什么事件。size就是你在这个epoll fd上能关注的最大fd数。我们这里传入的二是EPOLL_SIZE_HINT。</p>
<p>&#160; &#160; &#160; &#160;接着还要通过epoll_ctl函数来告诉epoll要监控相应的文件描述符的什么事件：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//epoll其中一个专用结构体</span></span><br><span class="line">   <span class="keyword">struct</span> epoll_event eventItem;</span><br><span class="line">   <span class="comment">//把结构体清零</span></span><br><span class="line">   <span class="built_in">memset</span>(&amp; eventItem, <span class="number">0</span>, <span class="keyword">sizeof</span>(epoll_event)); <span class="comment">// zero out unused members of data field union</span></span><br><span class="line">   <span class="comment">//重新赋值</span></span><br><span class="line">   eventItem.events = EPOLLIN;<span class="comment">//EPOLLIN ：表示对应的文件描述符可以读；</span></span><br><span class="line">   eventItem.data.fd = mWakeReadPipeFd;<span class="comment">//fd：关联的文件描述符；</span></span><br><span class="line">   <span class="comment">//epoll_ctl函数用于控制某个epoll文件描述符上的事件，可以注册事件，修改事件，删除事件。这里是添加事件 </span></span><br><span class="line">   result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeReadPipeFd, &amp; eventItem);</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;epoll_ctl函数如下：<br>函数声明：int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)<br>该函数用于控制某个epoll文件描述符上的事件，可以注册事件，修改事件，删除事件。<br>参数：<br>epfd：由 epoll_create 生成的epoll专用的文件描述符；<br>op：要进行的操作例如注册事件，可能的取值EPOLL_CTL_ADD 注册、EPOLL_CTL_MOD 修 改、EPOLL_CTL_DEL 删除<br>fd：关联的文件描述符；<br>event：指向epoll_event结构体的指针；<br>返回值：<br>如果调用成功返回0,不成功返回-1 </p>
<p>&#160; &#160; &#160; &#160;用到的结构体如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> epoll_event &#123;   </span><br><span class="line"><span class="keyword">__uint32_t</span> events; <span class="comment">/* Epoll events */</span>   <span class="comment">//事件类型</span></span><br><span class="line"><span class="keyword">epoll_data_t</span> data; <span class="comment">/* User data variable */</span>   </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> epoll_data &#123;   </span><br><span class="line"><span class="keyword">void</span> *ptr;   </span><br><span class="line"><span class="keyword">int</span> fd;   <span class="comment">//关联的文件描述符</span></span><br><span class="line"><span class="keyword">__uint32_t</span> u32;   </span><br><span class="line"><span class="keyword">__uint64_t</span> u64;   </span><br><span class="line">&#125; <span class="keyword">epoll_data_t</span>;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;epoll_event 结构体常用的事件类型:<br>EPOLLIN ：表示对应的文件描述符可以读；<br>EPOLLOUT：表示对应的文件描述符可以写；<br>EPOLLPRI：表示对应的文件描述符有紧急的数据可读<br>EPOLLERR：表示对应的文件描述符发生错误；<br>EPOLLHUP：表示对应的文件描述符被挂断；<br>EPOLLET：表示对应的文件描述符有事件发生；</p>
<p>&#160; &#160; &#160; &#160;这里就是告诉mEpollFd，它要监控mWakeReadPipeFd文件描述符的EPOLLIN事件，即当管道中有内容可读时，就唤醒当前正在等待管道中的内容的线程。<br>&#160; &#160; &#160; &#160;C++层的这个Looper对象创建好了之后，就返回到JNI层的NativeMessageQueue的构造函数，最后就返回到Java层的消息队列MessageQueue的创建过程，这样，Java层的Looper对象就准备好了。</p>
<p>&#160; &#160; &#160; &#160;对上面内容小结一下就是：<br>&#160; &#160; &#160; &#160;①在Java层，创建了一个Looper对象，这个Looper对象是用来进入消息循环的，它的内部有一个消息队列MessageQueue对象mQueue；<br>&#160; &#160; &#160; &#160;②在JNI层，创建了一个NativeMessageQueue对象，这个NativeMessageQueue对象保存在Java层的消息队列对象mQueue的成员变量mPtr中；<br>&#160; &#160; &#160; &#160;③在C++层，创建了一个Looper对象，保存在JNI层的NativeMessageQueue对象的成员变量mLooper中，这个对象的作用是，当Java层的消息队列中没有消息时，就使Android应用程序主线程进入等待状态，而当Java层的消息队列中来了新的消息后，就唤醒Android应用程序的主线程来处理这个消息。</p>
<h2 id="消息循环"><a href="#消息循环" class="headerlink" title="消息循环"></a>消息循环</h2><p>&#160; &#160; &#160; &#160;继续回到上面ActivitThread的main方法里，在上面这些工作都准备好之后就调用Looper.loop方法进入到消息循环中了。<br>&#160; &#160; &#160; &#160;消息循环就会取出消息进行处理，在看消息处理之前，先看一下消息是怎么被添加到消息队列的。</p>
<h3 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h3><p>&#160; &#160; &#160; &#160;在Java层，Message类表示一个消息对象，要发送消息首先就要先获得一个消息对象，Message类的构造函数是public的，但是不建议直接new Message，Message内部保存了一个缓存的消息池，我们可以用obtain从缓存池获得一个消息，Message使用完后系统会调用recycle回收，如果自己new很多Message，每次使用完后系统放入缓存池，会占用很多内存的。我们看看Message类相关方法和变量：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Message sPool;</span><br><span class="line"><span class="comment">// sometimes we store linked lists of these things</span></span><br><span class="line"><span class="comment">/*package*/</span> Message next;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_POOL_SIZE = <span class="number">50</span>;</span><br><span class="line">     </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">         <span class="keyword">if</span> (sPool != <span class="keyword">null</span>) &#123;</span><br><span class="line">             Message m = sPool;<span class="comment">//取出表头</span></span><br><span class="line">             sPool = m.next;</span><br><span class="line">             m.next = <span class="keyword">null</span>;</span><br><span class="line">             m.flags = <span class="number">0</span>; <span class="comment">// clear in-use flag</span></span><br><span class="line">             sPoolSize--;</span><br><span class="line">             <span class="keyword">return</span> m;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> Message();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (isInUse()) &#123;</span><br><span class="line">         <span class="keyword">if</span> (gCheckRecycle) &#123;</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"This message cannot be recycled because it "</span></span><br><span class="line">                     + <span class="string">"is still in use."</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     recycleUnchecked();</span><br><span class="line"> &#125;    </span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">recycleUnchecked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">// Mark the message as in use while it remains in the recycled object pool.</span></span><br><span class="line">     <span class="comment">// Clear out all other details.</span></span><br><span class="line">     flags = FLAG_IN_USE;</span><br><span class="line">     what = <span class="number">0</span>;</span><br><span class="line">     arg1 = <span class="number">0</span>;</span><br><span class="line">     arg2 = <span class="number">0</span>;</span><br><span class="line">     obj = <span class="keyword">null</span>;</span><br><span class="line">     replyTo = <span class="keyword">null</span>;</span><br><span class="line">     sendingUid = -<span class="number">1</span>;</span><br><span class="line">     when = <span class="number">0</span>;</span><br><span class="line">     target = <span class="keyword">null</span>;</span><br><span class="line">     callback = <span class="keyword">null</span>;</span><br><span class="line">     data = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">         <span class="keyword">if</span> (sPoolSize &lt; MAX_POOL_SIZE) &#123;</span><br><span class="line">             next = sPool;</span><br><span class="line">             sPool = <span class="keyword">this</span>;</span><br><span class="line">             sPoolSize++;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;Message内部通过next成员实现了一个链表，这样sPool就了为了一个Messages的缓存链表。</p>
<p>&#160; &#160; &#160; &#160;消息对象获取到了怎么发送呢，大家都知道是通过Handler的post、sendMessage等方法，其实这些方法最终都是调用的同一个方法sendMessageAtTime:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">    MessageQueue queue = mQueue;</span><br><span class="line">    <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        RuntimeException e = <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="keyword">this</span> + <span class="string">" sendMessageAtTime() called with no mQueue"</span>);</span><br><span class="line">        Log.w(<span class="string">"Looper"</span>, e.getMessage(), e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;sendMessageAtTime获取到消息队列然后调用enqueueMessage方法，消息队列mQueue是从与Handler关联的Looper获得的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">    msg.target = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">        msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;enqueueMessage将message的target设置为当前的handler，然后调用MessageQueue的enqueueMessage，在调用queue.enqueueMessage之前判断了mAsynchronous，从名字看是异步消息的意思，要明白Asynchronous的作用，需要先了解一个概念Barrier。</p>
<h3 id="Barrier与Asynchronous-Message"><a href="#Barrier与Asynchronous-Message" class="headerlink" title="Barrier与Asynchronous Message"></a>Barrier与Asynchronous Message</h3><p>&#160; &#160; &#160; &#160;Barrier是什么意思呢，从名字看是一个拦截器，在这个拦截器后面的消息都暂时无法执行，直到这个拦截器被移除了，MessageQueue有一个函数叫enqueueSyncBarier可以添加一个Barrier。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//消息队列的队头，消息队列按时间从小到大排序，这是最小的</span></span><br><span class="line">Message mMessages;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">enqueueSyncBarrier</span><span class="params">(<span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// Enqueue a new sync barrier token.</span></span><br><span class="line">       <span class="comment">// We don't need to wake the queue because the purpose of a barrier is to stall it.</span></span><br><span class="line">       <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">int</span> token = mNextBarrierToken++;<span class="comment">//一个用来返回的自增int值作为token</span></span><br><span class="line">           <span class="keyword">final</span> Message msg = Message.obtain();<span class="comment">//创建一个路障</span></span><br><span class="line">           msg.markInUse();<span class="comment">//标记为正在使用</span></span><br><span class="line">           msg.when = when;<span class="comment">//路障的时间</span></span><br><span class="line">           msg.arg1 = token;<span class="comment">//打个token</span></span><br><span class="line"></span><br><span class="line">           Message prev = <span class="keyword">null</span>;</span><br><span class="line">           Message p = mMessages;<span class="comment">//访问消息队列队头</span></span><br><span class="line">           <span class="keyword">if</span> (when != <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; p.when &lt;= when) &#123;<span class="comment">//遍历一遍消息队列，按时间找到路障位置</span></span><br><span class="line">                   prev = p;</span><br><span class="line">                   p = p.next;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123; <span class="comment">// invariant: p == prev.next //在时间所在队列位置插入路障</span></span><br><span class="line">               msg.next = p;</span><br><span class="line">               prev.next = msg;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;<span class="comment">//路障时间小于队头时间，或者消息队列为空，将路障设为队头</span></span><br><span class="line">               msg.next = p;</span><br><span class="line">               mMessages = msg;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> token;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;在enqueueSyncBarrier中，obtain了一个Message，并设置msg.arg1=token，token仅是一个每次调用enqueueSyncBarrier时自增的int值，目的是每次调用enqueueSyncBarrier时返回唯一的一个token，这个Message同样需要设置执行时间，然后插入到消息队列，<strong>特殊的是这个Message没有设置target，即msg.target为null。</strong><br>&#160; &#160; &#160; &#160;如果队列头部的消息的target为null就表示它是个Barrier，因为只有两种方法往mMessages中添加消息，一种是enqueueMessage，另一种是enqueueBarrier，而enqueueMessage中如果mst.target为null是直接抛异常的，后面会看到。</p>
<p>&#160; &#160; &#160; &#160;所谓的异步消息其实就是这样的，我们可以通过enqueueBarrier往消息队列中插入一个Barrier，那么队列中执行时间在这个Barrier以后的同步消息都会被这个Barrier拦截住无法执行，直到我们调用removeBarrier移除了这个Barrier，而异步消息则没有影响，消息默认就是同步消息，除非我们调用了Message的setAsynchronous，这个方法是隐藏的。只有在初始化Handler时通过参数指定往这个Handler发送的消息都是异步的，这样在Handler的enqueueMessage中就会调用Message的setAsynchronous设置消息是异步的，从上面Handler.enqueueMessage的代码中可以看到。<br>&#160; &#160; &#160; &#160;所谓异步消息，其实只有一个作用，就是在设置Barrier时仍可以不受Barrier的影响被正常处理，如果没有设置Barrier，异步消息就与同步消息没有区别，可以通过removeSyncBarrier移除Barrier：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeSyncBarrier</span><span class="params">(<span class="keyword">int</span> token)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Remove a sync barrier token from the queue.</span></span><br><span class="line">    <span class="comment">// If the queue is no longer stalled by a barrier then wake it.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        Message prev = <span class="keyword">null</span>;</span><br><span class="line">        Message p = mMessages;<span class="comment">//取出队头</span></span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; (p.target != <span class="keyword">null</span> || p.arg1 != token)) &#123;<span class="comment">//循环遍历消息队列，找出路障</span></span><br><span class="line">            prev = p;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;<span class="comment">//参数token就是enqueueSyncBarrier的返回值，如果没有调用指定的token是会抛异常的</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The specified message queue synchronization "</span></span><br><span class="line">                    + <span class="string">" barrier token has not been posted or has already been removed."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> needWake;</span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;<span class="comment">//找到路障，移除路障</span></span><br><span class="line">            prev.next = p.next;</span><br><span class="line">            needWake = <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mMessages = p.next;</span><br><span class="line">            needWake = mMessages == <span class="keyword">null</span> || mMessages.target != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p.recycleUnchecked();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If the loop is quitting then it is already awake.</span></span><br><span class="line">        <span class="comment">// We can assume mPtr != 0 when mQuitting is false.</span></span><br><span class="line">        <span class="keyword">if</span> (needWake &amp;&amp; !mQuitting) &#123;</span><br><span class="line">            nativeWake(mPtr);<span class="comment">//唤醒操作下面再讲</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="enqueueMessage"><a href="#enqueueMessage" class="headerlink" title="enqueueMessage"></a>enqueueMessage</h3><p>&#160; &#160; &#160; &#160;接着我们顺着上面内容，看一下是MessageQueue的enqueueMessage的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;<span class="comment">//注意这里，当msg.target为null时是直接抛异常的，上面提到过</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Message must have a target."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (msg.isInUse()) &#123;<span class="comment">//正在使用时不能重复加入队列</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg + <span class="string">" This message is already in use."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mQuitting) &#123;<span class="comment">//如果已经退出消息循环，则会异常返回</span></span><br><span class="line">            IllegalStateException e = <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                    msg.target + <span class="string">" sending message to a Handler on a dead thread"</span>);</span><br><span class="line">            Log.w(<span class="string">"MessageQueue"</span>, e.getMessage(), e);</span><br><span class="line">            msg.recycle();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        msg.markInUse();<span class="comment">//给消息打上正在使用标签</span></span><br><span class="line">        msg.when = when;</span><br><span class="line">        Message p = mMessages;<span class="comment">//取出队头</span></span><br><span class="line">        <span class="keyword">boolean</span> needWake;</span><br><span class="line">        <span class="comment">//如果当前的消息队列为空，或者新添加的消息的执行时间when是0，</span></span><br><span class="line">        <span class="comment">//或者新添加的消息的执行时间比消息队列头的消息的执行时间还早，</span></span><br><span class="line">        <span class="comment">//就把消息添加到消息队列头（消息队列按时间排序）</span></span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">            <span class="comment">// New head, wake up the event queue if blocked.</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">            needWake = mBlocked;<span class="comment">//当前消息队列为空时，这时候应用程序的主线程一般就是处于空闲等待状态了，这时候就要唤醒它</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//否则就要找到合适的位置将当前消息添加到消息队列</span></span><br><span class="line">            <span class="comment">// Inserted within the middle of the queue.  Usually we don't have to wake</span></span><br><span class="line">            <span class="comment">// up the event queue unless there is a barrier at the head of the queue</span></span><br><span class="line">            <span class="comment">// and the message is the earliest asynchronous message in the queue.</span></span><br><span class="line">            <span class="comment">//通常我们不用唤醒队列，除非有路障在队头并且插入的消息是更早的异步消息</span></span><br><span class="line">            needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">            Message prev;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;<span class="comment">//循环遍历队列，找到应该插入的位置</span></span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">                <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;<span class="comment">// 消息队列中有异步消息并且执行时间在新消息之前，所以不需要唤醒</span></span><br><span class="line">                    needWake = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            msg.next = p; <span class="comment">// invariant: p == prev.next 将目标消息插入队列位置</span></span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></span><br><span class="line">        <span class="keyword">if</span> (needWake) &#123;<span class="comment">//唤醒下面再讲</span></span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;注意方法内第一行，当msg.target为null时是直接抛异常的。</p>
<p>&#160; &#160; &#160; &#160;在enqueueMessage中首先判断，如果当前的消息队列为空，这时候应用程序的主线程一般就是处于空闲等待状态了，这时候就要唤醒它（唤醒我们下面再讲）。或者新添加的消息的执行时间when是0，或者新添加的消息的执行时间比消息队列头的消息的执行时间还早，就把消息添加到消息队列头（消息队列按时间排序），否则就要找到合适的位置将当前消息添加到消息队列。</p>
<h3 id="消息循环-1"><a href="#消息循环-1" class="headerlink" title="消息循环"></a>消息循环</h3><p>&#160; &#160; &#160; &#160;消息队列初始化好了，也知道怎么发消息了，下面就是怎么处理消息了，看Looper.loop函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> Looper me = myLooper();</span><br><span class="line">      <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">final</span> MessageQueue queue = me.mQueue;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">          Message msg = queue.next(); <span class="comment">// might block</span></span><br><span class="line">          <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">	......</span><br><span class="line"></span><br><span class="line">          msg.target.dispatchMessage(msg);</span><br><span class="line"></span><br><span class="line">	......</span><br><span class="line"></span><br><span class="line">          msg.recycleUnchecked();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这里就是进入到消息循环中去了，它不断地从消息队列mQueue中去获取下一个要处理的消息msg，如果消息的target成员变量为null，就表示要退出消息循环了，否则的话就要调用这个target对象的dispatchMessage成员函数来处理这个消息，这个target对象的类型为Handler，下面我们分析消息的发送时会看到这个消息对象msg是如设置的。<br>&#160; &#160; &#160; &#160;这个函数最关键的地方便是从消息队列中获取下一个要处理的消息了，即MessageQueue.next函数，我们看看它的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">// Return here if the message loop has already quit and been disposed.</span></span><br><span class="line">     <span class="comment">// This can happen if the application tries to restart a looper after quit</span></span><br><span class="line">     <span class="comment">// which is not supported.</span></span><br><span class="line">     <span class="keyword">final</span> <span class="keyword">long</span> ptr = mPtr;</span><br><span class="line">     <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">int</span> pendingIdleHandlerCount = -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span></span><br><span class="line">     <span class="keyword">int</span> nextPollTimeoutMillis = <span class="number">0</span>;<span class="comment">//当前消息队列中没有消息，它要等待的时间</span></span><br><span class="line">     <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">......</span><br><span class="line"><span class="comment">//本地方法，一次消息轮训</span></span><br><span class="line">         nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">         <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">             <span class="comment">// Try to retrieve the next message.  Return if found.</span></span><br><span class="line">             <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">             Message prevMsg = <span class="keyword">null</span>;</span><br><span class="line">             Message msg = mMessages;<span class="comment">//取出队头消息</span></span><br><span class="line">             <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;<span class="comment">//如果队头消息是路障，就往后找到第一个异步消息</span></span><br><span class="line">                 <span class="comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></span><br><span class="line">                 do &#123;</span><br><span class="line">                     prevMsg = msg;</span><br><span class="line">                     msg = msg.next;</span><br><span class="line">                 &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());<span class="comment">//循环查找第一个异步消息</span></span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;<span class="comment">//取出消息不为空</span></span><br><span class="line">                 <span class="keyword">if</span> (now &lt; msg.when) &#123;<span class="comment">//如果时间还未到，就要等待</span></span><br><span class="line">                     <span class="comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></span><br><span class="line">                     nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                 &#125; <span class="keyword">else</span> &#123;<span class="comment">//取出这个消息，并从消息队列移除</span></span><br><span class="line">                     <span class="comment">// Got a message.</span></span><br><span class="line">                     mBlocked = <span class="keyword">false</span>;</span><br><span class="line">                     <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                         prevMsg.next = msg.next;</span><br><span class="line">                     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                         mMessages = msg.next;</span><br><span class="line">                     &#125;</span><br><span class="line">                     msg.next = <span class="keyword">null</span>;</span><br><span class="line">                     <span class="keyword">if</span> (<span class="keyword">false</span>) Log.v(<span class="string">"MessageQueue"</span>, <span class="string">"Returning message: "</span> + msg);</span><br><span class="line">                     </span><br><span class="line">                     <span class="comment">//返回取出的消息</span></span><br><span class="line">                     <span class="keyword">return</span> msg;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果消息队列中没有消息，那就要进入无穷等待状态直到有新消息了</span></span><br><span class="line">                 <span class="comment">// No more messages.</span></span><br><span class="line">                 nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             <span class="comment">// Process the quit message now that all pending messages have been handled.</span></span><br><span class="line">             <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">                 dispose();</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             <span class="comment">// If first time idle, then get the number of idlers to run.</span></span><br><span class="line">             <span class="comment">// Idle handles only run if the queue is empty or if the first message</span></span><br><span class="line">             <span class="comment">// in the queue (possibly a barrier) is due to be handled in the future.</span></span><br><span class="line">             <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span></span><br><span class="line">                     &amp;&amp; (mMessages == <span class="keyword">null</span> || now &lt; mMessages.when)) &#123;</span><br><span class="line">                 pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                 <span class="comment">// No idle handlers to run.  Loop and wait some more.</span></span><br><span class="line">                 mBlocked = <span class="keyword">true</span>;</span><br><span class="line">                 <span class="keyword">continue</span>;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span> (mPendingIdleHandlers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                 mPendingIdleHandlers = <span class="keyword">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</span><br><span class="line">             &#125;</span><br><span class="line">             mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Run the idle handlers.</span></span><br><span class="line">         <span class="comment">// We only ever reach this code block during the first iteration.</span></span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">             <span class="keyword">final</span> IdleHandler idler = mPendingIdleHandlers[i];</span><br><span class="line">             mPendingIdleHandlers[i] = <span class="keyword">null</span>; <span class="comment">// release the reference to the handler</span></span><br><span class="line"></span><br><span class="line">             <span class="keyword">boolean</span> keep = <span class="keyword">false</span>;</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 keep = idler.queueIdle();</span><br><span class="line">             &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                 Log.wtf(<span class="string">"MessageQueue"</span>, <span class="string">"IdleHandler threw exception"</span>, t);</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">                 <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                     mIdleHandlers.remove(idler);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Reset the idle handler count to 0 so we do not run them again.</span></span><br><span class="line">         pendingIdleHandlerCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// While calling an idle handler, a new message could have been delivered</span></span><br><span class="line">         <span class="comment">// so go back and look again for a pending message without waiting.</span></span><br><span class="line">         nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;调用这个函数的时候，有可能会让线程进入等待状态。什么情况下，线程会进入等待状态呢？两种情况，一是当消息队列中没有消息时，它会使线程进入等待状态；二是消息队列中有消息，但是消息指定了执行的时间，而现在还没有到这个时间，线程也会进入等待状态。消息队列中的消息是按时间先后来排序的，上面我们分析过了。</p>
<p>&#160; &#160; &#160; &#160;执行下面语句是看看当前消息队列中有没有消息：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nativePollOnce(mPtr, nextPollTimeoutMillis);</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这是一个JNI方法，我们等一下再分析，这里传入的参数mPtr就是指向前面我们在JNI层创建的NativeMessageQueue对象了，而参数nextPollTimeoutMillis则表示如果当前消息队列中没有消息，它要等待的时候，for循环开始时，传入的值为0，表示不等待。<br>&#160; &#160; &#160; &#160;当前nativePollOnce返回后，就去看看消息队列中有没有消息：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Message prevMsg = <span class="keyword">null</span>;</span><br><span class="line">Message msg = mMessages;<span class="comment">//取出队头消息</span></span><br><span class="line"><span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;<span class="comment">//如果队头消息是路障，就往后找到第一个异步消息</span></span><br><span class="line">    <span class="comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></span><br><span class="line">    do &#123;</span><br><span class="line">        prevMsg = msg;</span><br><span class="line">        msg = msg.next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());<span class="comment">//循环查找第一个异步消息</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;<span class="comment">//取出消息不为空</span></span><br><span class="line">    <span class="keyword">if</span> (now &lt; msg.when) &#123;<span class="comment">//如果时间还未到，就要等待</span></span><br><span class="line">        <span class="comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></span><br><span class="line">        nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//取出这个消息，并从消息队列移除</span></span><br><span class="line">        <span class="comment">// Got a message.</span></span><br><span class="line">        mBlocked = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) &#123;</span><br><span class="line">            prevMsg.next = msg.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mMessages = msg.next;</span><br><span class="line">        &#125;</span><br><span class="line">        msg.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">false</span>) Log.v(<span class="string">"MessageQueue"</span>, <span class="string">"Returning message: "</span> + msg);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//返回取出的消息</span></span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;<span class="comment">//如果消息队列中没有消息，那就要进入无穷等待状态直到有新消息了</span></span><br><span class="line">    <span class="comment">// No more messages.</span></span><br><span class="line">    nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;取消息队列头部的消息，如果头部消息是Barrier（target==null）就往后遍历找到第一个异步消息；</p>
<blockquote>
<p>&#160; &#160; &#160; &#160;提前说明：nextPollTimeoutMillis 的值的意义是，-1表示下次调用nativePollOnce时，如果消息中没有消息，就进入无限等待状态中去。<br>&#160; &#160; &#160; &#160;这里计算出来的等待时间都是在下次调用nativePollOnce时使用的。</p>
</blockquote>
<p>&#160; &#160; &#160; &#160;接下来检测获取到的消息（消息队列头部的消息或者第一个异步消息），如果为null表示没有消息要执行，设置nextPollTimeoutMillis = -1，就要无限等待下去；<br>&#160; &#160; &#160; &#160;否则检测这个消息要执行的时间，如果到执行时间了就将这个消息markInUse并从消息队列移除，然后从next返回到loop；<br>&#160; &#160; &#160; &#160;否则设置nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE)，即距离最近要执行的消息还需要多久。</p>
<p>&#160; &#160; &#160; &#160;这里说的等待，是空闲等待，而不是忙等待，因此，在进入空闲等待状态前，如果应用程序注册了IdleHandler接口来处理一些事情，那么就会先执行这里IdleHandler，然后再进入等待状态。IdlerHandler是定义在MessageQueue的一个内部类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Callback interface for discovering when a thread is going to block</span><br><span class="line"> * waiting for more messages.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">interface</span> <span class="title">IdleHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Called when the message queue has run out of messages and will now</span><br><span class="line">     * wait for more.  Return true to keep your idle handler active, false</span><br><span class="line">     * to have it removed.  This may be called if there are still messages</span><br><span class="line">     * pending in the queue, but they are all scheduled to be dispatched</span><br><span class="line">     * after the current time.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">queueIdle</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;它只有一个成员函数queueIdle，执行这个函数时，如果返回值为false，那么就会从应用程序中移除这个IdleHandler，否则的话就会在应用程序中继续维护着这个IdleHandler，下次空闲时仍会再执会这个IdleHandler。MessageQueue提供了addIdleHandler和removeIdleHandler两注册和删除IdleHandler。</p>
<p>&#160; &#160; &#160; &#160;回到MessageQueue的next方法中，它接下来就是在进入等待状态前，看看有没有IdleHandler是需要执行的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If first time idle, then get the number of idlers to run.</span></span><br><span class="line">            <span class="comment">// Idle handles only run if the queue is empty or if the first message</span></span><br><span class="line">            <span class="comment">// in the queue (possibly a barrier) is due to be handled in the future.</span></span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span></span><br><span class="line">                    &amp;&amp; (mMessages == <span class="keyword">null</span> || now &lt; mMessages.when)) &#123;</span><br><span class="line">                pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// No idle handlers to run.  Loop and wait some more.</span></span><br><span class="line">                mBlocked = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mPendingIdleHandlers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mPendingIdleHandlers = <span class="keyword">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</span><br><span class="line">            &#125;</span><br><span class="line">            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;如果没有，即pendingIdleHandlerCount等于0，那下面的逻辑就不执行了，通过continue语句直接进入下一次循环，否则就要把注册在mIdleHandlers中的IdleHandler取出来，放在mPendingIdleHandlers数组中去。</p>
<p>&#160; &#160; &#160; &#160;接下来就是执行这些注册了的IdleHanlder了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Run the idle handlers.</span></span><br><span class="line">         <span class="comment">// We only ever reach this code block during the first iteration.</span></span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">             <span class="keyword">final</span> IdleHandler idler = mPendingIdleHandlers[i];</span><br><span class="line">             mPendingIdleHandlers[i] = <span class="keyword">null</span>; <span class="comment">// release the reference to the handler</span></span><br><span class="line"></span><br><span class="line">             <span class="keyword">boolean</span> keep = <span class="keyword">false</span>;</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 keep = idler.queueIdle();</span><br><span class="line">             &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                 Log.wtf(<span class="string">"MessageQueue"</span>, <span class="string">"IdleHandler threw exception"</span>, t);</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">                 <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                     mIdleHandlers.remove(idler);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;执行完这些IdleHandler之后，线程下次调用nativePollOnce函数时，就不设置超时时间了，因为，很有可能在执行IdleHandler的时候，已经有新的消息加入到消息队列中去了，因此，要重置nextPollTimeoutMillis的值：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// While calling an idle handler, a new message could have been delivered  </span></span><br><span class="line"><span class="comment">// so go back and look again for a pending message without waiting.  </span></span><br><span class="line">nextPollTimeoutMillis = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;到这里MessageQueue的next方法的java部分就分析完了，我们重点看一下native方法nativePollOnce，看看它是如何进入等待状态的。这个函数定义在frameworks/base/core/jni/android_os_MessageQueue.cpp文件中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_os_MessageQueue_nativePollOnce</span><span class="params">(JNIEnv* env, jclass clazz,</span><br><span class="line">        jlong ptr, jint timeoutMillis)</span> </span>&#123;</span><br><span class="line">    NativeMessageQueue* nativeMessageQueue = <span class="keyword">reinterpret_cast</span>&lt;NativeMessageQueue*&gt;(ptr);</span><br><span class="line">    nativeMessageQueue-&gt;pollOnce(env, timeoutMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这个函数首先是通过传进入的参数ptr取回前面在Java层创建MessageQueue对象时在JNI层创建的NatvieMessageQueue对象，然后调用它的pollOnce函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> NativeMessageQueue::pollOnce(JNIEnv* env, <span class="keyword">int</span> timeoutMillis) &#123;</span><br><span class="line">    ......</span><br><span class="line">    mLooper-&gt;pollOnce(timeoutMillis);</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这里将操作转发给mLooper对象的pollOnce函数处理，这里的mLooper对象是在C++层的对象，它也是在前面在JNI层创建的NatvieMessageQueue对象时创建的，它的pollOnce函数定义在system/core/libutils/Looper.cpp中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> Looper::pollOnce(<span class="keyword">int</span> timeoutMillis, <span class="keyword">int</span>* outFd, <span class="keyword">int</span>* outEvents, <span class="keyword">void</span>** outData) &#123;  </span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;  </span><br><span class="line">        ......  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (result != <span class="number">0</span>) &#123;  </span><br><span class="line">            ......  </span><br><span class="line">  </span><br><span class="line">            <span class="keyword">return</span> result;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        result = pollInner(timeoutMillis);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;省略一些障眼法，它主要就是调用pollInner函数来进一步操作，如果pollInner返回值不等于0，这个函数就可以返回了。函数pollInner的定义如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> Looper::pollInner(<span class="keyword">int</span> timeoutMillis) &#123;  </span><br><span class="line">    ......  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">int</span> result = ALOOPER_POLL_WAKE;  </span><br><span class="line">  </span><br><span class="line">    ......  </span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOOPER_USES_EPOLL  </span></span><br><span class="line">    <span class="keyword">struct</span> epoll_event eventItems[EPOLL_MAX_EVENTS];  </span><br><span class="line">    <span class="keyword">int</span> eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis);  </span><br><span class="line">    <span class="keyword">bool</span> acquiredLock = <span class="literal">false</span>;  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>  </span></span><br><span class="line">    ......  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  </span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (eventCount &lt; <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (errno == EINTR) &#123;  </span><br><span class="line">            <span class="keyword">goto</span> Done;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        LOGW(<span class="string">"Poll failed with an unexpected error, errno=%d"</span>, errno);  </span><br><span class="line">        result = ALOOPER_POLL_ERROR;  </span><br><span class="line">        <span class="keyword">goto</span> Done;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (eventCount == <span class="number">0</span>) &#123;  </span><br><span class="line">        ......  </span><br><span class="line">        result = ALOOPER_POLL_TIMEOUT;  </span><br><span class="line">        <span class="keyword">goto</span> Done;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    ......  </span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOOPER_USES_EPOLL  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; eventCount; i++) &#123;  </span><br><span class="line">        <span class="keyword">int</span> fd = eventItems[i].data.fd;  </span><br><span class="line">        <span class="keyword">uint32_t</span> epollEvents = eventItems[i].events;  </span><br><span class="line">        <span class="keyword">if</span> (fd == mWakeReadPipeFd) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (epollEvents &amp; EPOLLIN) &#123;  </span><br><span class="line">                awoken();  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                LOGW(<span class="string">"Ignoring unexpected epoll events 0x%x on wake read pipe."</span>, epollEvents);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            ......  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (acquiredLock) &#123;  </span><br><span class="line">        mLock.unlock();  </span><br><span class="line">    &#125;  </span><br><span class="line">Done: ;  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>  </span></span><br><span class="line">    ......  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  </span></span><br><span class="line">  </span><br><span class="line">    ......  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> result;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;省略一些障眼法，这里，首先是调用epoll_wait函数来看看epoll专用文件描述符mEpollFd所监控的文件描述符是否有IO事件发生，它设置监控的超时时间为timeoutMillis：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis);</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;epoll_wait函数 如下：<br>函数声明:int epoll_wait(int epfd,struct epoll_event * events,int maxevents,int timeout)<br>该函数用于轮询I/O事件的发生；<br>参数：<br>epfd:由epoll_create 生成的epoll专用的文件描述符；<br>epoll_event:用于回传代处理事件的数组；<br>maxevents:每次能处理的事件数；<br>timeout:等待I/O事件发生的超时值；-1相当于阻塞，0相当于非阻塞。一般用-1即可<br>返回值：<br>返回发生事件数。 </p>
<p>&#160; &#160; &#160; &#160;epoll_wait运行的原理是 ：<br>等侍注册在epfd上的fd的事件的发生，如果发生则将发生的fd和事件类型放入到events数组中。<br>并 且将注册在epfd上的fd的事件类型给清空，所以如果下一个循环你还要关注这个fd的话，则需要用epoll_ctl(epfd,EPOLL_CTL_MOD,listenfd,&amp;ev)来重新设置fd的事件类型。这时不用EPOLL_CTL_ADD,因为fd并未清空，只是事件类型清空。</p>
<p>&#160; &#160; &#160; &#160;回忆一下前面的Looper的构造函数，我们在里面设置了要监控mWakeReadPipeFd文件描述符的EPOLLIN事件。<br>&#160; &#160; &#160; &#160;当mEpollFd所监控的文件描述符发生了要监控的I/O事件后或者监控时间超时后，线程就从epoll_wait返回了，否则线程就会在epoll_wait函数中进入睡眠状态了。返回后如果eventCount等于0，就说明是超时了：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (eventCount == <span class="number">0</span>) &#123;  </span><br><span class="line">    ......  </span><br><span class="line">    result = ALOOPER_POLL_TIMEOUT;  </span><br><span class="line">    <span class="keyword">goto</span> Done;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160; 如果eventCount不等于0，就说明发生要监控的事件：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; eventCount; i++) &#123;  </span><br><span class="line">    <span class="keyword">int</span> fd = eventItems[i].data.fd;  </span><br><span class="line">    <span class="keyword">uint32_t</span> epollEvents = eventItems[i].events;  </span><br><span class="line">    <span class="keyword">if</span> (fd == mWakeReadPipeFd) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (epollEvents &amp; EPOLLIN) &#123;  </span><br><span class="line">            awoken();  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            LOGW(<span class="string">"Ignoring unexpected epoll events 0x%x on wake read pipe."</span>, epollEvents);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            ......  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这里我们只关注mWakeReadPipeFd文件描述符上的事件，如果在mWakeReadPipeFd文件描述符上发生了EPOLLIN就说明应用程序中的消息队列里面有新的消息需要处理了，接下来它就会先调用awoken函数清空管道中的内容，以便下次再调用pollInner函数时，知道自从上次处理完消息队列中的消息后，有没有新的消息加进来。<br>&#160; &#160; &#160; &#160;函数awoken的实现很简单，它只是把管道中的内容都读取出来：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Looper::awoken() &#123;  </span><br><span class="line">    ......  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">16</span>];  </span><br><span class="line">    <span class="keyword">ssize_t</span> nRead;  </span><br><span class="line">    <span class="keyword">do</span> &#123;  </span><br><span class="line">        nRead = read(mWakeReadPipeFd, buffer, <span class="keyword">sizeof</span>(buffer));  </span><br><span class="line">    &#125; <span class="keyword">while</span> ((nRead == <span class="number">-1</span> &amp;&amp; errno == EINTR) || nRead == <span class="keyword">sizeof</span>(buffer));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;因为当其它的线程向应用程序的消息队列加入新的消息时，会向这个管道写入新的内容来通知应用程序主线程有新的消息需要处理了，从而唤醒它，下面我们分析一下。</p>
<h3 id="唤醒时机"><a href="#唤醒时机" class="headerlink" title="唤醒时机"></a>唤醒时机</h3><p>&#160; &#160; &#160; &#160;上面讲发送消息时讲过，把消息加入到消息队列时，分两种情况，一种当前消息队列为空时，这时候应用程序的主线程一般就是处于空闲等待状态了，这时候就要唤醒它，另一种情况是应用程序的消息队列不为空，这时候就不需要唤醒应用程序的主线程了，因为这时候它一定是在忙着处于消息队列中的消息，因此不会处于空闲等待的状态。<br>&#160; &#160; &#160; &#160;把消息加入到消息队列去后，如果应用程序的主线程正处于空闲等待状态，就需要调用natvieWake函数来唤醒它了，这是一个JNI方法，定义在frameworks/base/core/jni/android_os_MessageQueue.cpp文件中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_os_MessageQueue_nativeWake</span><span class="params">(JNIEnv* env, jclass clazz, jlong ptr)</span> </span>&#123;</span><br><span class="line">    NativeMessageQueue* nativeMessageQueue = <span class="keyword">reinterpret_cast</span>&lt;NativeMessageQueue*&gt;(ptr);</span><br><span class="line">    <span class="keyword">return</span> nativeMessageQueue-&gt;wake();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这个JNI层的NativeMessageQueue对象我们在前面分析消息循环的时候创建好的，保存在Java层的MessageQueue对象的mPtr成员变量中，这里把它取回来之后，就调用它的wake函数来唤醒应用程序的主线程，这个函数也是定义在frameworks/base/core/jni/android_os_MessageQueue.cpp文件中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> NativeMessageQueue::wake() &#123;</span><br><span class="line">    mLooper-&gt;wake();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这里它又通过成员变量mLooper的wake函数来执行操作，这里的mLooper成员变量是一个C++层实现的Looper对象，它定义在system/core/libutils/Looper.cpp文件中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Looper::wake() &#123;  </span><br><span class="line">    ......  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">ssize_t</span> nWrite;  </span><br><span class="line">    <span class="keyword">do</span> &#123;  </span><br><span class="line">        nWrite = write(mWakeWritePipeFd, <span class="string">"W"</span>, <span class="number">1</span>);  </span><br><span class="line">    &#125; <span class="keyword">while</span> (nWrite == <span class="number">-1</span> &amp;&amp; errno == EINTR);  </span><br><span class="line">  </span><br><span class="line">    .......  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这个wake函数很简单，只是通过打开文件描述符mWakeWritePipeFd往管道的写入一个”W”字符串。其实，往管道写入什么内容并不重要，往管道写入内容的目的是为了唤醒应用程序的主线程。前面我们在分析应用程序的消息循环时说到，当应用程序的消息队列中没有消息处理时，应用程序的主线程就会进入空闲等待状态，而这个空闲等待状态就是通过调用这个Looper类的pollInner函数来进入的，具体就是在pollInner函数中调用epoll_wait函数来等待管道中有内容可读的。<br>&#160; &#160; &#160; &#160;这时候既然管道中有内容可读了，应用程序的主线程就会从这里的Looper类的pollInner函数返回到JNI层的nativePollOnce函数，最后返回到Java层中的MessageQueue.next函数中去，这里它就会发现消息队列中有新的消息需要处理了，于就会处理这个消息。</p>
<p>&#160; &#160; &#160; &#160;剩下就是对消息的处理了，这个就更随意了。回到Looper.loop方法中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Looper</span> </span>&#123;  </span><br><span class="line">    ......  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        Looper me = myLooper();  </span><br><span class="line">        MessageQueue queue = me.mQueue;  </span><br><span class="line">  </span><br><span class="line">        ......  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;  </span><br><span class="line">            Message msg = queue.next(); <span class="comment">// might block  </span></span><br><span class="line">            ......  </span><br><span class="line">  </span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;  </span><br><span class="line">                    <span class="comment">// No target is a magic identifier for the quit message.  </span></span><br><span class="line">                    <span class="keyword">return</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">  </span><br><span class="line">                ......  </span><br><span class="line">  </span><br><span class="line">                msg.target.dispatchMessage(msg);  <span class="comment">//处理消息</span></span><br><span class="line">                  </span><br><span class="line">                ......  </span><br><span class="line">  </span><br><span class="line">                msg.recycle();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    ......  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;它从消息队列中获得消息对象msg后，就会调用它的target成员变量的dispatchMessage函数来处理这个消息。在前面分析消息的发送时说过，这个消息对象msg的成员变量target是在发送消息的时候设置好的，一般就通过哪个Handler来发送消息，就通过哪个Handler来处理消息。<br>&#160; &#160; &#160; &#160;我们这里的Handler是ActivityThread的成员变量mH，是一个类型为H的Handler。 H类没有实现自己的dispatchMessage函数，但是它继承了父类Handler的dispatchMessage函数，我们看看Handler的dispatchMessage方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这里的消息对象msg的callback成员变量和Handler类的mCallBack成员变量一般都为null，于是，就会调用Handler类的handleMessage函数来处理这个消息，由于H类在继承Handler类时，重写了handleMessage函数，因此，这里调用的实际上是H类的handleMessage函数。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&#160; &#160; &#160; &#160;至此，我们就分析完Android应用程序的消息处理机制了，简单做一个总结：</p>
<ul>
<li><p>Android应用程序的主线程在进入消息循环过程前，会在内部创建一个Linux管道（Pipe），这个管道的作用是使得Android应用程序主线程在消息队列为空时可以进入空闲等待状态，并且使得当应用程序的消息队列有消息需要处理时唤醒应用程序的主线程。</p>
</li>
<li><p>Android应用程序的主线程进入空闲等待状态的方式实际上就是在管道的读端等待管道中有新的内容可读，具体来说就是是通过Linux系统的Epoll机制中的epoll_wait函数进行的。</p>
</li>
<li><p>当往Android应用程序的消息队列中加入新的消息时，会同时往管道中的写端写入内容，通过这种方式就可以唤醒正在等待消息到来的应用程序主线程。</p>
</li>
<li><p>当应用程序主线程在进入空闲等待前，会认为当前线程处理空闲状态，于是就会调用那些已经注册了的IdleHandler接口，使得应用程序有机会在空闲的时候处理一些事情。</p>
</li>
</ul>
<p>&#160; &#160; &#160; &#160;上述分析的是系统启动过程中的消息机制，如果我们想看一下一个线程想实现消息循环应该怎么做，可以看看HandlerThread的实现，和上面内容大同小异，有兴趣的同学可以自己研究研究。</p>
<p>&#160; &#160; &#160; &#160;结尾处贴个妹纸吧，这是今年ChinaJoy会场一个show girl，前同事拍的（我设备太渣了，所以在馆内只参加了活动，玩了些游戏=  。=）。<br> <div align="center"><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E9%9B%B6%E6%95%A3%E5%88%86%E6%9E%90/meizi2.jpg"></div><br> <div align="center"><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E9%9B%B6%E6%95%A3%E5%88%86%E6%9E%90/meizi1.jpg"></div></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[浅析Bitmap占据内存大小]]></title>
      <url>http://windrunnerlihuan.com/2016/07/12/%E6%B5%85%E6%9E%90Bitmap%E5%8D%A0%E6%8D%AE%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F/</url>
      <content type="html"><![CDATA[<hr>
<p>&#160; &#160; &#160; &#160; Bitmap的使用是开发时绕不过的坑，使用时要处处留意内存问题，稍有不慎就会报OOM（out of memory）。所以这次我们就研究研究程序中Bitmap到底占据多少内存。<br><a id="more"></a></p>
<h1 id="前奏"><a href="#前奏" class="headerlink" title="前奏"></a>前奏</h1><p>&#160; &#160; &#160; &#160; 比如我们使用一张图片，将其放入到工程目录中，想当然的会以为为这张图片建立的bitmap使用内存大小为：宽×高×像素大小。为了验证这个猜想，我在度娘上随便找了幅图：</p>
<p><div align="center"><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E6%B5%85%E6%9E%90Bitmap%E5%8D%A0%E6%8D%AE%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F/picture.jpg" title="素材"></div><br>&#160; &#160; &#160; &#160; 规格是768×1152，大小为153.3KB，格式为支持ARGB四阶的32位色的JPG图片。<br>&#160; &#160; &#160; &#160; 我们猜想，如果按照内存大小计算公式，所占内存应为：<strong>768×1152×4=3538944</strong>，字节。因为JPG格式是有损压缩格式，所以存储大小比内存大小小多了。<br>&#160; &#160; &#160; &#160; 然后将这张图片放到<strong>res/drawable-xhdpi</strong>下，通过如下代码计算内存大小：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> density = <span class="keyword">this</span>.getResources().getDisplayMetrics().density;</span><br><span class="line"><span class="keyword">int</span> dpi = <span class="keyword">this</span>.getResources().getDisplayMetrics().densityDpi;</span><br><span class="line">Log.e(TAG, <span class="string">"density = "</span> + density + <span class="string">"------"</span> + <span class="string">"dpi = "</span> + dpi);</span><br><span class="line"></span><br><span class="line">Bitmap b = BitmapFactory.decodeResource(getResources(), R.drawable.picture);</span><br><span class="line"><span class="keyword">int</span> w = b.getWidth();</span><br><span class="line"><span class="keyword">int</span> h = b.getHeight();</span><br><span class="line"><span class="keyword">int</span> size = b.getByteCount();</span><br><span class="line"><span class="keyword">int</span> config = b.getConfig().ordinal();</span><br><span class="line"></span><br><span class="line">Log.e(TAG, <span class="string">"w = "</span> + w + <span class="string">";"</span> + <span class="string">"h = "</span> + h + <span class="string">";"</span> + <span class="string">"size = "</span> + size + <span class="string">";"</span> + <span class="string">"config = "</span> + config);</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;测试机器规格为：<strong>Google Nexus 5 - 5.1.0 - API 22 - 1080×1920(480dpi)</strong>。<br>&#160; &#160; &#160; &#160;打印log如下：</p>
<blockquote>
<p>density = 3.0——dpi = 480<br>w = 1152;h = 1728;size = 7962624;config = 3</p>
</blockquote>
<p><div align="center"><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E6%B5%85%E6%9E%90Bitmap%E5%8D%A0%E6%8D%AE%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F/excuse.jpg" title="excuse me"></div><br>&#160; &#160; &#160; &#160;Why？How did you do it？这个不按套路出牌啊，宽高明显被拉伸了啊。。。。。。然后我又试了下将这张图片放到了<strong>res/drawable-xxhdpi</strong>下，打印log如下：</p>
<blockquote>
<p>density = 3.0——dpi = 480<br>w = 768;h = 1152;size = 3538944;config = 3</p>
</blockquote>
<p>&#160; &#160; &#160; &#160;这次倒是和理论计算的大小一样了，我们大概猜到了什么。。。。。接着我又把这张图片放到了<strong>assets</strong>目录下，然后修改了一下获取图片的代码，打印log如下：</p>
<blockquote>
<p>density = 3.0——dpi = 480<br>w = 768;h = 1152;size = 3538944;config = 3</p>
</blockquote>
<p>&#160; &#160; &#160; &#160;这次也是和理论值一样的，因为放到assets目录下的图片是不会被压缩的。</p>
<p>&#160; &#160; &#160; &#160;如果多试几次，把图片放入不同目录下再运行几遍，我们也能够总结出规律的。但这些都是现象，我们组的老大也曾经说过：开发人员不要轻易根据现象得出结论…….所以我们也要分析一下本质原因。</p>
<h1 id="求证"><a href="#求证" class="headerlink" title="求证"></a>求证</h1><p>&#160; &#160; &#160; &#160;做适配的同学要经常和density、densityDpi搞好关系，简单来说，可以理解为 density 的数值是 1dp=density px；densityDpi 是屏幕每英寸对应多少个点（不是像素点），在 DisplayMetrics 当中，这两个的关系是线性的：</p>
<table>
<thead>
<tr>
<th style="text-align:left">density</th>
<th style="text-align:right">0.75</th>
<th style="text-align:center">1</th>
<th style="text-align:center">1.5</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">3.5</th>
<th style="text-align:center">4</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">densityDpi</td>
<td style="text-align:right">120</td>
<td style="text-align:center">160</td>
<td style="text-align:center">240</td>
<td style="text-align:center">320</td>
<td style="text-align:center">480</td>
<td style="text-align:center">560</td>
<td style="text-align:center">640</td>
</tr>
<tr>
<td style="text-align:left">DpiFolder</td>
<td style="text-align:right">ldpi</td>
<td style="text-align:center">mdpi</td>
<td style="text-align:center">hdpi</td>
<td style="text-align:center">xhdpi</td>
<td style="text-align:center">xxhdpi</td>
<td style="text-align:center">xxxhdpi</td>
<td style="text-align:center">xxxxhdpi</td>
</tr>
</tbody>
</table>
<p>&#160; &#160; &#160; &#160;这些内容每个人应该都知道，先放到这里，方便后面查表。</p>
<h2 id="非压缩计算"><a href="#非压缩计算" class="headerlink" title="非压缩计算"></a>非压缩计算</h2><p>&#160; &#160; &#160; &#160;如果图片不被压缩，按照常规计算内存大小方法为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Bitmap的getByteCount方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getByteCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// int result permits bitmaps up to 46,340 x 46,340</span></span><br><span class="line">       <span class="keyword">return</span> getRowBytes() * getHeight();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//Bitmap的getRowBytes方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getRowBytes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> nativeRowBytes(mNativeBitmap);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">nativeRowBytes</span><span class="params">(<span class="keyword">long</span> nativeBitmap)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;getHeight 就是图片的高度（单位：px），getRowBytes 从字面意思看应该是行字节大小。我们往下看，找找JNI实现，查看 frameworks/base/core/jni/android/graphics/Bitmap.cpp文件：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jint <span class="title">Bitmap_rowBytes</span><span class="params">(JNIEnv* env, jobject, jlong bitmapHandle)</span> </span>&#123;</span><br><span class="line">    SkBitmap* bitmap = <span class="keyword">reinterpret_cast</span>&lt;SkBitmap*&gt;(bitmapHandle);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;jint&gt;(bitmap-&gt;rowBytes());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;（reinterpret_cast和static_cast是C++经常用到的用来处理无关类型之间转换的强制类型转换符，建议有时间可以研究研究，或者把C++回顾一下，毕竟挺重要的。这里先给个<a href="http://www.cnblogs.com/jerry19880126/archive/2012/08/14/2638192.html" target="_blank" rel="external">科普文章</a>）<br>&#160; &#160; &#160; &#160;上一篇关于的弹幕文章提到过，java层的Bitmap对应native层是由skia图形引擎创建的SkBitmap，关于<a href="https://skia.org/" target="_blank" rel="external">skia</a>这玩意儿东西比较多，不是专业的一时半会儿也玩不转。所以我们还是简单看看，继续往下找SkBitmap：(/external/skia/include/core/SkBitmap.h)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Return the number of bytes between subsequent rows of the bitmap. */</span></span><br><span class="line"><span class="keyword">size_t</span> rowBytes() <span class="keyword">const</span> &#123; <span class="keyword">return</span> fRowBytes; &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;得到上述fRowBytes的大小会在SkBitmap.cpp文件里计算：（/external/skia/src/core/SkBitmap.cpp）<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算fRowBytes大小</span></span><br><span class="line"><span class="keyword">size_t</span> SkBitmap::ComputeRowBytes(Config c, <span class="keyword">int</span> width) &#123;</span><br><span class="line">    <span class="keyword">return</span> SkColorTypeMinRowBytes(SkBitmapConfigToColorType(c), width);<span class="comment">//SkColorTypeMinRowBytes是/SkImageInfo.h的方法；SkBitmapConfigToColorType是SkImagePriv.cpp的方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//SkImageInfo.h的SkColorTypeMinRowBytes方法</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> size_t <span class="title">SkColorTypeMinRowBytes</span><span class="params">(SkColorType ct, <span class="keyword">int</span> width)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> width * SkColorTypeBytesPerPixel(ct);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//SkImageInfo.h的SkColorTypeBytesPerPixel方法</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">SkColorTypeBytesPerPixel</span><span class="params">(SkColorType ct)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">uint8_t</span> gSize[] = &#123;</span><br><span class="line">        <span class="number">0</span>,  <span class="comment">// Unknown</span></span><br><span class="line">        <span class="number">1</span>,  <span class="comment">// Alpha_8</span></span><br><span class="line">        <span class="number">2</span>,  <span class="comment">// RGB_565</span></span><br><span class="line">        <span class="number">2</span>,  <span class="comment">// ARGB_4444</span></span><br><span class="line">        <span class="number">4</span>,  <span class="comment">// RGBA_8888</span></span><br><span class="line">        <span class="number">4</span>,  <span class="comment">// BGRA_8888</span></span><br><span class="line">        <span class="number">1</span>,  <span class="comment">// kIndex_8</span></span><br><span class="line">    &#125;;</span><br><span class="line">	...省略障眼法的宏...</span><br><span class="line">    <span class="keyword">return</span> gSize[ct];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//SkBitmapConfigToColorType是SkImagePriv.cpp的方法</span></span><br><span class="line"><span class="function">SkColorType <span class="title">SkBitmapConfigToColorType</span><span class="params">(SkBitmap::Config config)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> SkColorType gCT[] = &#123;</span><br><span class="line">        kUnknown_SkColorType,   <span class="comment">// kNo_Config</span></span><br><span class="line">        kAlpha_8_SkColorType,   <span class="comment">// kA8_Config</span></span><br><span class="line">        kIndex_8_SkColorType,   <span class="comment">// kIndex8_Config</span></span><br><span class="line">        kRGB_565_SkColorType,   <span class="comment">// kRGB_565_Config</span></span><br><span class="line">        kARGB_4444_SkColorType, <span class="comment">// kARGB_4444_Config</span></span><br><span class="line">        kN32_SkColorType,   <span class="comment">// kARGB_8888_Config</span></span><br><span class="line">    &#125;;</span><br><span class="line">    SkASSERT((<span class="keyword">unsigned</span>)config &lt; SK_ARRAY_COUNT(gCT));</span><br><span class="line">    <span class="keyword">return</span> gCT[config];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;跟踪到这里，还记得我们上面大log的地方么。int config = b.getConfig().ordinal()返回的是3，那么在Bitmap.Config里面索引第4个枚举变量：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Config &#123;</span><br><span class="line">    ALPHA_8     (<span class="number">1</span>),</span><br><span class="line">    RGB_565     (<span class="number">3</span>),</span><br><span class="line">    ARGB_4444   (<span class="number">4</span>),</span><br><span class="line">    ARGB_8888   (<span class="number">5</span>);<span class="comment">//索引第四个是这个</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> nativeInt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从这个列表可以看出它与skia支持的图片格式一一对应，但是Android只支持上面4种</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Config sConfigs[] = &#123;</span><br><span class="line">        <span class="keyword">null</span>, ALPHA_8, <span class="keyword">null</span>, RGB_565, ARGB_4444, ARGB_8888</span><br><span class="line">    &#125;;       </span><br><span class="line">    Config(<span class="keyword">int</span> ni) &#123;</span><br><span class="line">        <span class="keyword">this</span>.nativeInt = ni;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Config <span class="title">nativeToConfig</span><span class="params">(<span class="keyword">int</span> ni)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sConfigs[ni];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;依照上面C++文件，我们发现 ARGB_8888（也就是我们最常用的 Bitmap 的格式）的一个像素占用 4byte，那么 rowBytes 实际上就是 4*width bytes。则理论上 ARGB_8888 的 Bitmap 占用内存的计算公式为：</p>
<p><strong>bitmapInRam = bitmapWidth × bitmapHeight × 4 bytes</strong></p>
<h2 id="压缩计算"><a href="#压缩计算" class="headerlink" title="压缩计算"></a>压缩计算</h2><p>&#160; &#160; &#160; &#160;如果我们不将图片放到assets目录下，内存大小计算方式就和上面完全不同了。我们读取的是 drawable 目录下面的图片，用的是 decodeResource 方法,该方法本质上就两步：</p>
<ul>
<li>读取原始资源，这个调用了 <strong>Resource.openRawResource</strong> 方法，这个方法调用完成之后会对 TypedValue 进行赋值，其中包含了原始资源的 density 等信息；</li>
<li>调用 <strong>decodeResourceStream</strong> 对原始资源进行解码和适配。这个过程实际上就是原始资源的 density 到屏幕 density 的一个映射。<br>&#160; &#160; &#160; &#160;原始资源的 density 其实取决于资源存放的目录（比如 xxhdpi 对应的是480），而屏幕 density 的赋值，请看下面这段代码：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bitmap <span class="title">decodeResource</span><span class="params">(Resources res, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> decodeResource(res, id, <span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bitmap <span class="title">decodeResource</span><span class="params">(Resources res, <span class="keyword">int</span> id, Options opts)</span> </span>&#123;</span><br><span class="line">      Bitmap bm = <span class="keyword">null</span>;</span><br><span class="line">      InputStream is = <span class="keyword">null</span>; </span><br><span class="line">      </span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">final</span> TypedValue value = <span class="keyword">new</span> TypedValue();</span><br><span class="line">          is = res.openRawResource(id, value);<span class="comment">//对 TypedValue 进行赋值，其中包含了原始资源的 density 等信息</span></span><br><span class="line"></span><br><span class="line">          bm = decodeResourceStream(res, value, is, <span class="keyword">null</span>, opts);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      ......</span><br><span class="line">      &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">      ......</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> bm;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bitmap <span class="title">decodeResourceStream</span><span class="params">(Resources res, TypedValue value,</span><br><span class="line">          InputStream is, Rect pad, Options opts)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (opts == <span class="keyword">null</span>) &#123;<span class="comment">//opt为null</span></span><br><span class="line">          opts = <span class="keyword">new</span> Options();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (opts.inDensity == <span class="number">0</span> &amp;&amp; value != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">final</span> <span class="keyword">int</span> density = value.density;</span><br><span class="line">          <span class="keyword">if</span> (density == TypedValue.DENSITY_DEFAULT) &#123;</span><br><span class="line">              opts.inDensity = DisplayMetrics.DENSITY_DEFAULT;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (density != TypedValue.DENSITY_NONE) &#123;</span><br><span class="line">              opts.inDensity = density;<span class="comment">//这里density的值如果对应资源目录为xhdpi的话，就是320</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (opts.inTargetDensity == <span class="number">0</span> &amp;&amp; res != <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="comment">//请注意，inTargetDensity就是当前的显示密度，比如Google Nexus 5就是480</span></span><br><span class="line">          opts.inTargetDensity = res.getDisplayMetrics().densityDpi;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">return</span> decodeStream(is, pad, opts);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bitmap <span class="title">decodeStream</span><span class="params">(InputStream is, Rect outPadding, Options opts)</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line">      bm = decodeStreamInternal(is, outPadding, opts);</span><br><span class="line">......</span><br><span class="line">      <span class="keyword">return</span> bm;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Bitmap <span class="title">decodeStreamInternal</span><span class="params">(InputStream is, Rect outPadding, Options opts)</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line">      <span class="keyword">return</span> nativeDecodeStream(is, tempStorage, outPadding, opts);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> Bitmap <span class="title">nativeDecodeStream</span><span class="params">(InputStream is, <span class="keyword">byte</span>[] storage,</span><br><span class="line">          Rect padding, Options opts)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>&#160; &#160; &#160; &#160;我们看到 opts 这个值被初始化，而它的构造居然如此简单：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Options</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    inDither = <span class="keyword">false</span>;</span><br><span class="line">    inScaled = <span class="keyword">true</span>;</span><br><span class="line">    inPremultiplied = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;所以我们就很容易的看到，Option.inScreenDensity 这个值没有被初始化，而实际上后面我们也会看到这个值根本不会用到；我们最应该关心的是什么呢？是 inDensity 和 inTargetDensity，这两个值与下面 cpp 文件里面的 density 和 targetDensity 相对应——重复一下，inDensity 就是原始资源的 density，inTargetDensity 就是屏幕的 density。<br>&#160; &#160; &#160; &#160;紧接着，用到了 nativeDecodeStream 方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jobject <span class="title">nativeDecodeStream</span><span class="params">(JNIEnv* env, jobject clazz, jobject is, jbyteArray storage,</span><br><span class="line">        jobject padding, jobject options)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    jobject bitmap = NULL;</span><br><span class="line">		......</span><br><span class="line">        bitmap = doDecode(env, bufferedStream, padding, options);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> bitmap;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> jobject <span class="title">doDecode</span><span class="params">(JNIEnv* env, SkStreamRewindable* stream, jobject padding, jobject options)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">......</span><br><span class="line">    <span class="keyword">if</span> (env-&gt;GetBooleanField(options, gOptions_scaledFieldID)) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> density = env-&gt;GetIntField(options, gOptions_densityFieldID);<span class="comment">//对应xhdpi的时候，是320</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> targetDensity = env-&gt;GetIntField(options, gOptions_targetDensityFieldID);<span class="comment">//Google Nexus 5为480</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> screenDensity = env-&gt;GetIntField(options, gOptions_screenDensityFieldID);</span><br><span class="line">        <span class="keyword">if</span> (density != <span class="number">0</span> &amp;&amp; targetDensity != <span class="number">0</span> &amp;&amp; density != screenDensity) &#123;</span><br><span class="line">            scale = (<span class="keyword">float</span>) targetDensity / density;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> bool willScale = scale != <span class="number">1.0f</span>;</span><br><span class="line">......</span><br><span class="line">SkBitmap decodingBitmap;</span><br><span class="line"><span class="keyword">if</span> (!decoder-&gt;decode(stream, &amp;decodingBitmap, prefColorType,decodeMode)) &#123;</span><br><span class="line">   <span class="keyword">return</span> nullObjectReturn(<span class="string">"decoder-&gt;decode returned false"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里这个deodingBitmap就是解码出来的bitmap，大小是图片原始的大小</span></span><br><span class="line"><span class="keyword">int</span> scaledWidth = decodingBitmap.width();</span><br><span class="line"><span class="keyword">int</span> scaledHeight = decodingBitmap.height();</span><br><span class="line"><span class="keyword">if</span> (willScale &amp;&amp; decodeMode != SkImageDecoder::kDecodeBounds_Mode) &#123;</span><br><span class="line">    scaledWidth = <span class="keyword">int</span>(scaledWidth * scale + <span class="number">0.5f</span>);</span><br><span class="line">    scaledHeight = <span class="keyword">int</span>(scaledHeight * scale + <span class="number">0.5f</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (willScale) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> sx = scaledWidth / <span class="keyword">float</span>(decodingBitmap.width());</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> sy = scaledHeight / <span class="keyword">float</span>(decodingBitmap.height());</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> avoid copying when scaled size equals decodingBitmap size</span></span><br><span class="line">    SkColorType colorType = colorTypeForScaledOutput(decodingBitmap.colorType());</span><br><span class="line">    <span class="comment">// <span class="doctag">FIXME:</span> If the alphaType is kUnpremul and the image has alpha, the</span></span><br><span class="line">    <span class="comment">// colors may not be correct, since Skia does not yet support drawing</span></span><br><span class="line">    <span class="comment">// to/from unpremultiplied bitmaps.</span></span><br><span class="line">    outputBitmap-&gt;setInfo(SkImageInfo::Make(scaledWidth, scaledHeight,</span><br><span class="line">            colorType, decodingBitmap.alphaType()));</span><br><span class="line">    <span class="keyword">if</span> (!outputBitmap-&gt;allocPixels(outputAllocator, NULL)) &#123;</span><br><span class="line">        <span class="keyword">return</span> nullObjectReturn(<span class="string">"allocation failed for scaled bitmap"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// If outputBitmap's pixels are newly allocated by Java, there is no need</span></span><br><span class="line">    <span class="comment">// to erase to 0, since the pixels were initialized to 0.</span></span><br><span class="line">    <span class="keyword">if</span> (outputAllocator != &amp;javaAllocator) &#123;</span><br><span class="line">        outputBitmap-&gt;eraseColor(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    SkPaint paint;</span><br><span class="line">    paint.setFilterLevel(SkPaint::kLow_FilterLevel);</span><br><span class="line"> </span><br><span class="line">    <span class="function">SkCanvas <span class="title">canvas</span><span class="params">(*outputBitmap)</span></span>;</span><br><span class="line">    canvas.scale(sx, sy);</span><br><span class="line">    canvas.drawBitmap(decodingBitmap, <span class="number">0.0f</span>, <span class="number">0.0f</span>, &amp;paint);</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;注意到其中有个 density 和 targetDensity，前者是 decodingBitmap 的 density，这个值跟这张图片的放置的目录有关（比如 xhdpi 是320，xxhdpi 是480），这部分代码我跟了一下，太长了，就不列出来了；targetDensity 实际上是我们加载图片的目标 density，这个值的来源我们已经在前面给出了，就是 DisplayMetrics 的 densityDpi，如果是Google Nexus 5那么这个数值就是480。sx 和sy 实际上是约等于 scale 的，因为 scaledWidth 和 scaledHeight 是由 width 和 height 乘以 scale 得到的。我们看到 Canvas 放大了 scale 倍，然后又把读到内存的这张 bitmap 画上去，相当于把这张 bitmap 放大了 scale 倍。</p>
<p>&#160; &#160; &#160; &#160;然后我们再次验证上面打log的地方，win + r ，输入calc呼出计算器。<strong>这里千万不要忘了了精度</strong>：</p>
<p><strong>float scale = 480/320f = 1.5</strong><br><strong>int scaledWidth = int(768 * 1.5 + 0.5f) = 1152</strong><br><strong>int scaledHeight = int(1152 * 1.5 + 0.5f) = 1728</strong></p>
<p><strong>size = 1152 <em> 1728 </em> 4 = 7962624</strong></p>
<p>&#160; &#160; &#160; &#160;果然和上面log打印的一模一样！因此我们可以得出结论。Bitmap在内存中大小取决于：</p>
<ul>
<li>色彩格式，前面我们已经提到，如果是 ARG_B8888 那么就是一个像素4个字节，如果是 RGB_565 那就是2个字节</li>
<li>原始文件存放的资源目录(是 hdpi 还是 xxhdpi 等等)</li>
<li>目标屏幕的密度（所以同等条件下，红米在资源方面消耗的内存肯定是要小于三星S6的）</li>
</ul>
<p>&#160; &#160; &#160; &#160;内存大小计算公式大概为（压缩计算情况下）（已忽略精度）：</p>
<blockquote>
<p><strong>内存大小 = （设备屏幕dpi / 资源所在目录dpi）^ 2 × 图片原始宽 × 图片原始高 × 像素大小</strong></p>
</blockquote>
<h1 id="瞎猜"><a href="#瞎猜" class="headerlink" title="瞎猜"></a>瞎猜</h1><p>&#160; &#160; &#160; &#160;上面分析Bitmap.Config时发现Android官方并不完全支持skia图形引擎的所有像素格式，供java层设置的Config只有这么4个：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Config &#123;</span><br><span class="line">    <span class="comment">// these native values must match up with the enum in SkBitmap.h</span></span><br><span class="line"> </span><br><span class="line">    ALPHA_8     (<span class="number">1</span>),</span><br><span class="line">    RGB_565     (<span class="number">3</span>),</span><br><span class="line">    ARGB_4444   (<span class="number">4</span>),</span><br><span class="line">    ARGB_8888   (<span class="number">5</span>);</span><br><span class="line">    </span><br><span class="line">    inal <span class="keyword">int</span> nativeInt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;其实 Java 层的枚举变量的 nativeInt 对应的就是 Skia 库当中枚举的索引值；而skia却支持这么多：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Skbitmap.h文件</span></span><br><span class="line">    <span class="keyword">enum</span> Config &#123;</span><br><span class="line">        kNo_Config,         <span class="comment">//!&lt; bitmap has not been configured</span></span><br><span class="line">        kA8_Config,         <span class="comment">//!&lt; 8-bits per pixel, with only alpha specified (0 is transparent, 0xFF is opaque)</span></span><br><span class="line">        kIndex8_Config,     <span class="comment">//!&lt; 8-bits per pixel, using SkColorTable to specify the colors</span></span><br><span class="line">        kRGB_565_Config,    <span class="comment">//!&lt; 16-bits per pixel, (see SkColorPriv.h for packing)</span></span><br><span class="line">        kARGB_4444_Config,  <span class="comment">//!&lt; 16-bits per pixel, (see SkColorPriv.h for packing)</span></span><br><span class="line">        kARGB_8888_Config,  <span class="comment">//!&lt; 32-bits per pixel, (see SkColorPriv.h for packing)</span></span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;上述枚举中第三个类型为<strong>索引图</strong>类型。<a href="http://www.tulaoshi.com/n/20160128/1466750.html" target="_blank" rel="external">索引位图</a>，每个像素只占 1 Byte，不仅支持 RGB，还支持 alpha。微软画图工具应该都玩过吧（win + r，输入mspaint），里面的调色板就是索引色盘。<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E6%B5%85%E6%9E%90Bitmap%E5%8D%A0%E6%8D%AE%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F/huatu.jpg" alt="画图工具"><br>&#160; &#160; &#160; &#160;而Android其他的config类型一个像素点占的字节比这个大多了，所以我们有时候能不能也用索引色去悄悄替换原来格式呢？<br>&#160; &#160; &#160; &#160;我的猜想是，反射构造一个Bitmap.Config枚举对象，然后反射设置nativeInt字段的值为2，猜想代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Options op = <span class="keyword">new</span> Options();</span><br><span class="line">op.inPreferredConfig = ...反射构建Bitmap.Config相关内容...</span><br><span class="line">BitmapFactory.decodeResource(getResources(), R.drawable.picture, op);</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;不过我没有实践过，也是瞎猜的，不知道能不能行的通。。。。。。</p>
<p>&#160; &#160; &#160; &#160;但是我对上一篇文章种调skia生成弹幕bitmap处的代码做了修改，修改了DanmakuFlameMaster工程里的NativeBitmapFactory.java文件：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Bitmap <span class="title">createNativeBitmap</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height, Config config, <span class="keyword">boolean</span> hasAlpha)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        int nativeConfig = getNativeConfig(config);</span></span><br><span class="line">        <span class="keyword">int</span> nativeConfig = <span class="number">2</span>;<span class="comment">//直接改为索引色</span></span><br><span class="line">        <span class="keyword">return</span> android.os.Build.VERSION.SDK_INT == <span class="number">19</span> ? createBitmap19(width, height,</span><br><span class="line">                nativeConfig, hasAlpha) : createBitmap(width, height, nativeConfig, hasAlpha);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;将色彩格式改为索引色，然后重新编译运行。。。。。。然而弹幕压根没出来。。。。。等以后有机会问问<code>ctiao</code>吧，请教一下为何。<br>&#160; &#160; &#160; &#160;这些瞎猜只能暂时放着，等以后有机会再验证吧。。。。。。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[弹幕框架DanmakuFlameMaster简单分析]]></title>
      <url>http://windrunnerlihuan.com/2016/07/02/DanmakuFlameMaster%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<hr>
<p>&#160; &#160; &#160; &#160;随着B站逐渐崛起，其开源弹幕项目<a href="https://github.com/Bilibili/DanmakuFlameMaster" target="_blank" rel="external">DanmakuFlameMaster</a>应用场景也越来越多。我也是在一次偶然机会下发现了这个项目，被其惊艳的效果震撼。以前我就对弹幕技术很感兴趣，可能是因为B站动漫看多，几乎每一部番都是漫天的弹幕乱飞，如果哪部剧没有弹幕反而觉得不适应；久而久之就愈发倾向钻研其原理。<br>&#160; &#160; &#160; &#160;看到效果后，我猜想<strong>绘制原理</strong>应该是创建一个定时器作为全部弹幕的时间参考，然后每条弹幕出现的位置都以这个定时器去计算x、y值，然后定时任务定期postInvalidate，弹幕画布重新绘制onDraw；弹幕如此之多，应该有<strong>缓存机制</strong>，也许建立了一个弹幕池让出现过的弹幕缓存起来，新弹幕可以复用旧弹幕item。<br>&#160; &#160; &#160; &#160;先这么假设吧，然后验证我们的猜想，看看有哪些坑。<br><a id="more"></a></p>
<hr>
<h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><p>&#160; &#160; &#160; &#160;首先是添加控件，项目里提供了三个控件：DanmakuSurfaceView、DanmakuTextureView和DanmakuView，使用其中三个任意一个都可以。我们选个DanmakuView方便分析。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">FrameLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span><br><span class="line">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span><br><span class="line">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span><br><span class="line">    <span class="attr">tools:context</span>=<span class="string">".MainActivity"</span>&gt;</span>	</span><br><span class="line">    </span><br><span class="line">	省略一些布局...</span><br><span class="line">	</span><br><span class="line">    <span class="tag">&lt;<span class="name">master.flame.danmaku.ui.widget.DanmakuView</span></span><br><span class="line">        <span class="attr">android:id</span>=<span class="string">"@+id/sv_danmaku"</span></span><br><span class="line">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span><br><span class="line">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span> /&gt;</span></span><br><span class="line">        </span><br><span class="line">    省略一些布局...  </span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">FrameLayout</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;然后是代码配置，先看一下初始化相关：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">      setContentView(R.layout.activity_main);</span><br><span class="line">      findViews();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">findViews</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">省略一些代码...</span><br><span class="line"></span><br><span class="line">      <span class="comment">// DanmakuView</span></span><br><span class="line">mDanmakuView = (IDanmakuView) findViewById(R.id.sv_danmaku);</span><br><span class="line">      <span class="comment">// 设置最大显示行数</span></span><br><span class="line">      HashMap&lt;Integer, Integer&gt; maxLinesPair = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">      maxLinesPair.put(BaseDanmaku.TYPE_SCROLL_RL, <span class="number">5</span>); <span class="comment">// 滚动弹幕最大显示5行</span></span><br><span class="line">      <span class="comment">// 设置是否禁止重叠</span></span><br><span class="line">      HashMap&lt;Integer, Boolean&gt; overlappingEnablePair = <span class="keyword">new</span> HashMap&lt;Integer, Boolean&gt;();</span><br><span class="line">      overlappingEnablePair.put(BaseDanmaku.TYPE_SCROLL_RL, <span class="keyword">true</span>);</span><br><span class="line">      overlappingEnablePair.put(BaseDanmaku.TYPE_FIX_TOP, <span class="keyword">true</span>);</span><br><span class="line">   <span class="comment">//创建弹幕控件上下文，类似Context，里面可以进行一系列配置</span></span><br><span class="line">      mContext = DanmakuContext.create();</span><br><span class="line">mContext.setDanmakuStyle(IDisplayer.DANMAKU_STYLE_STROKEN, <span class="number">3</span>)<span class="comment">//设置描边样式</span></span><br><span class="line">.setDuplicateMergingEnabled(<span class="keyword">false</span>) <span class="comment">//设置不合并相同内容弹幕</span></span><br><span class="line">.setScrollSpeedFactor(<span class="number">1.2f</span>) <span class="comment">//设置弹幕滚动速度缩放比例，越大速度越慢</span></span><br><span class="line">.setScaleTextSize(<span class="number">1.2f</span>) <span class="comment">//设置字体缩放比例</span></span><br><span class="line">   .setCacheStuffer(<span class="keyword">new</span> SpannedCacheStuffer(), mCacheStufferAdapter) <span class="comment">// 图文混排使用SpannedCacheStuffer  </span></span><br><span class="line"><span class="comment">//.setCacheStuffer(new BackgroundCacheStuffer())  // 绘制背景使用BackgroundCacheStuffer</span></span><br><span class="line">      .setMaximumLines(maxLinesPair) <span class="comment">//设置最大行数策略</span></span><br><span class="line">      .preventOverlapping(overlappingEnablePair); <span class="comment">//设置禁止重叠策略</span></span><br><span class="line">      	       </span><br><span class="line">省略一些代码...</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;DanmakuContext设置setCacheStuffer(CacheStuffer, Proxy)时，如果不设置此方法，则CacheStuffer默认为SimpleTextCacheStuffer，proxy默认为null；第一个参数，项目例子中提供了BackgroundCacheStuffer和SpannedCacheStuffer，其实也可以自己扩展，第二个参数例子中也写了一个mCacheStufferAdapter，同理也可以自己扩展。这个sample中注释也写得比较明确，我们往下分析原理时会解释。<br>&#160; &#160; &#160; &#160;然后设置数据源：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">			<span class="comment">//替换为A站弹幕数据源，因为A站弹幕数据是json，B站是xml，为了方便分析因此替换为A站源</span></span><br><span class="line">            <span class="comment">//mParser = createParser(this.getResources().openRawResource(R.raw.comments));</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mParser = createParser(<span class="keyword">this</span>.getAssets().open(<span class="string">"comment.json"</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> BaseDanmakuParser <span class="title">createParser</span><span class="params">(InputStream stream)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (stream == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> BaseDanmakuParser() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> Danmakus <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> Danmakus();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        ILoader loader = DanmakuLoaderFactory.create(DanmakuLoaderFactory.TAG_BILI);</span></span><br><span class="line">        ILoader loader = DanmakuLoaderFactory.create(DanmakuLoaderFactory.TAG_ACFUN);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            loader.load(stream);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalDataException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        BaseDanmakuParser parser = new BiliDanmukuParser();</span></span><br><span class="line">        BaseDanmakuParser parser = <span class="keyword">new</span> AcFunDanmakuParser();</span><br><span class="line">        IDataSource&lt;?&gt; dataSource = loader.getDataSource();</span><br><span class="line">        parser.load(dataSource);</span><br><span class="line">        <span class="keyword">return</span> parser;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;最后启动弹幕：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置弹幕view相关回调</span></span><br><span class="line">mDanmakuView.setCallback(<span class="keyword">new</span> DrawHandler.Callback() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateTimer</span><span class="params">(DanmakuTimer timer)</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawingFinished</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">danmakuShown</span><span class="params">(BaseDanmaku danmaku)</span> </span>&#123;</span><br><span class="line">         <span class="comment">//Log.d("DFM", "danmakuShown(): text=" + danmaku.text);</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Log.d(<span class="string">"DFM"</span>, <span class="string">"MainActivity inline callback's method prepared"</span>);</span><br><span class="line">            mDanmakuView.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    mDanmakuView.prepare(mParser, mContext);</span><br><span class="line">    mDanmakuView.showFPS(<span class="keyword">true</span>);</span><br><span class="line">    mDanmakuView.enableDanmakuDrawingCache(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;基本使用在项目的例子中都写的很清楚，这些应该难度不大。接下来应该是分析流程了。</p>
<h1 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h1><p>&#160; &#160; &#160; &#160;DanmakuFlameMaster流程确实十分复杂，因为变量实在太多了，所以分析时推荐先整体看个大概，然后一步一步打断点确认细节。</p>
<h2 id="初始配置"><a href="#初始配置" class="headerlink" title="初始配置"></a>初始配置</h2><p>&#160; &#160; &#160; &#160;上面写基本使用法，第一步是初始配置，我们看看到底初始化了哪些参数。对比上面的调用顺序，首先进入DanmakuContext看看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">		<span class="comment">//相关配置如下，主要初始化一下变量</span></span><br><span class="line">		mContext.setDanmakuStyle(IDisplayer.DANMAKU_STYLE_STROKEN, <span class="number">3</span>)<span class="comment">//设置描边样式</span></span><br><span class="line">		.setDuplicateMergingEnabled(<span class="keyword">false</span>) <span class="comment">//设置不合并相同内容弹幕</span></span><br><span class="line">		.setScrollSpeedFactor(<span class="number">1.2f</span>) <span class="comment">//设置弹幕滚动速度缩放比例，越大速度越慢</span></span><br><span class="line">		.setScaleTextSize(<span class="number">1.2f</span>) <span class="comment">//设置字体缩放比例</span></span><br><span class="line">	    .setCacheStuffer(<span class="keyword">new</span> SpannedCacheStuffer(), mCacheStufferAdapter) <span class="comment">// 图文混排使用SpannedCacheStuffer  </span></span><br><span class="line">		<span class="comment">//.setCacheStuffer(new BackgroundCacheStuffer())  // 绘制背景使用BackgroundCacheStuffer</span></span><br><span class="line">        .setMaximumLines(maxLinesPair) <span class="comment">//设置最大行数策略</span></span><br><span class="line">        .preventOverlapping(overlappingEnablePair); <span class="comment">//设置禁止重叠策略</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//DanmakuContext 类重要方法</span></span><br><span class="line">		<span class="comment">/*------------DanmakuContext STAET-----------*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AbsDisplayer mDisplayer = <span class="keyword">new</span> AndroidDisplayer();<span class="comment">//创建DanmakuContext 对象时直接new了个mDisplayer 全局变量</span></span><br><span class="line">	 <span class="comment">/**</span><br><span class="line">     * 设置缓存绘制填充器，默认使用SimpleTextCacheStuffer只支持纯文字显示, 如果需要图文混排请设置SpannedCacheStuffer </span><br><span class="line">     * 如果需要定制其他样式请扩展SimpleTextCacheStuffer或者SpannedCacheStuffer</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DanmakuContext <span class="title">setCacheStuffer</span><span class="params">(BaseCacheStuffer cacheStuffer, BaseCacheStuffer.Proxy cacheStufferAdapter)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mCacheStuffer = cacheStuffer;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.mCacheStuffer != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.mCacheStuffer.setProxy(cacheStufferAdapter);</span><br><span class="line">            mDisplayer.setCacheStuffer(<span class="keyword">this</span>.mCacheStuffer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*------------DanmakuContext END-----------*/</span></span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;以上配置主要配置一些常规参数，记不住也没关系，我们可以打断点一一查看。</p>
<h2 id="加载资源"><a href="#加载资源" class="headerlink" title="加载资源"></a>加载资源</h2><p>&#160; &#160; &#160; &#160;然后就是加载弹幕源：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> BaseDanmakuParser <span class="title">createParser</span><span class="params">(InputStream stream)</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建A站弹幕加载器</span></span><br><span class="line">      ILoader loader = DanmakuLoaderFactory.create(DanmakuLoaderFactory.TAG_ACFUN);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">//将数据流载入加载器里</span></span><br><span class="line">          loader.load(stream);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IllegalDataException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//创建弹幕解析器</span></span><br><span class="line">      BaseDanmakuParser parser = <span class="keyword">new</span> AcFunDanmakuParser();</span><br><span class="line">      <span class="comment">//取出数据源</span></span><br><span class="line">      IDataSource&lt;?&gt; dataSource = loader.getDataSource();</span><br><span class="line">      <span class="comment">//解析器放入数据源</span></span><br><span class="line">      parser.load(dataSource);</span><br><span class="line">      <span class="keyword">return</span> parser;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;我们一步一步来，先创建A站弹幕加载器：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据不同标签创建不同加载器，可以根据不同业务自己扩展定制</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ILoader <span class="title">create</span><span class="params">(String tag)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (TAG_BILI.equalsIgnoreCase(tag)) &#123;</span><br><span class="line">           <span class="keyword">return</span> BiliDanmakuLoader.instance();</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span>(TAG_ACFUN.equalsIgnoreCase(tag))<span class="comment">//我们到了这里</span></span><br><span class="line">       	<span class="keyword">return</span> AcFunDanmakuLoader.instance();</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;载入数据流：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">(InputStream in)</span> <span class="keyword">throws</span> IllegalDataException </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		dataSource = <span class="keyword">new</span> JSONSource(in);<span class="comment">//这里创建了一个JSONSource</span></span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalDataException(e);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//JSONSource构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">JSONSource</span><span class="params">(InputStream in)</span> <span class="keyword">throws</span> JSONException</span>&#123;</span><br><span class="line">	init(in);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(InputStream in)</span> <span class="keyword">throws</span> JSONException </span>&#123;</span><br><span class="line">	......</span><br><span class="line">	mInput = in;</span><br><span class="line">	String json = IOUtils.getString(mInput);<span class="comment">//将流转成字符串</span></span><br><span class="line">	init(json);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(String json)</span> <span class="keyword">throws</span> JSONException </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!TextUtils.isEmpty(json))&#123;</span><br><span class="line">		mJSONArray = <span class="keyword">new</span> JSONArray(json);<span class="comment">//将json字符串保存到一个JSONArray全局变量</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//取出JSONSource</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> JSONSource <span class="title">getDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> dataSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;载入数据流就是读取弹幕数据文件流，然后转成字符串，最后保存到一个JSONArray变量里存起来。<br>&#160; &#160; &#160; &#160;继续往下分析创建弹幕解析器、取出数据源、解析器放入数据源：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AcFunDanmakuParser的load方法，将上一步得到的JSONSource放入到AcFunDanmakuParser中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BaseDanmakuParser <span class="title">load</span><span class="params">(IDataSource&lt;?&gt; source)</span> </span>&#123;</span><br><span class="line">      mDataSource = source;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;到这里数据就载入到解析器里了，parser里有弹幕源数据了。</p>
<h2 id="启动弹幕"><a href="#启动弹幕" class="headerlink" title="启动弹幕"></a>启动弹幕</h2><p>&#160; &#160; &#160; &#160;启动弹幕重要的就是这一句：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mDanmakuView.prepare(mParser, mContext);</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;此时mParser和mContext都已经初始化完成。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(BaseDanmakuParser parser, DanmakuContext config)</span> </span>&#123;</span><br><span class="line">     prepare();<span class="comment">///创建一个 DrawHandler</span></span><br><span class="line">     handler.setConfig(config);</span><br><span class="line">     handler.setParser(parser);</span><br><span class="line">     handler.setCallback(mCallback);</span><br><span class="line">     handler.prepare();<span class="comment">//然后调用DrawHandler的prepare方法</span></span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//创建一个 DrawHandler</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (handler == <span class="keyword">null</span>)</span><br><span class="line">         handler = <span class="keyword">new</span> DrawHandler(getLooper(mDrawingThreadType), <span class="keyword">this</span>, mDanmakuVisible);<span class="comment">//mDanmakuVisible为true</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;设置一些全局变量后，会调用DrawHandler的prepare方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sendEmptyMessage(DrawHandler.PREPARE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> what = msg.what;</span><br><span class="line">    <span class="keyword">switch</span> (what) &#123;</span><br><span class="line">        <span class="keyword">case</span> PREPARE:</span><br><span class="line">            mTimeBase = SystemClock.uptimeMillis();</span><br><span class="line">            <span class="keyword">if</span> (mParser == <span class="keyword">null</span> || !mDanmakuView.isViewReady()) &#123;<span class="comment">// false || false</span></span><br><span class="line">                sendEmptyMessageDelayed(PREPARE, <span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                prepare(<span class="keyword">new</span> Runnable() &#123;<span class="comment">//会继续调用prepare重载方法</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        pausedPosition = <span class="number">0</span>;</span><br><span class="line">                        mReady = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            mCallback.prepared();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            ......</span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> DanmakuTimer timer = <span class="keyword">new</span> DanmakuTimer();<span class="comment">//已经初始化timer</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">final</span> Runnable runnable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (drawTask == <span class="keyword">null</span>) &#123;<span class="comment">//会继续调用createDrawTask方法</span></span><br><span class="line">        drawTask = createDrawTask(mDanmakuView.isDanmakuDrawingCacheEnabled(), timer,</span><br><span class="line">                mDanmakuView.getContext(), mDanmakuView.getWidth(), mDanmakuView.getHeight(),</span><br><span class="line">                mDanmakuView.isHardwareAccelerated(), <span class="keyword">new</span> IDrawTask.TaskListener() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ready</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        initRenderingConfigs();</span><br><span class="line">                        runnable.run();</span><br><span class="line">                    &#125;</span><br><span class="line">		......</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        runnable.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继续调用createDrawTask(true, timer, context, width, height, true, listener)方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> IDrawTask <span class="title">createDrawTask</span><span class="params">(<span class="keyword">boolean</span> useDrwaingCache, DanmakuTimer timer,</span><br><span class="line">                                 Context context,</span><br><span class="line">                                 <span class="keyword">int</span> width, <span class="keyword">int</span> height,</span><br><span class="line">                                 <span class="keyword">boolean</span> isHardwareAccelerated,</span><br><span class="line">                                 IDrawTask.TaskListener taskListener)</span> </span>&#123;</span><br><span class="line">    mDisp = mContext.getDisplayer();<span class="comment">//AndroidDisplayer赋给它，顾名思义，Displayer就是显示器</span></span><br><span class="line">    mDisp.setSize(width, height);<span class="comment">//设置弹幕视图宽高</span></span><br><span class="line">    DisplayMetrics displayMetrics = context.getResources().getDisplayMetrics();</span><br><span class="line">    mDisp.setDensities(displayMetrics.density, displayMetrics.densityDpi,</span><br><span class="line">            displayMetrics.scaledDensity);<span class="comment">//设置密度先关</span></span><br><span class="line">    mDisp.resetSlopPixel(mContext.scaleTextSize);<span class="comment">//设置字体缩放比例，之前设过了1.2</span></span><br><span class="line">    mDisp.setHardwareAccelerated(isHardwareAccelerated);<span class="comment">//硬件加速，true</span></span><br><span class="line">    <span class="comment">//useDrwaingCache 为true</span></span><br><span class="line">    IDrawTask task = useDrwaingCache ?</span><br><span class="line">            <span class="keyword">new</span> CacheManagingDrawTask(timer, mContext, taskListener, <span class="number">1024</span> * <span class="number">1024</span> * AndroidUtils.getMemoryClass(context) / <span class="number">3</span>)</span><br><span class="line">            : <span class="keyword">new</span> DrawTask(timer, mContext, taskListener);</span><br><span class="line">    task.setParser(mParser);<span class="comment">//把存放数据源的mParser放入CacheManagingDrawTask中</span></span><br><span class="line">    task.prepare();<span class="comment">//这个才是重点，调用CacheManagingDrawTask的prepare方法</span></span><br><span class="line">    obtainMessage(NOTIFY_DISP_SIZE_CHANGED, <span class="keyword">false</span>).sendToTarget();</span><br><span class="line">    <span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;上述过程最后一个调用了createDrawTask方法，这里先初始化了一下AndroidDisplayer配置，就把他当做显示器吧，我猜<code>ctiao</code>当初设计时也是这么比喻的吧。<br>&#160; &#160; &#160; &#160;设置好弹幕显示相关的参数，然后就是创建绘制任务IDrawTask 了。这里有两个选择，如果使用缓存就创建CacheManagingDrawTask，不使用就创建DrawTask。不过CacheManagingDrawTask比DrawTask复杂很多。</p>
<h3 id="CacheManagingDrawTask绘制任务"><a href="#CacheManagingDrawTask绘制任务" class="headerlink" title="CacheManagingDrawTask绘制任务"></a>CacheManagingDrawTask绘制任务</h3><p>&#160; &#160; &#160; &#160;我们的useDrwaingCache为true（<code>其实把它改为false也没关系，并且这样就用不上那些so库了</code>），则创建CacheManagingDrawTask绘制任务，然后调用prepare方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CacheManagingDrawTask</span><span class="params">(DanmakuTimer timer, DanmakuContext config, TaskListener taskListener, <span class="keyword">int</span> maxCacheSize)</span> </span>&#123;<span class="comment">//传入定时器timer，config，listener，还有三分一应用分配内存大小的maxCacheSize</span></span><br><span class="line">      <span class="keyword">super</span>(timer, config, taskListener);<span class="comment">//会调用父类DrawTask的构造方法</span></span><br><span class="line">      NativeBitmapFactory.loadLibs();<span class="comment">//加载so库，用于创建bitmap，同时测试时候加载成功</span></span><br><span class="line">      mMaxCacheSize = maxCacheSize;</span><br><span class="line">      <span class="keyword">if</span> (NativeBitmapFactory.isInNativeAlloc()) &#123;<span class="comment">//true,将最大内存扩大到2倍</span></span><br><span class="line">          mMaxCacheSize = maxCacheSize * <span class="number">2</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      mCacheManager = <span class="keyword">new</span> CacheManager(maxCacheSize, MAX_CACHE_SCREEN_SIZE);</span><br><span class="line">      mRenderer.setCacheManager(mCacheManager);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//看看父类的构造方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DrawTask</span><span class="params">(DanmakuTimer timer, DanmakuContext context,</span><br><span class="line">          TaskListener taskListener)</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line">      mContext = context;</span><br><span class="line">      mDisp = context.getDisplayer();</span><br><span class="line">      mTaskListener = taskListener;</span><br><span class="line">      mRenderer = <span class="keyword">new</span> DanmakuRenderer(context);</span><br><span class="line">......</span><br><span class="line">      initTimer(timer);<span class="comment">//初始化相关定时器</span></span><br><span class="line">......</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initTimer</span><span class="params">(DanmakuTimer timer)</span> </span>&#123;</span><br><span class="line">      mTimer = timer;</span><br><span class="line">      mCacheTimer = <span class="keyword">new</span> DanmakuTimer();</span><br><span class="line">      mCacheTimer.update(timer.currMillisecond);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;CacheManagingDrawTask的构造方法设置了一些变量。其中NativeBitmapFactory.loadLibs()加载了用于创建bitmap的so文件，就是用skia图形处理库直接创建bitmap，Android对2D图形处理采用的就是skia，3D图形处理用的是OpenGL ES。这样通过native层创建bitmap直接跳过Dalvik，毕竟java层内存用多了很容易oom。因为以前我就对native层比较感兴趣，所以我要任性的跟一遍源码 ^O.O^。为了怕跟完后自己晕了，找不到现在分析的地方了，所以在这里打个标签，mark一下。如不感兴趣，可以跳过= 。=<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/DanmakuFlameMaster%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/meizi.jpg" alt="标签"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//NativeBitmapFactory</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadLibs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		......</span><br><span class="line">        System.loadLibrary(<span class="string">"ndkbitmap"</span>);<span class="comment">//载入so</span></span><br><span class="line">		......</span><br><span class="line">        <span class="comment">//测试功能</span></span><br><span class="line">        <span class="keyword">if</span> (nativeLibLoaded) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> libInit = init();<span class="comment">//这是一个native方法</span></span><br><span class="line">            <span class="keyword">if</span> (!libInit) &#123;</span><br><span class="line">                release();</span><br><span class="line">                notLoadAgain = <span class="keyword">true</span>;</span><br><span class="line">                nativeLibLoaded = <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//初始化成功后</span></span><br><span class="line">                initField();<span class="comment">//反射Bitmap.Config的nativeInt字段</span></span><br><span class="line">                <span class="keyword">boolean</span> confirm = testLib();<span class="comment">//测试例子</span></span><br><span class="line">  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Log.e(<span class="string">"NativeBitmapFactory"</span>, <span class="string">"loaded"</span> + nativeLibLoaded);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//反射Bitmap.Config的nativeInt字段</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initField</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            nativeIntField = Bitmap.Config.class.getDeclaredField(<span class="string">"nativeInt"</span>);</span><br><span class="line">            nativeIntField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">            nativeIntField = <span class="keyword">null</span>;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">init</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这里会调用测试方法testLib：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">testLib</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (nativeIntField == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     Bitmap bitmap = <span class="keyword">null</span>;</span><br><span class="line">     Canvas canvas = <span class="keyword">null</span>;</span><br><span class="line">     ......</span><br><span class="line">      <span class="comment">//用native方法创建一个bitmap</span></span><br><span class="line">         bitmap = createNativeBitmap(<span class="number">2</span>, <span class="number">2</span>, Bitmap.Config.ARGB_8888, <span class="keyword">true</span>);</span><br><span class="line">         <span class="keyword">boolean</span> result = (bitmap != <span class="keyword">null</span> &amp;&amp; bitmap.getWidth() == <span class="number">2</span> &amp;&amp; bitmap.getHeight() == <span class="number">2</span>);</span><br><span class="line">......</span><br><span class="line">             canvas = <span class="keyword">new</span> Canvas(bitmap);</span><br><span class="line">             Paint paint = <span class="keyword">new</span> Paint();</span><br><span class="line">             paint.setColor(Color.RED);</span><br><span class="line">             paint.setTextSize(<span class="number">20f</span>);</span><br><span class="line">             canvas.drawRect(<span class="number">0f</span>, <span class="number">0f</span>, (<span class="keyword">float</span>) bitmap.getWidth(), (<span class="keyword">float</span>) bitmap.getHeight(),</span><br><span class="line">                     paint);</span><br><span class="line">             canvas.drawText(<span class="string">"TestLib"</span>, <span class="number">0</span>, <span class="number">0</span>, paint);</span><br><span class="line"></span><br><span class="line">   ......</span><br><span class="line">         <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Bitmap <span class="title">createNativeBitmap</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height, Config config, <span class="keyword">boolean</span> hasAlpha)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> nativeConfig = getNativeConfig(config);<span class="comment">//反射设置Bitmap.Config.ARGB_8888</span></span><br><span class="line">     <span class="keyword">return</span> android.os.Build.VERSION.SDK_INT == <span class="number">19</span> ? createBitmap19(width, height,</span><br><span class="line">             nativeConfig, hasAlpha) : createBitmap(width, height, nativeConfig, hasAlpha);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNativeConfig</span><span class="params">(Bitmap.Config config)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (nativeIntField == <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> nativeIntField.getInt(config);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">     &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> Bitmap <span class="title">createBitmap</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height, <span class="keyword">int</span> nativeConfig,</span><br><span class="line">         <span class="keyword">boolean</span> hasAlpha)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> Bitmap <span class="title">createBitmap19</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height, <span class="keyword">int</span> nativeConfig,</span><br><span class="line">         <span class="keyword">boolean</span> hasAlpha)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;上述最终用native方法创建bitmap，C++文件地址为 <a href="https://github.com/Bilibili/NativeBitmapFactory" target="_blank" rel="external">https://github.com/Bilibili/NativeBitmapFactory</a> ，接着继续查看native方法具体实现NativeBitmapFactory.cpp。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先看java层init方法对应的本地方法</span></span><br><span class="line"><span class="function">jboolean <span class="title">Java_tv_cjump_jni_NativeBitmapFactory_init</span><span class="params">(JNIEnv *env)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	......</span><br><span class="line">	<span class="comment">//继续看Start方法</span></span><br><span class="line">    <span class="keyword">int</span> r = Start();</span><br><span class="line">    <span class="keyword">return</span> r == SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Start</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">//创建一个类型为ndkbitmap_obj 的结构体指针</span></span><br><span class="line">    ndkbitmap_obj = (<span class="keyword">ndkbitmap_object_t</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*ndkbitmap_obj));</span><br><span class="line">    <span class="keyword">int</span> r = Open(ndkbitmap_obj);</span><br><span class="line">	......</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Open</span><span class="params">(<span class="keyword">ndkbitmap_object_t</span> *obj)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">//创建一个类型为skbitmap_sys_t 的结构体指针</span></span><br><span class="line">    <span class="keyword">skbitmap_sys_t</span> *sys = (<span class="keyword">skbitmap_sys_t</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (*sys));</span><br><span class="line">	......</span><br><span class="line">	<span class="comment">//打开libskia.so动态链接库，初始化一些参数并返回动态链接库的句柄</span></span><br><span class="line">    sys-&gt;libskia = InitLibrary(sys);</span><br><span class="line">	......</span><br><span class="line">	<span class="comment">//打开libandroid_runtime.so动态链接库，初始化一些参数并返回动态链接库的句柄</span></span><br><span class="line">    sys-&gt;libjnigraphics = InitLibrary2(sys);</span><br><span class="line">	......</span><br><span class="line">	<span class="comment">//将初始化过后的结构指针sys赋给结构体obj的sys成员</span></span><br><span class="line">    obj-&gt;sys = sys;</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;init方法主要是打开和skia相关的动态链接库，并初始化一些配置。(InitLibrary和InitLibrary2方法的细节我没有贴，里面实现需要一些专业知识，有兴趣的可以找资料钻研)然后就是createBitmap：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">jobject <span class="title">Java_tv_cjump_jni_NativeBitmapFactory_createBitmap</span><span class="params">(JNIEnv *env , jobject  obj, jint w, jint h, jint config, jboolean hasAlpha)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> createBitmap(env, obj, w, h, config, hasAlpha, <span class="keyword">true</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">jobject <span class="title">Java_tv_cjump_jni_NativeBitmapFactory_createBitmap19</span><span class="params">(JNIEnv *env , jobject  obj, jint w, jint h, jint config, jboolean hasAlpha)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> createBitmap(env, obj, w, h, config, hasAlpha, <span class="number">0x3</span>, <span class="number">19</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">jobject <span class="title">createBitmap</span><span class="params">(JNIEnv *env , jobject  obj, jint w, jint h, jint config, jboolean hasAlpha, <span class="keyword">int</span> isMuttable, <span class="keyword">int</span> api)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *bm = createSkBitmap(ndkbitmap_obj, config, w, h);<span class="comment">//调用重载方法创建bitmap指针</span></span><br><span class="line">    <span class="keyword">if</span> (bm == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    jobject result = NULL;</span><br><span class="line">    skbitmap_sys_t *p_sys = ndkbitmap_obj-&gt;sys;</span><br><span class="line">    <span class="keyword">if</span>(p_sys-&gt;libjnigraphics) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p_sys-&gt;gjni_createBitmap) </span><br><span class="line">        &#123;<span class="comment">//SDK版本小于19</span></span><br><span class="line">	        <span class="comment">//通过这个函数指针把JNI层bitmap的转换对象return给java层</span></span><br><span class="line">            result = p_sys-&gt;gjni_createBitmap(env, bm, isMuttable, NULL, -<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(p_sys-&gt;gjni_createBitmap_19later) &#123;<span class="comment">//SDK版本19以后返回值</span></span><br><span class="line">            result = p_sys-&gt;gjni_createBitmap_19later(env, bm, NULL, isMuttable, NULL, NULL, -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建bitmap指针，并通过相关指针函数设置bitmap参数</span></span><br><span class="line">inline <span class="keyword">void</span> *createSkBitmap(ndkbitmap_object_t *obj, <span class="keyword">int</span> config, <span class="keyword">int</span> w, <span class="keyword">int</span> h)</span><br><span class="line">&#123;</span><br><span class="line">    skbitmap_sys_t *p_sys = obj-&gt;sys;</span><br><span class="line">    <span class="keyword">if</span> (p_sys == NULL || p_sys-&gt;libskia == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//申请内存，创建skBitmap 指针</span></span><br><span class="line">    <span class="keyword">void</span> *skBitmap = malloc(SIZE_OF_SKBITMAP);</span><br><span class="line">    <span class="keyword">if</span> (!skBitmap)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    *((uint32_t *) ((uint32_t)skBitmap + SIZE_OF_SKBITMAP - <span class="number">4</span>)) = <span class="number">0xbaadbaad</span>;</span><br><span class="line">    <span class="comment">//ctor   </span></span><br><span class="line">    p_sys-&gt;sk_ctor(skBitmap);</span><br><span class="line">    <span class="keyword">if</span> (p_sys-&gt;sk_setConfig)</span><br><span class="line">    &#123;</span><br><span class="line">        p_sys-&gt;sk_setConfig(skBitmap, config, w, h, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (p_sys-&gt;sk_setConfig_19later)</span><br><span class="line">    &#123;</span><br><span class="line">        p_sys-&gt;sk_setConfig_19later(skBitmap, config, w, h, <span class="number">0</span>, (uint8_t)kPremul_SkAlphaType);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p_sys-&gt;sk_setInfo) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> imageInfo[<span class="number">4</span>] = &#123;w, h, SkBitmapConfigToColorType(config), kPremul_SkAlphaType&#125;;</span><br><span class="line">        p_sys-&gt;sk_setInfo(skBitmap, imageInfo, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    p_sys-&gt;sk_allocPixels(skBitmap, NULL, NULL);</span><br><span class="line">    p_sys-&gt;sk_eraseARGB(skBitmap, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(*((uint32_t *) ((uint32_t)skBitmap + SIZE_OF_SKBITMAP - <span class="number">4</span>)) == <span class="number">0xbaadbaad</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">        free(skBitmap);</span><br><span class="line">        <span class="keyword">return</span> NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> skBitmap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;通过skia图形库创建bitmap流程大概就是这些，其实skia的东西也是巨多无比，如果是从事这一方面工作应该都轻车熟路，我是完全的小白，能力有限，只能先到这儿。</p>
<p>&#160; &#160; &#160; &#160;好了，继续回到上次打标签的地方。接着该调用CacheManagingDrawTask的prepare方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> (mParser != <span class="keyword">null</span>);</span><br><span class="line">    loadDanmakus(mParser);</span><br><span class="line">    mCacheManager.begin();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;先调用loadDanmakus方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> IDanmakus danmakuList;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadDanmakus</span><span class="params">(BaseDanmakuParser parser)</span> </span>&#123;</span><br><span class="line">        danmakuList = parser.setConfig(mContext)</span><br><span class="line">                            .setDisplayer(mDisp)</span><br><span class="line">                            .setTimer(mTimer)</span><br><span class="line">                            .getDanmakus();<span class="comment">//从parser中取出弹幕数据,做出相关处理</span></span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(danmakuList != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mLastDanmaku = danmakuList.last();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;parser设置完DanmakuContext，AndroidDisplayer，DanmakuTimer之后，再调用getDanmakus取出弹幕信息：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> IDanmakus <span class="title">getDanmakus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mDanmakus != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> mDanmakus;</span><br><span class="line">    mContext.mDanmakuFactory.resetDurationsData();<span class="comment">//重庆内置一些变量为null</span></span><br><span class="line">    mDanmakus = parse();<span class="comment">//解析弹幕</span></span><br><span class="line">    releaseDataSource();<span class="comment">//关闭JSONSource</span></span><br><span class="line">    mContext.mDanmakuFactory.updateMaxDanmakuDuration();<span class="comment">//修正弹幕最大时长</span></span><br><span class="line">    <span class="keyword">return</span> mDanmakus;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;进入AcFunDanmakuParser的parse方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> Danmakus <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mDataSource != <span class="keyword">null</span> &amp;&amp; mDataSource <span class="keyword">instanceof</span> JSONSource) &#123;</span><br><span class="line">            JSONSource jsonSource = (JSONSource) mDataSource;</span><br><span class="line">            <span class="keyword">return</span> doParse(jsonSource.data());<span class="comment">//go on</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Danmakus();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Danmakus <span class="title">doParse</span><span class="params">(JSONArray danmakuListData)</span> </span>&#123;</span><br><span class="line">        Danmakus danmakus = <span class="keyword">new</span> Danmakus();</span><br><span class="line">        <span class="keyword">if</span> (danmakuListData == <span class="keyword">null</span> || danmakuListData.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> danmakus;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; danmakuListData.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                JSONObject danmakuArray = danmakuListData.getJSONObject(i);</span><br><span class="line">                <span class="keyword">if</span> (danmakuArray != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    danmakus = _parse(danmakuArray, danmakus);<span class="comment">//解析每一条弹幕</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (JSONException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> danmakus;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">/**</span><br><span class="line">     * &#123;"c":"19.408,16777215,1,25,178252,1376325904","m":"金刚如来！"&#125;</span><br><span class="line">     // 0:时间(弹幕出现时间)</span><br><span class="line">     // 1:颜色</span><br><span class="line">     // 2:类型(1从右往左滚动弹幕|6从右至左滚动弹幕|5顶端固定弹幕|4底端固定弹幕|7高级弹幕|8脚本弹幕)</span><br><span class="line">     // 3:字号</span><br><span class="line">     // 4:用户id ?</span><br><span class="line">     // 5:时间戳 ?</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Danmakus <span class="title">_parse</span><span class="params">(JSONObject jsonObject, Danmakus danmakus)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (danmakus == <span class="keyword">null</span>) &#123;</span><br><span class="line">            danmakus = <span class="keyword">new</span> Danmakus();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (jsonObject == <span class="keyword">null</span> || jsonObject.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> danmakus;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; jsonObject.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                JSONObject obj = jsonObject;</span><br><span class="line">                String c = obj.getString(<span class="string">"c"</span>);<span class="comment">//弹幕配置信息</span></span><br><span class="line">                String[] values = c.split(<span class="string">","</span>);</span><br><span class="line">                <span class="keyword">if</span> (values.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> type = Integer.parseInt(values[<span class="number">2</span>]); <span class="comment">// 弹幕类型</span></span><br><span class="line">                    <span class="keyword">if</span> (type == <span class="number">7</span>)</span><br><span class="line">                        <span class="comment">// FIXME : hard code</span></span><br><span class="line">                        <span class="comment">// TODO : parse advance danmaku json</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">long</span> time = (<span class="keyword">long</span>) (Float.parseFloat(values[<span class="number">0</span>]) * <span class="number">1000</span>); <span class="comment">// 出现时间</span></span><br><span class="line">                    <span class="keyword">int</span> color = Integer.parseInt(values[<span class="number">1</span>]) | <span class="number">0xFF000000</span>; <span class="comment">// 颜色</span></span><br><span class="line">                    <span class="keyword">float</span> textSize = Float.parseFloat(values[<span class="number">3</span>]); <span class="comment">// 字体大小</span></span><br><span class="line">                    <span class="comment">//使用弹幕工厂创建一条弹幕</span></span><br><span class="line">                    BaseDanmaku item = mContext.mDanmakuFactory.createDanmaku(type, mContext);</span><br><span class="line">                    <span class="keyword">if</span> (item != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        item.time = time;</span><br><span class="line">                        item.textSize = textSize * (mDispDensity - <span class="number">0.6f</span>);</span><br><span class="line">                        item.textColor = color;</span><br><span class="line">                        item.textShadowColor = color &lt;= Color.BLACK ? Color.WHITE : Color.BLACK;</span><br><span class="line">                        <span class="comment">//弹幕文字内容，如果多行文本会拆分内容</span></span><br><span class="line">                        DanmakuUtils.fillText(item, obj.optString(<span class="string">"m"</span>, <span class="string">"...."</span>));</span><br><span class="line">                        item.index = i;</span><br><span class="line">                        item.setTimer(mTimer);<span class="comment">//将定时器设置给每一条弹幕</span></span><br><span class="line">                        danmakus.addItem(item);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (JSONException e) &#123;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> danmakus;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//DanmakuUtilsdefillText方法，多行文本会拆分</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fillText</span><span class="params">(BaseDanmaku danmaku, CharSequence text)</span> </span>&#123;</span><br><span class="line">        danmaku.text = text;</span><br><span class="line">        <span class="comment">//如果文本没有换行符则不用拆分</span></span><br><span class="line">        <span class="keyword">if</span> (TextUtils.isEmpty(text) || !text.toString().contains(BaseDanmaku.DANMAKU_BR_CHAR)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//如果有换行符则拆分，然后将拆分的数组付给lines 属性</span></span><br><span class="line">        String[] lines = String.valueOf(danmaku.text).split(BaseDanmaku.DANMAKU_BR_CHAR, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (lines.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            danmaku.lines = lines;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;从JSONSource里解析每一条弹幕，接着我们看看弹幕工厂DanmakuFactory创建弹幕的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> BaseDanmaku <span class="title">createDanmaku</span><span class="params">(<span class="keyword">int</span> type, DanmakuContext context)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (context == <span class="keyword">null</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      sLastConfig = context;</span><br><span class="line">      sLastDisp = context.getDisplayer();</span><br><span class="line">      <span class="keyword">return</span> createDanmaku(type, sLastDisp.getWidth(), sLastDisp.getHeight(), CURRENT_DISP_SIZE_FACTOR, context.scrollSpeedFactor);<span class="comment">// go on overload method</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> BaseDanmaku <span class="title">createDanmaku</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">int</span> viewportWidth, <span class="keyword">int</span> viewportHeight,</span><br><span class="line">          <span class="keyword">float</span> viewportScale, <span class="keyword">float</span> scrollSpeedFactor)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> createDanmaku(type, (<span class="keyword">float</span>) viewportWidth, (<span class="keyword">float</span>) viewportHeight, viewportScale, scrollSpeedFactor);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> BaseDanmaku <span class="title">createDanmaku</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">float</span> viewportWidth, <span class="keyword">float</span> viewportHeight,</span><br><span class="line">          <span class="keyword">float</span> viewportSizeFactor, <span class="keyword">float</span> scrollSpeedFactor)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> oldDispWidth = CURRENT_DISP_WIDTH; <span class="comment">// 默认是0</span></span><br><span class="line">      <span class="keyword">int</span> oldDispHeight = CURRENT_DISP_HEIGHT; <span class="comment">// 默认是0</span></span><br><span class="line">      <span class="comment">//修正试图宽高，缩放比，弹幕时长</span></span><br><span class="line">      <span class="keyword">boolean</span> sizeChanged = updateViewportState(viewportWidth, viewportHeight, viewportSizeFactor);</span><br><span class="line">      <span class="comment">//滚动弹幕的Duration赋值</span></span><br><span class="line">      <span class="keyword">if</span> (MAX_Duration_Scroll_Danmaku == <span class="keyword">null</span>) &#123;</span><br><span class="line">          MAX_Duration_Scroll_Danmaku = <span class="keyword">new</span> Duration(REAL_DANMAKU_DURATION);</span><br><span class="line">          MAX_Duration_Scroll_Danmaku.setFactor(scrollSpeedFactor);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sizeChanged) &#123;</span><br><span class="line">          MAX_Duration_Scroll_Danmaku.setValue(REAL_DANMAKU_DURATION);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//固定位置弹幕的Duration赋值</span></span><br><span class="line">      <span class="keyword">if</span> (MAX_Duration_Fix_Danmaku == <span class="keyword">null</span>) &#123;</span><br><span class="line">          MAX_Duration_Fix_Danmaku = <span class="keyword">new</span> Duration(COMMON_DANMAKU_DURATION);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (sizeChanged &amp;&amp; viewportWidth &gt; <span class="number">0</span>) &#123;<span class="comment">// true &amp;&amp; true</span></span><br><span class="line">          updateMaxDanmakuDuration();<span class="comment">// 修正弹幕最长时长</span></span><br><span class="line">	......</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      BaseDanmaku instance = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// 从右往左滚动</span></span><br><span class="line">              instance = <span class="keyword">new</span> R2LDanmaku(MAX_Duration_Scroll_Danmaku);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">4</span>: <span class="comment">// 底端固定</span></span><br><span class="line">              instance = <span class="keyword">new</span> FBDanmaku(MAX_Duration_Fix_Danmaku);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">5</span>: <span class="comment">// 顶端固定</span></span><br><span class="line">              instance = <span class="keyword">new</span> FTDanmaku(MAX_Duration_Fix_Danmaku);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">6</span>: <span class="comment">// 从左往右滚动</span></span><br><span class="line">              instance = <span class="keyword">new</span> L2RDanmaku(MAX_Duration_Scroll_Danmaku);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">7</span>: <span class="comment">// 特殊弹幕</span></span><br><span class="line">              instance = <span class="keyword">new</span> SpecialDanmaku();</span><br><span class="line">              sSpecialDanmakus.addItem(instance);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//修正试图宽高，缩放比，弹幕时长</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">updateViewportState</span><span class="params">(<span class="keyword">float</span> viewportWidth, <span class="keyword">float</span> viewportHeight,</span><br><span class="line">          <span class="keyword">float</span> viewportSizeFactor)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">boolean</span> sizeChanged = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">if</span> (CURRENT_DISP_WIDTH != (<span class="keyword">int</span>) viewportWidth</span><br><span class="line">              || CURRENT_DISP_HEIGHT != (<span class="keyword">int</span>) viewportHeight</span><br><span class="line">              || CURRENT_DISP_SIZE_FACTOR != viewportSizeFactor) &#123;</span><br><span class="line">          sizeChanged = <span class="keyword">true</span>;</span><br><span class="line">          <span class="comment">//弹幕时长 t = 3800 * (1.2 * 视图宽 / 682)</span></span><br><span class="line">          REAL_DANMAKU_DURATION = (<span class="keyword">long</span>) (COMMON_DANMAKU_DURATION * (viewportSizeFactor</span><br><span class="line">                  * viewportWidth / BILI_PLAYER_WIDTH));</span><br><span class="line">          <span class="comment">// t = min(t, 9000)</span></span><br><span class="line">          REAL_DANMAKU_DURATION = Math.min(MAX_DANMAKU_DURATION_HIGH_DENSITY,</span><br><span class="line">                  REAL_DANMAKU_DURATION);</span><br><span class="line">          <span class="comment">// t = max(t, 4000)        </span></span><br><span class="line">          REAL_DANMAKU_DURATION = Math.max(MIN_DANMAKU_DURATION, REAL_DANMAKU_DURATION);</span><br><span class="line">          </span><br><span class="line">          CURRENT_DISP_WIDTH = (<span class="keyword">int</span>) viewportWidth;</span><br><span class="line">          CURRENT_DISP_HEIGHT = (<span class="keyword">int</span>) viewportHeight;</span><br><span class="line">          CURRENT_DISP_SIZE_FACTOR = viewportSizeFactor;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> sizeChanged;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//修正弹幕最长时长</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateMaxDanmakuDuration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">long</span> maxScrollDuration = (MAX_Duration_Scroll_Danmaku == <span class="keyword">null</span> ? <span class="number">0</span>: MAX_Duration_Scroll_Danmaku.value), </span><br><span class="line">            maxFixDuration = (MAX_Duration_Fix_Danmaku == <span class="keyword">null</span> ? <span class="number">0</span> : MAX_Duration_Fix_Danmaku.value), </span><br><span class="line">            maxSpecialDuration = (MAX_Duration_Special_Danmaku == <span class="keyword">null</span> ? <span class="number">0</span>: MAX_Duration_Special_Danmaku.value);</span><br><span class="line"></span><br><span class="line">      MAX_DANMAKU_DURATION = Math.max(maxScrollDuration, maxFixDuration);</span><br><span class="line">      MAX_DANMAKU_DURATION = Math.max(MAX_DANMAKU_DURATION, maxSpecialDuration);</span><br><span class="line"></span><br><span class="line">      MAX_DANMAKU_DURATION = Math.max(COMMON_DANMAKU_DURATION, MAX_DANMAKU_DURATION);</span><br><span class="line">      MAX_DANMAKU_DURATION = Math.max(REAL_DANMAKU_DURATION, MAX_DANMAKU_DURATION);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;DanmakuFactory创建弹幕主要是计算了弹幕时长，然后根据不同类型创建不同的弹幕。</p>
<p>&#160; &#160; &#160; &#160;到此CacheManagingDrawTask的loadDanmakus方法走完了。loadDanmakus方法主要从 mParser里的JSONSource解析弹幕数据源，根据不同类型的type用DanmakuFactory创建不同的Danmaku，分别计算Duration，最后存放到一个Danmakus对象里。</p>
<p>&#160; &#160; &#160; &#160; 继续回到刚才的prepare方法，往下继续执行:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">assert</span> (mParser != <span class="keyword">null</span>);</span><br><span class="line">     loadDanmakus(mParser);<span class="comment">//走完了</span></span><br><span class="line">     mCacheManager.begin();<span class="comment">//走这个</span></span><br><span class="line"> &#125;</span><br><span class="line">  <span class="comment">//CacheManager的方法</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         mEndFlag = <span class="keyword">false</span>;</span><br><span class="line">         <span class="comment">//创建一个HandlerThread用于在工作线程处理事务</span></span><br><span class="line">         <span class="keyword">if</span> (mThread == <span class="keyword">null</span>) &#123;</span><br><span class="line">             mThread = <span class="keyword">new</span> HandlerThread(<span class="string">"DFM Cache-Building Thread"</span>);</span><br><span class="line">             mThread.start();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//创建一个Handler和HandlerThread搭配用</span></span><br><span class="line">         <span class="keyword">if</span> (mHandler == <span class="keyword">null</span>)</span><br><span class="line">             mHandler = <span class="keyword">new</span> CacheHandler(mThread.getLooper());</span><br><span class="line">         mHandler.begin();<span class="comment">// 走到这里</span></span><br><span class="line">     &#125;</span><br><span class="line"><span class="comment">//HandlerThread的begin方法 </span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             sendEmptyMessage(PREPARE);</span><br><span class="line">	......</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;我们可以看到创建了一个HandlerThread，然后创建了一个CacheHandler，所以CacheHandler发送消息后，处理消息内容都是在子线程。<br>&#160; &#160; &#160; &#160;然后发送了PREPARE消息，然后就是回调handleMessage方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">     DrawingCachePoolManager mCachePoolManager = <span class="keyword">new</span> DrawingCachePoolManager();</span><br><span class="line">     <span class="comment">//创建一个缓存个数上限为800的FinitePool池</span></span><br><span class="line">        Pool&lt;DrawingCache&gt; mCachePool = Pools.finitePool(mCachePoolManager, <span class="number">800</span>);</span><br><span class="line">        <span class="comment">//Pools的finitePool方法</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Poolable&lt;T&gt;&gt; <span class="function">Pool&lt;T&gt; <span class="title">finitePool</span><span class="params">(PoolableManager&lt;T&gt; manager, <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FinitePool&lt;T&gt;(manager, limit);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//CacheHandler的handleMessage方法</span></span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">               <span class="keyword">int</span> what = msg.what;</span><br><span class="line">               <span class="keyword">switch</span> (what) &#123;</span><br><span class="line">                   <span class="keyword">case</span> PREPARE:</span><br><span class="line">                       evictAllNotInScreen();<span class="comment">//清除所有不在屏幕内的缓存，此时还没有缓存</span></span><br><span class="line">                       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">300</span>; i++) &#123;<span class="comment">//在池里放300个预留缓存，以链式存储方式存放</span></span><br><span class="line">                           mCachePool.release(<span class="keyword">new</span> DrawingCache());</span><br><span class="line">                       &#125;</span><br><span class="line"></span><br><span class="line">			......</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//FinitePool的release方法：回收缓存对象，并且用头插法，以链式存储（类似链表）	</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(T element)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (!element.isPooled()) &#123;</span><br><span class="line">           <span class="keyword">if</span> (mInfinite || mPoolCount &lt; mLimit) &#123;</span><br><span class="line">               mPoolCount++;</span><br><span class="line">               element.setNextPoolable(mRoot);</span><br><span class="line">               element.setPooled(<span class="keyword">true</span>);</span><br><span class="line">               mRoot = element;</span><br><span class="line">           &#125;</span><br><span class="line">           mManager.onReleased(element);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           System.out.print(<span class="string">"[FinitePool] Element is already in pool: "</span> + element);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;处理完PREPARE消息后，会继续进入DISPATCH_ACTIONS逻辑处理中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">	......</span><br><span class="line">          <span class="keyword">case</span> DISPATCH_ACTIONS:</span><br><span class="line">              <span class="keyword">long</span> delayed = dispatchAction();<span class="comment">//走到这里</span></span><br><span class="line">              <span class="keyword">if</span> (delayed &lt;= <span class="number">0</span>) &#123;<span class="comment">// true</span></span><br><span class="line">               <span class="comment">//会没隔半条弹幕时间发送一次DISPATCH_ACTIONS消息</span></span><br><span class="line">                  delayed = mContext.mDanmakuFactory.MAX_DANMAKU_DURATION / <span class="number">2</span>;</span><br><span class="line">              &#125;</span><br><span class="line">           sendEmptyMessageDelayed(DISPATCH_ACTIONS, delayed);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          ......</span><br><span class="line">    <span class="comment">/*----------dispatchAction方法START----------*/</span>        </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">dispatchAction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">...省略一些第一次不会执行的逻辑...</span><br><span class="line">            </span><br><span class="line">            removeMessages(BUILD_CACHES);</span><br><span class="line">            sendEmptyMessage(BUILD_CACHES);<span class="comment">//发送BUILD_CACHES消息</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*----------dispatchAction方法END----------*/</span></span><br><span class="line">          ......</span><br><span class="line">                <span class="keyword">case</span> BUILD_CACHES:</span><br><span class="line">                    removeMessages(BUILD_CACHES);</span><br><span class="line">                    <span class="keyword">boolean</span> repositioned = ((mTaskListener != <span class="keyword">null</span> </span><br><span class="line">                    &amp;&amp; mReadyState == <span class="keyword">false</span>) || mSeekedFlag);<span class="comment">// 为true</span></span><br><span class="line">                    prepareCaches(repositioned);<span class="comment">//调用prepareCaches方法</span></span><br><span class="line">                    <span class="keyword">if</span> (repositioned)</span><br><span class="line">                        mSeekedFlag = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (mTaskListener != <span class="keyword">null</span> &amp;&amp; mReadyState == <span class="keyword">false</span>) &#123;</span><br><span class="line">                        mTaskListener.ready();<span class="comment">//然后回到mTaskListener监听ready方法</span></span><br><span class="line">                        mReadyState = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                ......</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;我们发现，处理接着处理DISPATCH_ACTIONS消息时，会每隔半条弹幕时间发送一次DISPATCH_ACTIONS消息。<br>&#160; &#160; &#160; &#160;处理DISPATCH_ACTIONS消息内会执行dispatchAction方法，这个方法内逻辑情况比较多，我们先挖个坑，先把刚开始时会走的逻辑执行了，其他逻辑以后用时会填上。（挖坑 ^O_O^）<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/DanmakuFlameMaster%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/wakeng.jpg" alt="挖坑"><br>&#160; &#160; &#160; &#160;首次调用dispatchAction方法内发送了BUILD_CACHES消息消息，会先调用prepareCaches(true)方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">prepareCaches</span><span class="params">(<span class="keyword">boolean</span> repositioned)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">long</span> curr = mCacheTimer.currMillisecond;<span class="comment">// 0</span></span><br><span class="line">                <span class="comment">//3条弹幕时间</span></span><br><span class="line">                <span class="keyword">long</span> end = curr + mContext.mDanmakuFactory.MAX_DANMAKU_DURATION * mScreenSize;</span><br><span class="line">                <span class="keyword">if</span> (end &lt; mTimer.currMillisecond) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">long</span> startTime = SystemClock.uptimeMillis();</span><br><span class="line">                IDanmakus danmakus = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">int</span> tryCount = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">boolean</span> hasException = <span class="keyword">false</span>;</span><br><span class="line">                do &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">	                    <span class="comment">//截取三条弹幕时间中所有的弹幕</span></span><br><span class="line">                        danmakus = danmakuList.subnew(curr, end);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        hasException = <span class="keyword">true</span>;</span><br><span class="line">                        SystemClock.sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">while</span> (++tryCount &lt; <span class="number">3</span> &amp;&amp; danmakus == <span class="keyword">null</span> &amp;&amp; hasException);<span class="comment">//截取成功后跳出循环</span></span><br><span class="line">                <span class="keyword">if</span> (danmakus == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mCacheTimer.update(end);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">				......</span><br><span class="line">                IDanmakuIterator itr = danmakus.iterator();</span><br><span class="line">                BaseDanmaku item = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">int</span> sizeInScreen = danmakus.size();</span><br><span class="line">                <span class="keyword">while</span> (!mPause &amp;&amp; !mCancelFlag) &#123;<span class="comment">//</span></span><br><span class="line">                    <span class="keyword">boolean</span> hasNext = itr.hasNext();</span><br><span class="line">                    <span class="keyword">if</span> (!hasNext) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    item = itr.next();</span><br><span class="line"></span><br><span class="line">					 ......</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// build cache ，省略了一些障眼法,这才是重点，建立缓存</span></span><br><span class="line">                    <span class="keyword">if</span> (buildCache(item, <span class="keyword">false</span>) == RESULT_FAILED) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">					......</span><br><span class="line">                &#125;</span><br><span class="line">                ......</span><br><span class="line">                <span class="keyword">if</span> (item != <span class="keyword">null</span>) &#123;<span class="comment">//截取的最后一条弹幕,更新缓存定时器时间</span></span><br><span class="line">                    mCacheTimer.update(item.time);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mCacheTimer.update(end);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> consumingTime;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;为截取的每一条弹幕建立缓存会调用buildCache(item, false)方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">       <span class="function"><span class="keyword">private</span> <span class="keyword">byte</span> <span class="title">buildCache</span><span class="params">(BaseDanmaku item, <span class="keyword">boolean</span> forceInsert)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// measure ,先测量每一条弹幕的宽高</span></span><br><span class="line">           <span class="keyword">if</span> (!item.isMeasured()) &#123;</span><br><span class="line">               item.measure(mDisp, <span class="keyword">true</span>);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           DrawingCache cache = <span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// try to find reuseable cache, 在mCaches缓存的20条内查找和目标弹幕样式完全一样的弹幕(文字、大小、边框、下划线、颜色完全相同)</span></span><br><span class="line">               BaseDanmaku danmaku = findReuseableCache(item, <span class="keyword">true</span>, <span class="number">20</span>);</span><br><span class="line">               <span class="keyword">if</span> (danmaku != <span class="keyword">null</span>) &#123;<span class="comment">//如果查找出了这样的弹幕</span></span><br><span class="line">                   cache = (DrawingCache) danmaku.cache;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;<span class="comment">//如果找到的弹幕有缓存</span></span><br><span class="line">                   cache.increaseReference();<span class="comment">//则将引用计数 +1</span></span><br><span class="line">                   item.cache = cache;<span class="comment">//将目标弹幕缓存的引用指向查找出来的弹幕缓存，即多个引用指向同一个对象</span></span><br><span class="line">                   <span class="comment">//将这个目标弹幕的引用放入缓存Danmakus中(mCaches)，同时更新已使用大小mRealSize</span></span><br><span class="line">                   mCacheManager.push(item, <span class="number">0</span>, forceInsert);</span><br><span class="line">                   <span class="keyword">return</span> RESULT_SUCCESS;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// try to find reuseable cache from timeout || no-refrerence caches</span></span><br><span class="line">               <span class="comment">//如果上述的查找样式完全相同的弹幕没有找到，则在前50条缓存中查找对比当前时间已经过时的</span></span><br><span class="line">               <span class="comment">//，没有被重复引用的(只有上面那种情况才会增加引用计数，其他情况都不会)</span></span><br><span class="line">               <span class="comment">//，而且宽高和目标弹幕差值在规定范围内的弹幕</span></span><br><span class="line">               danmaku = findReuseableCache(item, <span class="keyword">false</span>, <span class="number">50</span>);</span><br><span class="line">               <span class="keyword">if</span> (danmaku != <span class="keyword">null</span>) &#123;<span class="comment">// 如果找到了这样的弹幕</span></span><br><span class="line">                   cache = (DrawingCache) danmaku.cache;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;<span class="comment">//如果找到的弹幕有缓存</span></span><br><span class="line">                   danmaku.cache = <span class="keyword">null</span>;<span class="comment">//先清除过时弹幕的缓存</span></span><br><span class="line">                   <span class="comment">//再根据目标弹幕样式，重新设置缓存(为每条弹幕创建一个bitmap和canvas，然后画出边框、下划线、文字等等)</span></span><br><span class="line">                   cache = DanmakuUtils.buildDanmakuDrawingCache(item, mDisp, cache);  <span class="comment">//redraw</span></span><br><span class="line">                   item.cache = cache;<span class="comment">//将缓存应用赋给目标弹幕</span></span><br><span class="line">                   mCacheManager.push(item, <span class="number">0</span>, forceInsert);<span class="comment">//将这个目标弹幕的引用放入缓存Danmakus中(mCaches)，同时更新已使用大小mRealSize</span></span><br><span class="line">                   <span class="keyword">return</span> RESULT_SUCCESS;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果上述两次查找缓存都没找到，则进入下面逻辑</span></span><br><span class="line">               <span class="comment">// guess cache size</span></span><br><span class="line">               <span class="keyword">if</span> (!forceInsert) &#123;<span class="comment">//如果forceInsert为false，则表示不检测内存超出</span></span><br><span class="line">                <span class="comment">//计算此弹幕bitmap的大小，width * height * 4</span></span><br><span class="line">                <span class="comment">//(因为用native创建的Bitmap的Config为ARGB_8888，所以一个像素占4个字节)</span></span><br><span class="line">                   <span class="keyword">int</span> cacheSize = DanmakuUtils.getCacheSize((<span class="keyword">int</span>) item.paintWidth,</span><br><span class="line">                           (<span class="keyword">int</span>) item.paintHeight);</span><br><span class="line">                   <span class="comment">//如果当前已经使用大小 + 此弹幕缓存大小 &gt; 设置的最大内存（2/3 应用内存）        </span></span><br><span class="line">                   <span class="keyword">if</span> (mRealSize + cacheSize &gt; mMaxSize) &#123;<span class="comment">//没有超</span></span><br><span class="line">                       <span class="keyword">return</span> RESULT_FAILED;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"><span class="comment">//从FinitePool中的300个DrawingCache对象中取出来一个</span></span><br><span class="line">               cache = mCachePool.acquire();</span><br><span class="line">               <span class="comment">//如果从上面的FinitePool取完了，则会直接new一个DrawingCache，配置DrawingCache</span></span><br><span class="line">               cache = DanmakuUtils.buildDanmakuDrawingCache(item, mDisp, cache);</span><br><span class="line">               item.cache = cache;</span><br><span class="line">               <span class="comment">//将item存入mCaches缓存，同时更新已使用大小mRealSize</span></span><br><span class="line">               <span class="keyword">boolean</span> pushed = mCacheManager.push(item, sizeOf(item), forceInsert);</span><br><span class="line">               <span class="keyword">if</span> (!pushed) &#123;<span class="comment">//如果item存放失败(使用内存超出规定大小)</span></span><br><span class="line">                   releaseDanmakuCache(item, cache);<span class="comment">//释放DrawingCache</span></span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">return</span> pushed ? RESULT_SUCCESS : RESULT_FAILED;</span><br><span class="line"></span><br><span class="line">           &#125; <span class="keyword">catch</span> (OutOfMemoryError e) &#123;</span><br><span class="line">               releaseDanmakuCache(item, cache);</span><br><span class="line">               <span class="keyword">return</span> RESULT_FAILED;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">               releaseDanmakuCache(item, cache);</span><br><span class="line">               <span class="keyword">return</span> RESULT_FAILED;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;buildCache(item, false)为每一条弹幕建立缓存，其中有几处：</p>
<ul>
<li>先测量弹幕的宽高</li>
<li>在mCaches缓存的20条内查找和目标弹幕样式完全一样的弹幕(文字、大小、边框、下划线、颜色完全相同)</li>
<li>如果上述的查找样式完全相同的弹幕没有找到，则在前50条缓存中查找对比当前时间已经过时的 ，没有被重复引用的(只有上面那种情况才会增加引用计数，其他情况都不会)，而且宽高和目标弹幕差值在规定范围内的弹幕，再根据目标弹幕样式，重新设置缓存(为每条弹幕创建一个bitmap和canvas，然后画出边框、下划线、文字等等)</li>
<li>如果上述两次查找缓存都没找到，则从FinitePool中取出一个，没有就new一个，然后同上配置DrawingCache</li>
</ul>
<p>&#160; &#160; &#160; &#160;1）我们一个一个来，先测量：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//弹幕的基类都是BaseDanmaku,只有子类R2LDanmaku重写了measure方法</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//R2LDanmaku的measure方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">measure</span><span class="params">(IDisplayer displayer, <span class="keyword">boolean</span> fromWorkerThread)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.measure(displayer, fromWorkerThread);<span class="comment">//调用了父类的方法</span></span><br><span class="line">        mDistance = (<span class="keyword">int</span>) (displayer.getWidth() + paintWidth);<span class="comment">//滚动弹幕的距离都是 视图宽度+弹幕宽度，很好理解</span></span><br><span class="line">        mStepX = mDistance / (<span class="keyword">float</span>) duration.value; <span class="comment">//每秒步长就是总滚动距离除以弹幕时长</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//父类BaseDanmaku的measure方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">measure</span><span class="params">(IDisplayer displayer, <span class="keyword">boolean</span> fromWorkerThread)</span> </span>&#123;</span><br><span class="line">        displayer.measure(<span class="keyword">this</span>, fromWorkerThread);<span class="comment">//AndroidDisplayer的measure方法</span></span><br><span class="line">        <span class="keyword">this</span>.measureResetFlag = flags.MEASURE_RESET_FLAG;<span class="comment">//设置已经测量过了的标签</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;接着会调用AndroidDisplayer的measure方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">measure</span><span class="params">(BaseDanmaku danmaku, <span class="keyword">boolean</span> fromWorkerThread)</span> </span>&#123;</span><br><span class="line">	...设置画笔style,color,alpha,省略...</span><br><span class="line">       calcPaintWH(danmaku, paint, fromWorkerThread);<span class="comment">//计算宽高</span></span><br><span class="line">	...设置画笔style,color,alpha,省略...</span><br><span class="line">   &#125;</span><br><span class="line"><span class="keyword">private</span> BaseCacheStuffer sStuffer = <span class="keyword">new</span> SimpleTextCacheStuffer();<span class="comment">//默认是SimpleTextCacheStuffer</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">calcPaintWH</span><span class="params">(BaseDanmaku danmaku, TextPaint paint, <span class="keyword">boolean</span> fromWorkerThread)</span> </span>&#123;</span><br><span class="line">       sStuffer.measure(danmaku, paint, fromWorkerThread);<span class="comment">//sStuffer就是我们在MainActivity里配置DanmakuContext时设置的，默认是SimpleTextCacheStuffer</span></span><br><span class="line">       </span><br><span class="line">       ...加上描边，padding等额外值，省略...</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;还记得在MainActivity里配置DanmakuContext吗？当时是这么写的：<br>                .setCacheStuffer(new SpannedCacheStuffer(), mCacheStufferAdapter) // 图文混排使用SpannedCacheStuffer<br>//              .setCacheStuffer(new BackgroundCacheStuffer())  // 绘制背景使用BackgroundCacheStuffer</p>
<p>&#160; &#160; &#160; &#160;比如SpannedCacheStuffer的measure方法是这样的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span><span class="comment">//SpannedCacheStuffer的measure方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">measure</span><span class="params">(BaseDanmaku danmaku, TextPaint paint, <span class="keyword">boolean</span> fromWorkerThread)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (danmaku.text <span class="keyword">instanceof</span> Spanned) &#123;</span><br><span class="line">          CharSequence text = danmaku.text;</span><br><span class="line">          <span class="keyword">if</span> (text != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">//可看到将弹幕的宽高，文字等信息包在了一个StaticLayout对象中，然后付给danmaku的obj对象</span></span><br><span class="line">              StaticLayout staticLayout = <span class="keyword">new</span> StaticLayout(text, paint, (<span class="keyword">int</span>) Math.ceil(StaticLayout.getDesiredWidth(danmaku.text, paint)), Layout.Alignment.ALIGN_NORMAL, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="keyword">true</span>);</span><br><span class="line">              danmaku.paintWidth = staticLayout.getWidth();</span><br><span class="line">              danmaku.paintHeight = staticLayout.getHeight();</span><br><span class="line">              danmaku.obj = <span class="keyword">new</span> SoftReference&lt;&gt;(staticLayout);</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">super</span>.measure(danmaku, paint, fromWorkerThread);<span class="comment">//如果不是图文混排类型，则调用父类SimpleTextCacheStuffer的方法</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;<strong>可以看到measure方法创建了一个StaticLayout对象，并将它的软引用赋给了danmaku的obj属性；如果是图文混排类型弹幕，则danmaku.obj不为空；如果是普通弹幕则danmaku.obj为空</strong>。<br>&#160; &#160; &#160; &#160;BackgroundCacheStuffer也差不多，都是对弹幕样式的一些改造。</p>
<p>&#160; &#160; &#160; &#160;然后我们看SimpleTextCacheStuffer的measure方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SimpleTextCacheStuffer的measure方法   </span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">measure</span><span class="params">(BaseDanmaku danmaku, TextPaint paint, <span class="keyword">boolean</span> fromWorkerThread)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (mProxy != <span class="keyword">null</span>) &#123;<span class="comment">//这个mProxy 是BaseCacheStuffer.Proxy类型的对象，也是初始化DanmakuContext调用setCacheStuffer(cacheStuffer, proxy)时设置的</span></span><br><span class="line">           mProxy.prepareDrawing(danmaku, fromWorkerThread);<span class="comment">//根据你的条件检查是否需要需要更新弹幕</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">float</span> w = <span class="number">0</span>;</span><br><span class="line">       Float textHeight = <span class="number">0f</span>;</span><br><span class="line">       <span class="keyword">if</span> (danmaku.lines == <span class="keyword">null</span>) &#123;<span class="comment">//不是多行文本</span></span><br><span class="line">           <span class="keyword">if</span> (danmaku.text == <span class="keyword">null</span>) &#123;</span><br><span class="line">               w = <span class="number">0</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               w = paint.measureText(danmaku.text.toString());<span class="comment">//测量出文字宽度</span></span><br><span class="line">               textHeight = getCacheHeight(danmaku, paint);<span class="comment">//计算出文字高度</span></span><br><span class="line">           &#125;</span><br><span class="line">           danmaku.paintWidth = w;</span><br><span class="line">           danmaku.paintHeight = textHeight;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果是多行文本</span></span><br><span class="line">           textHeight = getCacheHeight(danmaku, paint);<span class="comment">//计算出单行文字高度</span></span><br><span class="line">           <span class="keyword">for</span> (String tempStr : danmaku.lines) &#123;<span class="comment">//计算出多行文本总宽高</span></span><br><span class="line">               <span class="keyword">if</span> (tempStr.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                   <span class="keyword">float</span> tr = paint.measureText(tempStr);</span><br><span class="line">                   w = Math.max(tr, w);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           danmaku.paintWidth = w;</span><br><span class="line">           danmaku.paintHeight = danmaku.lines.length * textHeight;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Map&lt;Float, Float&gt; sTextHeightCache = <span class="keyword">new</span> HashMap&lt;Float, Float&gt;();<span class="comment">//key是字号大小，value是字体高度</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> Float <span class="title">getCacheHeight</span><span class="params">(BaseDanmaku danmaku, Paint paint)</span> </span>&#123;</span><br><span class="line">       Float textSize = paint.getTextSize();</span><br><span class="line">       Float textHeight = sTextHeightCache.get(textSize);</span><br><span class="line">       <span class="keyword">if</span> (textHeight == <span class="keyword">null</span>) &#123;</span><br><span class="line">           Paint.FontMetrics fontMetrics = paint.getFontMetrics();</span><br><span class="line">           <span class="comment">//Android对文字绘制有些特殊，基准点是baseline，也就是例如canvas.drawText(text, baseX, baseY, textPaint)中写入的baseY大小</span></span><br><span class="line">           <span class="comment">//Ascent是baseline之上字符最高处的y值；</span></span><br><span class="line">		<span class="comment">//Descent是baseline之下字符最低处的y值；</span></span><br><span class="line">		<span class="comment">//Leading其实是上一行字符的descent到下一行的ascent之间的距离。</span></span><br><span class="line">		<span class="comment">//所以文本高度就是descent - ascent + leading </span></span><br><span class="line">           textHeight = fontMetrics.descent - fontMetrics.ascent + fontMetrics.leading;</span><br><span class="line">           sTextHeightCache.put(textSize, textHeight);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> textHeight;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这样就计算完了每一条弹幕的宽高，完成了测量。</p>
<p>&#160; &#160; &#160; &#160;2） 在mCaches缓存的20条内查找和目标弹幕样式完全一样的弹幕(文字、大小、边框、下划线、颜色完全相同)：<br>&#160; &#160; &#160; &#160;先回到buildCache方法中这个位置。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">byte</span> <span class="title">buildCache</span><span class="params">(BaseDanmaku item, <span class="keyword">boolean</span> forceInsert)</span> </span>&#123;<span class="comment">//item, false</span></span><br><span class="line"></span><br><span class="line">	...测量已经完成...</span><br><span class="line">             DrawingCache cache = <span class="keyword">null</span>;</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 <span class="comment">// try to find reuseable cache, 在mCaches缓存的20条内查找和目标弹幕样式完全一样的弹幕(文字、大小、边框、下划线、颜色完全相同)</span></span><br><span class="line">                 BaseDanmaku danmaku = findReuseableCache(item, <span class="keyword">true</span>, <span class="number">20</span>);</span><br><span class="line">                 <span class="keyword">if</span> (danmaku != <span class="keyword">null</span>) &#123;<span class="comment">//如果查找出了这样的弹幕</span></span><br><span class="line">                     cache = (DrawingCache) danmaku.cache;</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;<span class="comment">//如果找到的弹幕有缓存</span></span><br><span class="line">                     cache.increaseReference();<span class="comment">//则将引用计数 +1</span></span><br><span class="line">                     item.cache = cache;<span class="comment">//将目标弹幕缓存的引用指向查找出来的弹幕缓存，即多个引用指向同一个对象</span></span><br><span class="line">                     <span class="comment">//将这个目标弹幕的引用放入缓存Danmakus中(mCaches)，同时更新已使用大小mRealSize</span></span><br><span class="line">                     mCacheManager.push(item, <span class="number">0</span>, forceInsert);</span><br><span class="line">                     <span class="keyword">return</span> RESULT_SUCCESS;</span><br><span class="line">                 &#125;</span><br><span class="line">             ......    </span><br><span class="line">   &#125; </span><br><span class="line">     <span class="comment">//在mCaches缓存的20条内查找和目标弹幕样式完全一样的弹幕(文字、大小、边框、下划线、颜色完全相同)             </span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> BaseDanmaku <span class="title">findReuseableCache</span><span class="params">(BaseDanmaku refDanmaku,</span><br><span class="line">                                            <span class="keyword">boolean</span> strictMode,</span><br><span class="line">                                            <span class="keyword">int</span> maximumTimes)</span> </span>&#123;<span class="comment">//item， true， 20</span></span><br><span class="line">         IDanmakuIterator it = mCaches.iterator();</span><br><span class="line">......</span><br><span class="line">         <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">while</span> (it.hasNext() &amp;&amp; count++ &lt; maximumTimes) &#123;  <span class="comment">// limit maximum times 20</span></span><br><span class="line">             BaseDanmaku danmaku = it.next();</span><br><span class="line">             IDrawingCache&lt;?&gt; cache = danmaku.getDrawingCache();</span><br><span class="line">             <span class="keyword">if</span> (cache == <span class="keyword">null</span> || cache.get() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                 <span class="keyword">continue</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">//对比mCaches中的弹幕和目标的内幕文字、大小、边框、下划线、颜色是否完全相同</span></span><br><span class="line">             <span class="keyword">if</span> (danmaku.paintWidth == refDanmaku.paintWidth</span><br><span class="line">                     &amp;&amp; danmaku.paintHeight == refDanmaku.paintHeight</span><br><span class="line">                     &amp;&amp; danmaku.underlineColor == refDanmaku.underlineColor</span><br><span class="line">                     &amp;&amp; danmaku.borderColor == refDanmaku.borderColor</span><br><span class="line">                     &amp;&amp; danmaku.textColor == refDanmaku.textColor</span><br><span class="line">                     &amp;&amp; danmaku.text.equals(refDanmaku.text)) &#123;</span><br><span class="line">                 <span class="keyword">return</span> danmaku;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span> (strictMode) &#123;<span class="comment">//true</span></span><br><span class="line">                 <span class="keyword">continue</span>;</span><br><span class="line">             &#125;</span><br><span class="line">	......</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//CacheManagingDrawTask.CacheManager的push方法</span></span><br><span class="line">     <span class="comment">//将这个目标弹幕的引用放入缓存Danmakus中(mCaches)，同时更新已使用大小mRealSize</span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">push</span><span class="params">(BaseDanmaku item, <span class="keyword">int</span> itemSize, <span class="keyword">boolean</span> forcePush)</span> </span>&#123;<span class="comment">//item，0，false</span></span><br><span class="line">         <span class="keyword">int</span> size = itemSize; <span class="comment">//0</span></span><br><span class="line">......</span><br><span class="line"><span class="comment">//这里注意mCaches是Danmakus类型，addItem方法里面实现其实是类型为TreeSet的集合去添加，如果是同一个对象，则不会添加</span></span><br><span class="line">         <span class="keyword">this</span>.mCaches.addItem(item);</span><br><span class="line">         mRealSize += size;<span class="comment">//因为已经存在相同的缓存，因此已经使用缓存总大小不再增加</span></span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> <span class="comment">//Danmakus的addItem方法</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addItem</span><span class="params">(BaseDanmaku item)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (items != <span class="keyword">null</span>) &#123;<span class="comment">//items 类型为TreeSet</span></span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="keyword">if</span> (items.add(item)) &#123;<span class="comment">//如果是相同对象，则返回false，mSize个数不会增加</span></span><br><span class="line">                 mSize++;</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;上述情况仅仅在相同样式，大小，颜色等都相同的弹幕第二次和以后的才会进入这段逻辑。对于不同的弹幕不会进入这个逻辑。（<strong>而且即使是相同弹幕，mCaches也只会存一个对象的，因为内部TreeSet的特性</strong>）<br>&#160; &#160; &#160; &#160;所以我们继续看下一种逻辑。</p>
<p>&#160; &#160; &#160; &#160;3）在前50条缓存中查找对比当前时间已经过时的 ，没有被重复引用的(只有上面那种情况才会增加引用计数，其他情况都不会)，而且宽高和目标弹幕差值在规定范围内的弹幕，再根据目标弹幕样式，重新设置缓存(为每条弹幕创建一个bitmap和canvas，然后画出边框、下划线、文字等等)：<br>&#160; &#160; &#160; &#160;继续回到buildCache方法这个位置：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">byte</span> <span class="title">buildCache</span><span class="params">(BaseDanmaku item, <span class="keyword">boolean</span> forceInsert)</span> </span>&#123;<span class="comment">//item, false</span></span><br><span class="line">		...测量过了...</span><br><span class="line">		...第一策略已经pass...</span><br><span class="line">			<span class="comment">// try to find reuseable cache from timeout || no-refrerence caches</span></span><br><span class="line">                  <span class="comment">//如果上述的查找样式完全相同的弹幕没有找到，则在前50条缓存中查找对比当前时间已经过时的</span></span><br><span class="line">                  <span class="comment">//，没有被重复引用的(只有上面那种情况才会增加引用计数，其他情况都不会)</span></span><br><span class="line">                  <span class="comment">//，而且宽高和目标弹幕差值在规定范围内的弹幕</span></span><br><span class="line">                  danmaku = findReuseableCache(item, <span class="keyword">false</span>, <span class="number">50</span>);</span><br><span class="line">                  <span class="keyword">if</span> (danmaku != <span class="keyword">null</span>) &#123;<span class="comment">// 如果找到了这样的弹幕</span></span><br><span class="line">                      cache = (DrawingCache) danmaku.cache;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;<span class="comment">//如果找到的弹幕有缓存</span></span><br><span class="line">                      danmaku.cache = <span class="keyword">null</span>;<span class="comment">//先清除过时弹幕的缓存</span></span><br><span class="line">                      <span class="comment">//再根据目标弹幕样式，重新设置缓存(为每条弹幕创建一个bitmap和canvas，然后画出边框、下划线、文字等等)</span></span><br><span class="line">                      cache = DanmakuUtils.buildDanmakuDrawingCache(item, mDisp, cache);  <span class="comment">//redraw</span></span><br><span class="line">                      item.cache = cache;<span class="comment">//将缓存应用赋给目标弹幕</span></span><br><span class="line">                      mCacheManager.push(item, <span class="number">0</span>, forceInsert);<span class="comment">//将这个目标弹幕的引用放入缓存Danmakus中(mCaches)，同时更新已使用大小mRealSize</span></span><br><span class="line">                      <span class="keyword">return</span> RESULT_SUCCESS;</span><br><span class="line">                  &#125;</span><br><span class="line">              ......    </span><br><span class="line">&#125;</span><br><span class="line">      <span class="function"><span class="keyword">private</span> BaseDanmaku <span class="title">findReuseableCache</span><span class="params">(BaseDanmaku refDanmaku,</span><br><span class="line">                                             <span class="keyword">boolean</span> strictMode,</span><br><span class="line">                                             <span class="keyword">int</span> maximumTimes)</span> </span>&#123;<span class="comment">//item,false,50</span></span><br><span class="line">          IDanmakuIterator it = mCaches.iterator();</span><br><span class="line">          <span class="keyword">int</span> slopPixel = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">if</span> (!strictMode) &#123;<span class="comment">//进入逻辑，非严苛模式</span></span><br><span class="line">              slopPixel = mDisp.getSlopPixel() * <span class="number">2</span>;<span class="comment">//允许目标弹幕与mCaches中找到的弹幕宽高偏差</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">while</span> (it.hasNext() &amp;&amp; count++ &lt; maximumTimes) &#123;  <span class="comment">// limit maximum times 20</span></span><br><span class="line">              BaseDanmaku danmaku = it.next();</span><br><span class="line">              IDrawingCache&lt;?&gt; cache = danmaku.getDrawingCache();</span><br><span class="line">              <span class="keyword">if</span> (cache == <span class="keyword">null</span> || cache.get() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  <span class="keyword">continue</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">//在这种第二策略中这段逻辑根本不会执行，因为以已经被上面的第一策略拦截了</span></span><br><span class="line">              <span class="keyword">if</span> (danmaku.paintWidth == refDanmaku.paintWidth</span><br><span class="line">                      &amp;&amp; danmaku.paintHeight == refDanmaku.paintHeight</span><br><span class="line">                      &amp;&amp; danmaku.underlineColor == refDanmaku.underlineColor</span><br><span class="line">                      &amp;&amp; danmaku.borderColor == refDanmaku.borderColor</span><br><span class="line">                      &amp;&amp; danmaku.textColor == refDanmaku.textColor</span><br><span class="line">                      &amp;&amp; danmaku.text.equals(refDanmaku.text)) &#123;</span><br><span class="line">                  <span class="keyword">return</span> danmaku;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (strictMode) &#123;<span class="comment">//false</span></span><br><span class="line">                  <span class="keyword">continue</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (!danmaku.isTimeOut()) &#123;<span class="comment">//还必须在mCaches中过时的弹幕中查找</span></span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (cache.hasReferences()) &#123;<span class="comment">//如果是相同弹幕被重新引用的，第二策略没有这样的</span></span><br><span class="line">                  <span class="keyword">continue</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">//所以会走到这里，比较mCaches中过时的弹幕和目标弹幕宽高在不在允许的偏差内，如果在就返回查找出的这个弹幕</span></span><br><span class="line">              <span class="keyword">float</span> widthGap = cache.width() - refDanmaku.paintWidth;</span><br><span class="line">              <span class="keyword">float</span> heightGap = cache.height() - refDanmaku.paintHeight;</span><br><span class="line">              <span class="keyword">if</span> (widthGap &gt;= <span class="number">0</span> &amp;&amp; widthGap &lt;= slopPixel &amp;&amp;</span><br><span class="line">                      heightGap &gt;= <span class="number">0</span> &amp;&amp; heightGap &lt;= slopPixel) &#123;</span><br><span class="line">                  <span class="keyword">return</span> danmaku;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;如果在上述第二策略中，在过时的缓存中找到了和目标弹幕宽高差不多的缓存项，则根据目标弹幕样式，重新设置缓存(为每条弹幕创建一个bitmap和canvas，然后画出边框、下划线、文字等等)，调用DanmakuUtils.buildDanmakuDrawingCache(item, mDisp, cache)方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DrawingCache <span class="title">buildDanmakuDrawingCache</span><span class="params">(BaseDanmaku danmaku, IDisplayer disp,</span><br><span class="line">          DrawingCache cache)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (cache == <span class="keyword">null</span>)</span><br><span class="line">          cache = <span class="keyword">new</span> DrawingCache();</span><br><span class="line"><span class="comment">//组建弹幕缓存(bitmap,canvas)</span></span><br><span class="line">      cache.build((<span class="keyword">int</span>) Math.ceil(danmaku.paintWidth), (<span class="keyword">int</span>) Math.ceil(danmaku.paintHeight), disp.getDensityDpi(), <span class="keyword">false</span>);</span><br><span class="line">      DrawingCacheHolder holder = cache.get();</span><br><span class="line">      <span class="keyword">if</span> (holder != <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="comment">//绘制弹幕内容</span></span><br><span class="line">          ((AbsDisplayer) disp).drawDanmaku(danmaku, holder.canvas, <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">true</span>);</span><br><span class="line">          <span class="keyword">if</span>(disp.isHardwareAccelerated()) &#123;<span class="comment">//如果有硬件加速</span></span><br><span class="line">           <span class="comment">//超过一屏的弹幕要切割</span></span><br><span class="line">              holder.splitWith(disp.getWidth(), disp.getHeight(), disp.getMaximumCacheWidth(),</span><br><span class="line">                      disp.getMaximumCacheHeight());</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> cache;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;重新设置缓存分三步：1.组建弹幕缓存,2.绘制弹幕内容,3.切割超过一屏的弹幕。</p>
<p>&#160; &#160; &#160; &#160;No.1 组建弹幕缓存：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DrawingCache的build方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> density, <span class="keyword">boolean</span> checkSizeEquals)</span> </span>&#123;<span class="comment">//checkSizeEquals为false</span></span><br><span class="line">       <span class="keyword">final</span> DrawingCacheHolder holder = mHolder;</span><br><span class="line">       <span class="comment">//每个DrawingCache都有一个DrawingCacheHolder</span></span><br><span class="line">       holder.buildCache(w, h, density, checkSizeEquals);<span class="comment">//DrawingCacheHolder的buildCache方法</span></span><br><span class="line">       mSize = mHolder.bitmap.getRowBytes() * mHolder.bitmap.getHeight();<span class="comment">//返回创建的bitmap的大小</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//DrawingCacheHolder的buildCache方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildCache</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> density, <span class="keyword">boolean</span> checkSizeEquals)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">boolean</span> reuse = checkSizeEquals ? (w == width &amp;&amp; h == height) : (w &lt;= width &amp;&amp; h &lt;= height);<span class="comment">//检测大小 ？ 宽高相等 ： 小于已经缓存的bitmap宽高</span></span><br><span class="line">       <span class="keyword">if</span> (reuse &amp;&amp; bitmap != <span class="keyword">null</span>) &#123;<span class="comment">//如果能够复用bitmap</span></span><br><span class="line">           bitmap.eraseColor(Color.TRANSPARENT);<span class="comment">//擦出之前的颜色</span></span><br><span class="line">           canvas.setBitmap(bitmap);<span class="comment">//给Canvas重新预设bitmap</span></span><br><span class="line">           recycleBitmapArray();<span class="comment">//回收超过一屏弹幕切割后的bitmap数组，这个接下来会讲</span></span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (bitmap != <span class="keyword">null</span>) &#123;<span class="comment">//如果不能复用，则回收旧的缓存bitmap</span></span><br><span class="line">           recycle();</span><br><span class="line">       &#125;</span><br><span class="line">       width = w;</span><br><span class="line">       height = h;</span><br><span class="line">       bitmap = NativeBitmapFactory.createBitmap(w, h, Bitmap.Config.ARGB_8888);<span class="comment">//用native方法创建一个bitmap</span></span><br><span class="line">       <span class="keyword">if</span> (density &gt; <span class="number">0</span>) &#123;<span class="comment">//设置density</span></span><br><span class="line">           mDensity = density;</span><br><span class="line">           bitmap.setDensity(density);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//设置canvas</span></span><br><span class="line">       <span class="keyword">if</span> (canvas == <span class="keyword">null</span>)&#123;</span><br><span class="line">           canvas = <span class="keyword">new</span> Canvas(bitmap);</span><br><span class="line">           canvas.setDensity(density);</span><br><span class="line">       &#125;<span class="keyword">else</span></span><br><span class="line">           canvas.setBitmap(bitmap);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;组建弹幕缓存就是为个DrawingCache根据目标弹幕大小创建bitmap和canvas。</p>
<p>&#160; &#160; &#160; &#160;No.2 绘制弹幕内容：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">drawDanmaku</span><span class="params">(BaseDanmaku danmaku, Canvas canvas, </span><br><span class="line">  <span class="keyword">float</span> left, <span class="keyword">float</span> top, <span class="keyword">boolean</span> fromWorkerThread)</span> </span>&#123;<span class="comment">//danmaku, holder.canvas, 0, 0, true</span></span><br><span class="line">      <span class="keyword">float</span> _left = left;</span><br><span class="line">      <span class="keyword">float</span> _top = top;</span><br><span class="line">      </span><br><span class="line">...一些杂项，忽略...</span><br><span class="line"></span><br><span class="line">      TextPaint paint = getPaint(danmaku, fromWorkerThread);<span class="comment">//获取画笔</span></span><br><span class="line">      <span class="comment">//绘制背景，sStuffer可以自己设置，默认是SimpleTextCacheStuffer,默认drawBackground为空</span></span><br><span class="line">      <span class="comment">//这个可以自己扩展，上面讲过</span></span><br><span class="line">      sStuffer.drawBackground(danmaku, canvas, _left, _top);</span><br><span class="line">      <span class="keyword">if</span> (danmaku.lines != <span class="keyword">null</span>) &#123;<span class="comment">//如果是多行文本</span></span><br><span class="line">          String[] lines = danmaku.lines;</span><br><span class="line">          <span class="keyword">if</span> (lines.length == <span class="number">1</span>) &#123;<span class="comment">//多行文本行数为1</span></span><br><span class="line">              <span class="keyword">if</span> (hasStroke(danmaku)) &#123;<span class="comment">//如果有描边，则绘制描边</span></span><br><span class="line">               <span class="comment">//重设画笔（绘制描边）</span></span><br><span class="line">                  applyPaintConfig(danmaku, paint, <span class="keyword">true</span>);</span><br><span class="line">                  <span class="keyword">float</span> strokeLeft = left;</span><br><span class="line">                  <span class="keyword">float</span> strokeTop = top - paint.ascent();</span><br><span class="line">                  ......</span><br><span class="line">                  <span class="comment">//绘制描边</span></span><br><span class="line">                  sStuffer.drawStroke(danmaku, lines[<span class="number">0</span>], canvas, strokeLeft, strokeTop, paint);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">//再次重设画笔（绘制文字）</span></span><br><span class="line">              applyPaintConfig(danmaku, paint, <span class="keyword">false</span>);</span><br><span class="line">              <span class="comment">//绘制文字</span></span><br><span class="line">              sStuffer.drawText(danmaku, lines[<span class="number">0</span>], canvas, left, top - paint.ascent(), paint, fromWorkerThread);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;<span class="comment">//多行文本行数大于1</span></span><br><span class="line">           <span class="comment">//先计算每行文本的高度</span></span><br><span class="line">              <span class="keyword">float</span> textHeight = (danmaku.paintHeight - <span class="number">2</span> * danmaku.padding) / lines.length;</span><br><span class="line">              <span class="comment">//循环绘制每一行文本</span></span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; lines.length; t++) &#123;</span><br><span class="line">                  ......</span><br><span class="line">                  <span class="keyword">if</span> (hasStroke(danmaku)) &#123;<span class="comment">//如果有描边，则绘制描边</span></span><br><span class="line">                   <span class="comment">//重设画笔（绘制描边）</span></span><br><span class="line">                      applyPaintConfig(danmaku, paint, <span class="keyword">true</span>);</span><br><span class="line">                      <span class="keyword">float</span> strokeLeft = left;</span><br><span class="line">                      <span class="keyword">float</span> strokeTop = t * textHeight + top - paint.ascent();</span><br><span class="line">				......</span><br><span class="line">                      <span class="comment">//绘制描边</span></span><br><span class="line">                      sStuffer.drawStroke(danmaku, lines[t], canvas, strokeLeft, strokeTop, paint);</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="comment">//再次重设画笔（绘制文字）</span></span><br><span class="line">                  applyPaintConfig(danmaku, paint, <span class="keyword">false</span>);</span><br><span class="line">                  <span class="comment">//绘制文字</span></span><br><span class="line">                  sStuffer.drawText(danmaku, lines[t], canvas, left, t * textHeight + top - paint.ascent(), paint, fromWorkerThread);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果是单行文本</span></span><br><span class="line">          <span class="keyword">if</span> (hasStroke(danmaku)) &#123;<span class="comment">//如果有描边，则绘制描边</span></span><br><span class="line">           <span class="comment">//重设画笔（绘制描边）</span></span><br><span class="line">              applyPaintConfig(danmaku, paint, <span class="keyword">true</span>);</span><br><span class="line">              <span class="keyword">float</span> strokeLeft = left;</span><br><span class="line">              <span class="keyword">float</span> strokeTop = top - paint.ascent();</span><br><span class="line">		......</span><br><span class="line">              <span class="comment">//绘制描边</span></span><br><span class="line">              sStuffer.drawStroke(danmaku, <span class="keyword">null</span>, canvas, strokeLeft, strokeTop, paint);</span><br><span class="line">          &#125;</span><br><span class="line">	<span class="comment">//再次重设画笔（绘制文字）</span></span><br><span class="line">          applyPaintConfig(danmaku, paint, <span class="keyword">false</span>);</span><br><span class="line">          <span class="comment">//绘制文字</span></span><br><span class="line">          sStuffer.drawText(danmaku, <span class="keyword">null</span>, canvas, left, top - paint.ascent(), paint, fromWorkerThread);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// draw underline</span></span><br><span class="line">      <span class="keyword">if</span> (danmaku.underlineColor != <span class="number">0</span>) &#123;<span class="comment">//绘制下划线（if）</span></span><br><span class="line">          Paint linePaint = getUnderlinePaint(danmaku);</span><br><span class="line">          <span class="keyword">float</span> bottom = _top + danmaku.paintHeight - UNDERLINE_HEIGHT;</span><br><span class="line">          canvas.drawLine(_left, bottom, _left + danmaku.paintWidth, bottom, linePaint);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//draw border</span></span><br><span class="line">      <span class="keyword">if</span> (danmaku.borderColor != <span class="number">0</span>) &#123;<span class="comment">//绘制外框</span></span><br><span class="line">          Paint borderPaint = getBorderPaint(danmaku);</span><br><span class="line">          canvas.drawRect(_left, _top, _left + danmaku.paintWidth, _top + danmaku.paintHeight,</span><br><span class="line">                  borderPaint);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//设置画笔</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">applyPaintConfig</span><span class="params">(BaseDanmaku danmaku, Paint paint, <span class="keyword">boolean</span> stroke)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	......</span><br><span class="line">          <span class="keyword">if</span> (stroke) &#123;</span><br><span class="line">              paint.setStyle(HAS_PROJECTION ? Style.FILL : Style.STROKE);</span><br><span class="line">              paint.setColor(danmaku.textShadowColor &amp; <span class="number">0x00FFFFFF</span>);</span><br><span class="line">              <span class="keyword">int</span> alpha = HAS_PROJECTION ? sProjectionAlpha : AlphaValue.MAX;</span><br><span class="line">              paint.setAlpha(alpha);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              paint.setStyle(Style.FILL);</span><br><span class="line">              paint.setColor(danmaku.textColor &amp; <span class="number">0x00FFFFFF</span>);</span><br><span class="line">              paint.setAlpha(AlphaValue.MAX);</span><br><span class="line">          &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;上述就是绘制弹幕内容过程，主要就是sStuffer的drawStroke，drawText方法。如果你在DanmakuContext中没有设置CacheStuffer，则上述drawDanmaku方法中的sStuffer为默认的SimpleTextCacheStuffer。<br>&#160; &#160; &#160; &#160;drawStroke方法及其扩展都一样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SimpleTextCacheStuffer的drawStroke方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawStroke</span><span class="params">(BaseDanmaku danmaku, String lineText, Canvas canvas, <span class="keyword">float</span> left, <span class="keyword">float</span> top, Paint paint)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (lineText != <span class="keyword">null</span>) &#123;</span><br><span class="line">           canvas.drawText(lineText, left, top, paint);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           canvas.drawText(danmaku.text.toString(), left, top, paint);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;我们设了SpannedCacheStuffer, drawText方法有些区别：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SimpleTextCacheStuffer的drawText方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawText</span><span class="params">(BaseDanmaku danmaku, String lineText, Canvas canvas, <span class="keyword">float</span> left, <span class="keyword">float</span> top, TextPaint paint, <span class="keyword">boolean</span> fromWorkerThread)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (lineText != <span class="keyword">null</span>) &#123;</span><br><span class="line">           canvas.drawText(lineText, left, top, paint);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           canvas.drawText(danmaku.text.toString(), left, top, paint);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//SpannedCacheStuffer的drawText方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawText</span><span class="params">(BaseDanmaku danmaku, String lineText, Canvas canvas, <span class="keyword">float</span> left, <span class="keyword">float</span> top, TextPaint paint, <span class="keyword">boolean</span> fromWorkerThread)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (danmaku.obj == <span class="keyword">null</span>) &#123;<span class="comment">//普通弹幕</span></span><br><span class="line">           <span class="keyword">super</span>.drawText(danmaku, lineText, canvas, left, top, paint, fromWorkerThread);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果是图文混排弹幕</span></span><br><span class="line">       SoftReference&lt;StaticLayout&gt; reference = (SoftReference&lt;StaticLayout&gt;) danmaku.obj;</span><br><span class="line">       StaticLayout staticLayout = reference.get();</span><br><span class="line">       <span class="comment">//按位与，判断标志位是否有效。这里判断是否请求重新测量</span></span><br><span class="line">       <span class="keyword">boolean</span> requestRemeasure = <span class="number">0</span> != (danmaku.requestFlags &amp; BaseDanmaku.FLAG_REQUEST_REMEASURE);</span><br><span class="line">       <span class="comment">//判断是否请求重绘</span></span><br><span class="line">       <span class="keyword">boolean</span> requestInvalidate = <span class="number">0</span> != (danmaku.requestFlags &amp; BaseDanmaku.FLAG_REQUEST_INVALIDATE);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (requestInvalidate || staticLayout == <span class="keyword">null</span>) &#123;<span class="comment">//如果请求重绘或者staticLayout 软引用被回收了</span></span><br><span class="line">           <span class="keyword">if</span> (requestInvalidate) &#123;</span><br><span class="line">            <span class="comment">//与非操作，清除标志位。清除请求重绘标志位</span></span><br><span class="line">               danmaku.requestFlags &amp;= ~BaseDanmaku.FLAG_REQUEST_INVALIDATE;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mProxy != <span class="keyword">null</span>) &#123;<span class="comment">//这个在设置DanmakuContext时设置，上面讲过，可以自己扩展</span></span><br><span class="line">               mProxy.prepareDrawing(danmaku, fromWorkerThread);</span><br><span class="line">           &#125;</span><br><span class="line">           CharSequence text = danmaku.text;</span><br><span class="line">           <span class="keyword">if</span> (text != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (requestRemeasure) &#123;<span class="comment">//重新测量</span></span><br><span class="line">                   staticLayout = <span class="keyword">new</span> StaticLayout(text, paint, (<span class="keyword">int</span>) Math.ceil(StaticLayout.getDesiredWidth(danmaku.text, paint)), Layout.Alignment.ALIGN_NORMAL, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="keyword">true</span>);</span><br><span class="line">                   danmaku.paintWidth = staticLayout.getWidth();</span><br><span class="line">                   danmaku.paintHeight = staticLayout.getHeight();</span><br><span class="line">                   danmaku.requestFlags &amp;= ~BaseDanmaku.FLAG_REQUEST_REMEASURE;<span class="comment">//清除标志位</span></span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;<span class="comment">//不用重新测量</span></span><br><span class="line">                   staticLayout = <span class="keyword">new</span> StaticLayout(text, paint, (<span class="keyword">int</span>) danmaku.paintWidth, Layout.Alignment.ALIGN_NORMAL, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="keyword">true</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               danmaku.obj = <span class="keyword">new</span> SoftReference&lt;&gt;(staticLayout);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//staticLayout可以继续用</span></span><br><span class="line">       <span class="keyword">boolean</span> needRestore = <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">if</span> (left != <span class="number">0</span> &amp;&amp; top != <span class="number">0</span>) &#123;</span><br><span class="line">           canvas.save();</span><br><span class="line">           canvas.translate(left, top + paint.ascent());</span><br><span class="line">           needRestore = <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//绘制弹幕内容</span></span><br><span class="line">       staticLayout.draw(canvas);</span><br><span class="line">       <span class="keyword">if</span> (needRestore) &#123;</span><br><span class="line">           canvas.restore();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;绘制弹幕内容就完了，主要是绘制描边，绘制文字，绘制下划线，边框等等。</p>
<p>&#160; &#160; &#160; &#160;No.3 切割超过一屏的弹幕：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DrawingCacheHolder的splitWith方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">splitWith</span><span class="params">(<span class="keyword">int</span> dispWidth, <span class="keyword">int</span> dispHeight, <span class="keyword">int</span> maximumCacheWidth, <span class="keyword">int</span> maximumCacheHeight)</span> </span>&#123;</span><br><span class="line">       recycleBitmapArray();<span class="comment">//回收已存的bitmapArray数组</span></span><br><span class="line">       <span class="keyword">if</span> (width &lt;= <span class="number">0</span> || height &lt;= <span class="number">0</span> || bitmap == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果弹幕的宽高都没有超过屏幕宽高，则不切割bitmap</span></span><br><span class="line">       <span class="keyword">if</span> (width &lt;= maximumCacheWidth &amp;&amp; height &lt;= maximumCacheHeight) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//切割超过一屏的弹幕</span></span><br><span class="line">       maximumCacheWidth = Math.min(maximumCacheWidth, dispWidth);</span><br><span class="line">       maximumCacheHeight = Math.min(maximumCacheHeight, dispHeight);</span><br><span class="line">       <span class="comment">//计算弹幕宽高是屏幕宽高的倍数，然后决定切割成多少块</span></span><br><span class="line">       <span class="keyword">int</span> xCount = width / maximumCacheWidth + (width % maximumCacheWidth == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">       <span class="keyword">int</span> yCount = height / maximumCacheHeight + (height % maximumCacheHeight == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">       <span class="comment">//然后求切割后弹幕每一块宽和高的平均值</span></span><br><span class="line">       <span class="keyword">int</span> averageWidth = width / xCount;</span><br><span class="line">       <span class="keyword">int</span> averageHeight = height / yCount;</span><br><span class="line">       <span class="comment">//建立二位bitmap数组，用于存放切割碎片</span></span><br><span class="line">       <span class="keyword">final</span> Bitmap[][] bmpArray = <span class="keyword">new</span> Bitmap[yCount][xCount];</span><br><span class="line">       <span class="keyword">if</span> (canvas == <span class="keyword">null</span>)&#123;</span><br><span class="line">           canvas = <span class="keyword">new</span> Canvas();</span><br><span class="line">           <span class="keyword">if</span> (mDensity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               canvas.setDensity(mDensity);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       Rect rectSrc = <span class="keyword">new</span> Rect();</span><br><span class="line">       Rect rectDst = <span class="keyword">new</span> Rect();</span><br><span class="line">       <span class="comment">//切割bitmap到bitmapArray中</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> yIndex = <span class="number">0</span>; yIndex &lt; yCount; yIndex++) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> xIndex = <span class="number">0</span>; xIndex &lt; xCount; xIndex++) &#123;</span><br><span class="line">            <span class="comment">//创建每一块小块bitmap</span></span><br><span class="line">               Bitmap bmp = bmpArray[yIndex][xIndex] = NativeBitmapFactory.createBitmap(</span><br><span class="line">                       averageWidth, averageHeight, Bitmap.Config.ARGB_8888);</span><br><span class="line">               <span class="keyword">if</span> (mDensity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                   bmp.setDensity(mDensity);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//将弹幕的大bitmap绘制进每个小块bitmap中</span></span><br><span class="line">               canvas.setBitmap(bmp);</span><br><span class="line">               <span class="keyword">int</span> left = xIndex * averageWidth, top = yIndex * averageHeight;</span><br><span class="line">               rectSrc.set(left, top, left + averageWidth, top + averageHeight);</span><br><span class="line">               rectDst.set(<span class="number">0</span>, <span class="number">0</span>, bmp.getWidth(), bmp.getHeight());</span><br><span class="line">               canvas.drawBitmap(bitmap, rectSrc, rectDst, <span class="keyword">null</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       canvas.setBitmap(bitmap);</span><br><span class="line">       bitmapArray = bmpArray;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;切割超过一屏的弹幕，<strong>就像玩切田字格游戏一样</strong>，完成后保存了一个bitmapArray数组。</p>
<p>&#160; &#160; &#160; &#160;到这里我们buildCache(item, false)的策略二中的重新设置缓存DanmakuUtils.buildDanmakuDrawingCache(item, mDisp, cache)就走完了。然后将这个目标弹幕的引用放入缓存Danmakus中(mCaches)，同时更新已使用大小mRealSize。同时注意mCaches内部成员items是TreeSet类型，不能添加相同的对象。</p>
<p>&#160; &#160; &#160; &#160;策略二设计的挺复杂的，我们可以看到这个策略应该是弹幕已经播放时不断执行的，对过时弹幕缓存的重复利用。不过我们刚开始，这一策略还未起作用，所以跳过，进入下一阶段：</p>
<p> &#160; &#160; &#160; &#160;4）如果上述两次查找缓存都没找到，则从FinitePool中取出一个，没有就new一个，然后同上配置DrawingCache：<br> &#160; &#160; &#160; &#160;继续回到buildCache方法这个位置： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">byte</span> <span class="title">buildCache</span><span class="params">(BaseDanmaku item, <span class="keyword">boolean</span> forceInsert)</span> </span>&#123;<span class="comment">//item, false</span></span><br><span class="line">		...测量过了...</span><br><span class="line">		...第一策略已经pass...</span><br><span class="line">		...第二策略已经pass...</span><br><span class="line">                  <span class="comment">//如果上述两次查找缓存都没找到，则进入下面逻辑</span></span><br><span class="line">                  <span class="comment">// guess cache size</span></span><br><span class="line">                  <span class="keyword">if</span> (!forceInsert) &#123;<span class="comment">//如果forceInsert为false，则表示不检测内存超出</span></span><br><span class="line">                      <span class="comment">//计算此弹幕bitmap的大小，width * height * 4</span></span><br><span class="line">                      <span class="comment">//(因为用native创建的Bitmap的Config为ARGB_8888，所以一个像素占4个字节)</span></span><br><span class="line">                      <span class="keyword">int</span> cacheSize = DanmakuUtils.getCacheSize((<span class="keyword">int</span>) item.paintWidth,</span><br><span class="line">                              (<span class="keyword">int</span>) item.paintHeight);</span><br><span class="line">                      <span class="comment">//如果当前已经使用大小 + 此弹幕缓存大小 &gt; 设置的最大内存（2/3 应用内存）        </span></span><br><span class="line">                      <span class="keyword">if</span> (mRealSize + cacheSize &gt; mMaxSize) &#123;<span class="comment">//没有超</span></span><br><span class="line">                          <span class="keyword">return</span> RESULT_FAILED;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="comment">//从FinitePool中的300个DrawingCache对象中取出来一个</span></span><br><span class="line">                  cache = mCachePool.acquire();</span><br><span class="line">                  <span class="comment">//如果从上面的FinitePool取完了，则会直接new一个DrawingCache，配置DrawingCache</span></span><br><span class="line">                  cache = DanmakuUtils.buildDanmakuDrawingCache(item, mDisp, cache);</span><br><span class="line">                  item.cache = cache;</span><br><span class="line">                  <span class="comment">//将item存入mCaches缓存，同时更新已使用大小mRealSize</span></span><br><span class="line">                  <span class="keyword">boolean</span> pushed = mCacheManager.push(item, sizeOf(item), forceInsert);</span><br><span class="line">                  <span class="keyword">if</span> (!pushed) &#123;<span class="comment">//如果item存放失败(使用内存超出规定大小)</span></span><br><span class="line">                      releaseDanmakuCache(item, cache);<span class="comment">//释放DrawingCache</span></span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">return</span> pushed ? RESULT_SUCCESS : RESULT_FAILED;</span><br><span class="line">		......</span><br><span class="line">&#125;</span><br><span class="line">   <span class="comment">//FinitePool的acquire方法，从缓存链表头取出一个对象</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> T <span class="title">acquire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        T element;</span><br><span class="line">		<span class="comment">//mRoot 就是缓存链表表头指向的对象</span></span><br><span class="line">        <span class="keyword">if</span> (mRoot != <span class="keyword">null</span>) &#123;</span><br><span class="line">            element = mRoot;</span><br><span class="line">            mRoot = element.getNextPoolable();</span><br><span class="line">            mPoolCount--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            element = mManager.newInstance();</span><br><span class="line">        &#125;</span><br><span class="line">	        <span class="keyword">if</span> (element != <span class="keyword">null</span>) &#123;</span><br><span class="line">            element.setNextPoolable(<span class="keyword">null</span>);</span><br><span class="line">            element.setPooled(<span class="keyword">false</span>);</span><br><span class="line">            mManager.onAcquired(element);</span><br><span class="line">        &#125;	</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;上述策略三是直接新建一个缓存DrawingCache，然后根据目标弹幕样式等配置它然后将它付给目标弹幕，再将目标弹幕放入缓存mCaches中。<br>&#160; &#160; &#160; &#160;刚开始时会执行策略三，因为刚开始时还没有缓存供我们使用，所以只能新建。</p>
<p>&#160; &#160; &#160; &#160;到此buildCache方法就走完了。我们可以看到buildCache主要截取了从当前时间开始的3倍弹幕时间内所有弹幕，然后为每一条弹幕建立缓存（创建DrawingCache对象，然后测量弹幕大小，再绘制弹幕内容，最后将信息保存到DrawingCache中，然后将它赋给目标弹幕的cache属性），并将这些弹幕保存到缓存mCaches中。</p>
<p>&#160; &#160; &#160; &#160;再次回顾一下上面的逻辑：</p>
<ul>
<li>子线程从发送PREPARE消息开始，然后接着发送了DISPATCH_ACTIONS消息；</li>
<li>DISPATCH_ACTIONS消息处理逻辑内部又会发送DISPATCH_ACTIONS消息，时间间隔为半条弹幕时间就这样不断循环发送；</li>
<li>DISPATCH_ACTIONS消息处理会调用dispatchAction方法，dispatchAction方法会发送BUILD_CACHES消息；</li>
<li>BUILD_CACHES消息处理会调用prepareCaches方法，prepareCaches方法内部会调用buildCache方法为从当前时间开始的3倍弹幕时间内所有的弹幕做缓存。</li>
</ul>
<p>&#160; &#160; &#160; &#160;buildCache走完后，赶紧回到它之前调用方法的地方，不要把自己搞晕了= 。=<br>&#160; &#160; &#160; &#160;回到CacheManagingDrawTask的prepareCaches方法中，<strong>最后更新一下缓存定时器的时间，到缓存的最后一条弹幕的出现时间</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">prepareCaches</span><span class="params">(<span class="keyword">boolean</span> repositioned)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	...截取三倍弹幕时间内所有弹幕，并为他们一一建立缓存...</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (item != <span class="keyword">null</span>) &#123;<span class="comment">//截取的最后一条弹幕,更新缓存定时器时间到它的出现时间</span></span><br><span class="line">        mCacheTimer.update(item.time);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mCacheTimer.update(end);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;prepareCaches方法走完后，回到处理原先处理BUILD_CACHES消息的逻辑中，继续执行剩余部分：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//CacheHandler的handleMessage方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line"> ......</span><br><span class="line"> <span class="keyword">case</span> BUILD_CACHES:</span><br><span class="line">        removeMessages(BUILD_CACHES);</span><br><span class="line">        <span class="keyword">boolean</span> repositioned = ((mTaskListener != <span class="keyword">null</span> </span><br><span class="line">         &amp;&amp; mReadyState == <span class="keyword">false</span>) || mSeekedFlag);<span class="comment">// 为true</span></span><br><span class="line">        prepareCaches(repositioned);<span class="comment">//首次建立缓存已经完毕</span></span><br><span class="line">        <span class="keyword">if</span> (repositioned)</span><br><span class="line">         mSeekedFlag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (mTaskListener != <span class="keyword">null</span> &amp;&amp; mReadyState == <span class="keyword">false</span>) &#123;</span><br><span class="line">         mTaskListener.ready();<span class="comment">//然后回到mTaskListener监听ready方法</span></span><br><span class="line">         mReadyState = <span class="keyword">true</span>;<span class="comment">//将mReadyState标志位置为true，下次BUILD_CACHES不会进入这段逻辑了</span></span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">       ...... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;执行mTaskListener.ready()方法，得回到上层逻辑DrawHandler的prepare(runnable)方法中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DrawHandler的prepare方法</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">final</span> Runnable runnable)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (drawTask == <span class="keyword">null</span>) &#123;</span><br><span class="line">           drawTask = createDrawTask(mDanmakuView.isDanmakuDrawingCacheEnabled(), timer,</span><br><span class="line">                   mDanmakuView.getContext(), mDanmakuView.getWidth(), mDanmakuView.getHeight(),</span><br><span class="line">                   mDanmakuView.isHardwareAccelerated(), <span class="keyword">new</span> IDrawTask.TaskListener() &#123;</span><br><span class="line">                       <span class="meta">@Override</span></span><br><span class="line">                       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ready</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                           initRenderingConfigs();<span class="comment">//初始化一些渲染参数</span></span><br><span class="line">                           runnable.run();<span class="comment">//执行runnable的run方法，继续追踪</span></span><br><span class="line">                       &#125;</span><br><span class="line">				......</span><br><span class="line">                   &#125;);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           runnable.run();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//DrawHandler的initRenderingConfigs方法</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initRenderingConfigs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">long</span> averageFrameConsumingTime = <span class="number">16</span>;<span class="comment">//平均每帧渲染间隔</span></span><br><span class="line">       mCordonTime = Math.max(<span class="number">33</span>, (<span class="keyword">long</span>) (averageFrameConsumingTime * <span class="number">2.5f</span>));<span class="comment">//40，警戒值1</span></span><br><span class="line">       mCordonTime2 = (<span class="keyword">long</span>) (mCordonTime * <span class="number">2.5f</span>);<span class="comment">//100，警戒值2</span></span><br><span class="line">       mFrameUpdateRate = Math.max(<span class="number">16</span>, averageFrameConsumingTime / <span class="number">15</span> * <span class="number">15</span>);<span class="comment">//16，每帧渲染间隔</span></span><br><span class="line">       mThresholdTime = mFrameUpdateRate + <span class="number">3</span>;<span class="comment">//19，渲染间隔阀值</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;初始化一些渲染参数，主要就是计算一下警戒时间和渲染频率。然后继续追踪runnable.run()方法，这个得回到DrawHandler的handleMessage方法中处理DrawHandler.PREPARE逻辑处：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DrawHandler的handleMessage方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> what = msg.what;</span><br><span class="line">       <span class="keyword">switch</span> (what) &#123;</span><br><span class="line">           <span class="keyword">case</span> PREPARE:</span><br><span class="line">		......</span><br><span class="line">                   prepare(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                       <span class="meta">@Override</span></span><br><span class="line">                       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;<span class="comment">//会回调到这里</span></span><br><span class="line">                           pausedPosition = <span class="number">0</span>;</span><br><span class="line">                           mReady = <span class="keyword">true</span>;<span class="comment">//将mReady 标志位置为true</span></span><br><span class="line">                           <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">                               mCallback.prepared();<span class="comment">//回调callback监听</span></span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;);</span><br><span class="line">               ......</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;继续追踪mCallback.prepared()，会回到MainActivity当中我们设置DanmakuView的地方：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MainActivity中设置mDanmakuView</span></span><br><span class="line">   mDanmakuView.setCallback(<span class="keyword">new</span> master.flame.danmaku.controller.DrawHandler.Callback() &#123;</span><br><span class="line">	......</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepared</span><span class="params">()</span> </span>&#123;                 </span><br><span class="line">    mDanmakuView.start();</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">   <span class="comment">//继续产看DanmaKuView的start方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       start(<span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">long</span> postion)</span> </span>&#123;</span><br><span class="line">	......</span><br><span class="line">       handler.obtainMessage(DrawHandler.START, postion).sendToTarget();<span class="comment">//DrawHandler发送START消息</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;然后就是DrawHandler发送START消息：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DrawHandler的handleMessage方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">		......</span><br><span class="line">        <span class="keyword">case</span> START:</span><br><span class="line">               Long startTime = (Long) msg.obj;<span class="comment">//0</span></span><br><span class="line">               <span class="keyword">if</span> (startTime != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   pausedPosition = startTime;<span class="comment">//0</span></span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   pausedPosition = <span class="number">0</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           <span class="keyword">case</span> SEEK_POS:</span><br><span class="line">			......</span><br><span class="line">           <span class="keyword">case</span> RESUME:</span><br><span class="line">               quitFlag = <span class="keyword">false</span>;</span><br><span class="line">               <span class="keyword">if</span> (mReady) &#123;<span class="comment">//true</span></span><br><span class="line">				......</span><br><span class="line">                   mTimeBase = SystemClock.uptimeMillis() - pausedPosition;<span class="comment">//将时间基线设为当前时间</span></span><br><span class="line">                   timer.update(pausedPosition);<span class="comment">//更新主定时器时间到初始位置，为0</span></span><br><span class="line">                   removeMessages(RESUME);</span><br><span class="line">                   sendEmptyMessage(UPDATE);<span class="comment">//发送UPDATE消息</span></span><br><span class="line">                   drawTask.start();<span class="comment">//CacheManagingDrawTask的start方法</span></span><br><span class="line">				......</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  ......</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> UPDATE:</span><br><span class="line">               <span class="keyword">if</span> (mUpdateInNewThread) &#123;<span class="comment">//在DrawHandler构造方法里赋值的变量，只有当可用CPU个数大于3时才为true</span></span><br><span class="line">                   updateInNewThread();<span class="comment">//四核，八核的请进</span></span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   updateInCurrentThread();<span class="comment">//单核，双核的请进</span></span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           ......    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;上述逻辑最后会进入RESUME消息处理中，先调用CacheManagingDrawTask的start方法，然后处理UPDATE消息。我们先看看CacheManagingDrawTask的start方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CacheManagingDrawTask的start方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	......</span><br><span class="line">       mCacheManager.resume();<span class="comment">//CacheManager的resume方法</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//继续跟CacheManager的resume方法</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           ......</span><br><span class="line">           mHandler.resume();<span class="comment">//CacheManagingDrawTask的resume方法</span></span><br><span class="line">		......</span><br><span class="line">       &#125;</span><br><span class="line">    <span class="comment">//继续跟CacheManagingDrawTask的resume方法   </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           mCancelFlag = <span class="keyword">false</span>;</span><br><span class="line">           mPause = <span class="keyword">false</span>;</span><br><span class="line">           removeMessages(DISPATCH_ACTIONS);</span><br><span class="line">           sendEmptyMessage(DISPATCH_ACTIONS);<span class="comment">//发送DISPATCH_ACTIONS消息，我们上面分析过，就是建立缓存</span></span><br><span class="line">           sendEmptyMessageDelayed(CLEAR_TIMEOUT_CACHES, mContext.mDanmakuFactory.MAX_DANMAKU_DURATION);<span class="comment">//延时发送CLEAR_TIMEOUT_CACHES消息</span></span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;我们可以看到CacheManagingDrawTask的start方法最终做了两件事，一件是发送DISPATCH_ACTIONS再次建立缓存，这个流程我们上面分析过；第二件是<code>延时发送</code>CLEAR_TIMEOUT_CACHES消息。</p>
<p>&#160; &#160; &#160; &#160;所以我们看看CLEAR_TIMEOUT_CACHES消息处理逻辑：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CacheHandler的handleMessage方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">	 .......</span><br><span class="line">	 <span class="keyword">case</span> CLEAR_TIMEOUT_CACHES:</span><br><span class="line">            clearTimeOutCaches();<span class="comment">//继续跟这个</span></span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           ......    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用 clearTimeOutCaches方法</span></span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">clearTimeOutCaches</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          clearTimeOutCaches(mTimer.currMillisecond);<span class="comment">//调用重载方法，参数为主定时器当前时间</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//调用重载方法，参数为主定时器当前时间</span></span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">clearTimeOutCaches</span><span class="params">(<span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">          IDanmakuIterator it = mCaches.iterator();<span class="comment">//从之前buildCache中建立的缓存中一一遍历</span></span><br><span class="line">          <span class="keyword">while</span> (it.hasNext() &amp;&amp; !mEndFlag) &#123;<span class="comment">//mEndFlag = false</span></span><br><span class="line">              BaseDanmaku val = it.next();</span><br><span class="line">              <span class="keyword">if</span> (val.isTimeOut()) &#123;<span class="comment">//如果缓存的弹幕已经超时</span></span><br><span class="line">			......</span><br><span class="line">                  entryRemoved(<span class="keyword">false</span>, val, <span class="keyword">null</span>);<span class="comment">//销毁缓存</span></span><br><span class="line">                  it.remove();<span class="comment">//从缓存mCaches中移除此引用</span></span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;顺着逻辑看看entryRemoved(false, val, null)方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">entryRemoved</span><span class="params">(<span class="keyword">boolean</span> evicted, BaseDanmaku oldValue, BaseDanmaku newValue)</span> </span>&#123;<span class="comment">//第1个和第3个参数没用到</span></span><br><span class="line">    IDrawingCache&lt;?&gt; cache = oldValue.getDrawingCache();</span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">long</span> releasedSize = clearCache(oldValue);<span class="comment">//调用了clearCache方法</span></span><br><span class="line">        <span class="keyword">if</span> (oldValue.isTimeOut()) &#123;</span><br><span class="line">         <span class="comment">//这个方法最终会调用我们最初设置DanmakuContext.setCacheStuffer(new SpannedCacheStuffer(), mCacheStufferAdapter)</span></span><br><span class="line">         <span class="comment">//中第二个参数类型为BaseCacheStuffer.Proxy的releaseResource方法,</span></span><br><span class="line">         <span class="comment">//方法注释是这么写的 TODO 重要:清理含有ImageSpan的text中的一些占用内存的资源 例如drawable</span></span><br><span class="line">            mContext.getDisplayer().getCacheStuffer().releaseResource(oldValue);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (releasedSize &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        mRealSize -= releasedSize;<span class="comment">//真正缓存大小减去需要释放的缓存大小</span></span><br><span class="line">        mCachePool.release((DrawingCache) cache);<span class="comment">//将Drawingcache放回到FinitePool中，已供下次取出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//往下看，看看clearCache方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">clearCache</span><span class="params">(BaseDanmaku oldValue)</span> </span>&#123;</span><br><span class="line">    IDrawingCache&lt;?&gt; cache = oldValue.cache;</span><br><span class="line">    <span class="keyword">if</span> (cache == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cache.hasReferences()) &#123;<span class="comment">//如果DrawingCache缓存还被重复引用</span></span><br><span class="line">        cache.decreaseReference();<span class="comment">//则将引用计数-1</span></span><br><span class="line">        oldValue.cache = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//不销毁缓存(bitmap,canvas等)，只有等到引用计数为0时才会销毁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> size = sizeOf(oldValue);<span class="comment">//计算缓存的bitmap大小</span></span><br><span class="line">    cache.destroy();<span class="comment">//同时销毁bitmap等</span></span><br><span class="line">    oldValue.cache = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//缓存的bitmap的大小</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">sizeOf</span><span class="params">(BaseDanmaku value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value.cache != <span class="keyword">null</span> &amp;&amp; !value.cache.hasReferences()) &#123;</span><br><span class="line">        <span class="keyword">return</span> value.cache.size();<span class="comment">//返回的是Drawing中bitmap对象的大小，上面讲过的</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;CLEAR_TIMEOUT_CACHES消息处理就分析完了，就是移除缓存弹幕mCache中过时的弹幕，并且销毁他们持有的DrawingCache，同时销毁内部的bitmap、canvas等。</p>
<h3 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h3><p>&#160; &#160; &#160; &#160;现在重点来了！还记得我们之前挖的一个大坑么？就是妹子图那个地方。那是CacheHandler给工作线程发送DISPATCH_ACTIONS消息时调用的dispatchAction方法。因为CacheHandler每个半条弹幕时间就会发DISPATCH_ACTIONS消息，所以我们得仔细分析一下dispatchAction方法的各种情况：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">dispatchAction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="comment">//如果上一次buildCache完成后得到的缓存弹幕末尾项的时间（上面分析过，这个值存在mCacheTimer.currMillisecond中）</span></span><br><span class="line">         <span class="comment">//和主定时器当前时间之间的时间差值已经大于一条弹幕时间,</span></span><br><span class="line">         <span class="comment">//则会清除所有不在屏幕内的缓存，然后重新buildCache建立缓存</span></span><br><span class="line">            <span class="keyword">if</span> (mCacheTimer.currMillisecond &lt;= mTimer.currMillisecond - mContext.mDanmakuFactory.MAX_DANMAKU_DURATION) &#123;</span><br><span class="line">                evictAllNotInScreen();<span class="comment">//则会清除所有不在屏幕内的缓存</span></span><br><span class="line">                mCacheTimer.update(mTimer.currMillisecond);</span><br><span class="line">                sendEmptyMessage(BUILD_CACHES);<span class="comment">//重新建立缓存</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">float</span> level = getPoolPercent();<span class="comment">//获得缓存实际大小占设置最大内存的百分比</span></span><br><span class="line">            BaseDanmaku firstCache = mCaches.first();</span><br><span class="line">            <span class="comment">//TODO 如果firstcache大于当前时间超过半屏并且水位在0.5f以下,就要往里蓄水</span></span><br><span class="line">            <span class="keyword">long</span> gapTime = firstCache != <span class="keyword">null</span> ? firstCache.time - mTimer.currMillisecond : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">long</span> doubleScreenDuration = mContext.mDanmakuFactory.MAX_DANMAKU_DURATION * <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (level &lt; <span class="number">0.6f</span> &amp;&amp; gapTime &gt; mContext.mDanmakuFactory.MAX_DANMAKU_DURATION) &#123;</span><br><span class="line">                mCacheTimer.update(mTimer.currMillisecond);</span><br><span class="line">                removeMessages(BUILD_CACHES);</span><br><span class="line">                sendEmptyMessage(BUILD_CACHES);<span class="comment">//重新建立缓存</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (level &gt; <span class="number">0.4f</span> &amp;&amp; gapTime &lt; -doubleScreenDuration) &#123;<span class="comment">//如果水位在0.5以上，并且上一次蓄水距离现在已经超过两条弹幕时间了，就要开闸放水</span></span><br><span class="line">                <span class="comment">// clear timeout caches</span></span><br><span class="line">                removeMessages(CLEAR_TIMEOUT_CACHES);</span><br><span class="line">                sendEmptyMessage(CLEAR_TIMEOUT_CACHES);<span class="comment">//CLEAR_TIMEOUT_CACHES消息刚分析过了，清除过时缓存</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (level &gt;= <span class="number">0.9f</span>) &#123;<span class="comment">//水位快满了，等待下次放水</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// check cache time</span></span><br><span class="line">            <span class="keyword">long</span> deltaTime = mCacheTimer.currMillisecond - mTimer.currMillisecond;</span><br><span class="line">            <span class="comment">//缓存的第一条弹幕已经过时了，并且缓存弹幕末尾时间和现在时间差值已经超过一条弹幕时间了</span></span><br><span class="line">            <span class="keyword">if</span> (firstCache != <span class="keyword">null</span> &amp;&amp; firstCache.isTimeOut() &amp;&amp; deltaTime &lt; -mContext.mDanmakuFactory.MAX_DANMAKU_DURATION) &#123;</span><br><span class="line">                mCacheTimer.update(mTimer.currMillisecond);</span><br><span class="line">                sendEmptyMessage(CLEAR_OUTSIDE_CACHES);<span class="comment">//先清除过时缓存</span></span><br><span class="line">                sendEmptyMessage(BUILD_CACHES);<span class="comment">//再重组缓存</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (deltaTime &gt; doubleScreenDuration) &#123;<span class="comment">//如果缓存的最后一条弹幕时间距离现在还有双倍弹幕时间多，则啥都不做</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//剩余情况组建缓存</span></span><br><span class="line">            removeMessages(BUILD_CACHES);</span><br><span class="line">            sendEmptyMessage(BUILD_CACHES);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//则会清除所有不在屏幕内的缓存    </span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">evictAllNotInScreen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        evictAllNotInScreen(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">evictAllNotInScreen</span><span class="params">(<span class="keyword">boolean</span> removeAllReferences)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mCaches != <span class="keyword">null</span>) &#123;</span><br><span class="line">            IDanmakuIterator it = mCaches.iterator();</span><br><span class="line">            <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                BaseDanmaku danmaku = it.next();</span><br><span class="line">	......</span><br><span class="line">                <span class="keyword">if</span> (danmaku.isOutside()) &#123;<span class="comment">//如果弹幕已经走完了，超过屏幕</span></span><br><span class="line">                    entryRemoved(<span class="keyword">true</span>, danmaku, <span class="keyword">null</span>);<span class="comment">//回收缓存</span></span><br><span class="line">                    it.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">  </span><br><span class="line">        &#125;</span><br><span class="line">        mRealSize = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获得缓存实际大小占设置最大内存的百分比</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getPoolPercent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mMaxSize == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mRealSize / (<span class="keyword">float</span>) mMaxSize;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;dispatchAction方法主要分为以下几种规则：</p>
<ul>
<li>如果上一次buildCache完成后得到的缓存弹幕末尾项的时间（上面分析过，这个值存在mCacheTimer.currMillisecond中）和主定时器当前时间之间的时间差值已经大于一条弹幕时间, 则会清除所有不在屏幕内的缓存，然后重新buildCache建立缓存；</li>
<li>如果缓存弹幕的第一项出现时间大于当前时间超过半屏，并且总缓存大小在规定最大值一半以下, 就要重新建立缓存；</li>
<li>如果总缓存大小在规定最大值一半以上，并且上一次建立缓存距离现在已经超过两条弹幕时间了，就要清除超时缓存；</li>
<li>如果总缓存大小快达到规定最大值，就等待下一次清除超时缓存；</li>
<li>缓存的第一条弹幕已经过时了，并且缓存弹幕末尾时间和现在时间差值已经超过一条弹幕时间了，先清除过时缓存，再重组缓存；</li>
<li>如果缓存的最后一条弹幕时间距离现在还有双倍弹幕时间多，则啥都不做;</li>
<li>剩余情况就是重组缓存。</li>
</ul>
<p>&#160; &#160; &#160; &#160;因为DISPATCH_ACTIONS消息是每隔半条弹幕时间发送一次，所以会不断执行dispatchAction方法。然后根据上述出现的情况不断BUILD_CACHES和CLEAR_TIMEOUT_CACHES,这样工作线程就形成了一套缓存机制。</p>
<h3 id="绘制弹幕界面"><a href="#绘制弹幕界面" class="headerlink" title="绘制弹幕界面"></a>绘制弹幕界面</h3><p>&#160; &#160; &#160; &#160;到此CacheManagingDrawTask的start方法就分析完了，继续回到DrawHandler的handleMessage方法，接着处理UPDATE消息：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DrawHandler的handleMessage方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">case</span> UPDATE:</span><br><span class="line">               <span class="keyword">if</span> (mUpdateInNewThread) &#123;<span class="comment">//在DrawHandler构造方法里赋值的变量，只有当可用CPU个数大于3时才为true</span></span><br><span class="line">                   updateInNewThread();<span class="comment">//四核，八核的请进</span></span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   updateInCurrentThread();<span class="comment">//单核，双核的请进</span></span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           ...... 	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;到这里，我们应该能猜到接下要进行应该就是绘制工作了。其实updateInNewThread和updateInCurrentThread做的事情是一样的，只不过其中一个新开了子线程去做这些事情。两者的工作原理都是更新定时器，然后postInvalidate，使DanmakuView重绘，然后再发UPDATE消息，重复上述过程。</p>
<p>&#160; &#160; &#160; &#160;鉴于目前四核手机已经烂大街了，我们也就挑个多核的方法进去看看：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateInNewThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mThread != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mThread = <span class="keyword">new</span> UpdateThread(<span class="string">"DFM Update"</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">long</span> lastTime = SystemClock.uptimeMillis();</span><br><span class="line">            <span class="keyword">long</span> dTime = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (!isQuited() &amp;&amp; !quitFlag) &#123;</span><br><span class="line">                <span class="keyword">long</span> startMS = SystemClock.uptimeMillis();</span><br><span class="line">                dTime = SystemClock.uptimeMillis() - lastTime;</span><br><span class="line">                <span class="keyword">long</span> diffTime = mFrameUpdateRate - dTime;<span class="comment">//mFrameUpdateRate 为16，之前计算过</span></span><br><span class="line">                <span class="keyword">if</span> (diffTime &gt; <span class="number">1</span>) &#123;<span class="comment">//如果间隔时间太短，则会延时，一定要等够16毫秒，达到绘制时间间隔</span></span><br><span class="line">                    SystemClock.sleep(<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;d</span><br><span class="line">                <span class="comment">//上面逻辑是为了延时，稳定帧率</span></span><br><span class="line">                lastTime = startMS;</span><br><span class="line">                <span class="keyword">long</span> d = syncTimer(startMS);<span class="comment">//同步主定时器时间</span></span><br><span class="line">       ......</span><br><span class="line">       </span><br><span class="line">                d = mDanmakuView.drawDanmakus();<span class="comment">//开始postInvalidate，绘制弹幕，同时返回绘制时间</span></span><br><span class="line">                <span class="comment">//这种情况出现在绘制时间内，绘制时子线程在wait，等待绘制结束，然后返回差值必定大于警戒值100</span></span><br><span class="line">                <span class="keyword">if</span> (d &gt; mCordonTime2) &#123;  <span class="comment">// this situation may be cuased by ui-thread waiting of DanmakuView, so we sync-timer at once</span></span><br><span class="line">                    timer.add(d);<span class="comment">//绘制完成后更新主定时器时间</span></span><br><span class="line">                    mDrawTimes.clear();</span><br><span class="line">                &#125;</span><br><span class="line">	......</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    mThread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;updateInNewThread主要做了两件事：延时然后同步主定时器时间，然后通知DanmakuView重绘。</p>
<p>&#160; &#160; &#160; &#160;我们先看同步主定时器时间：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">syncTimer</span><span class="params">(<span class="keyword">long</span> startMS)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      ......</span><br><span class="line">      <span class="keyword">long</span> d = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">long</span> time = startMS - mTimeBase;<span class="comment">//当前时间到初始时间的时间差</span></span><br><span class="line">       ......</span><br><span class="line">          <span class="keyword">long</span> gapTime = time - timer.currMillisecond;<span class="comment">//总时间差减去上一次绘制完成时间，得到绘制间隙时间</span></span><br><span class="line">          <span class="keyword">long</span> averageTime = Math.max(mFrameUpdateRate, getAverageRenderingTime());<span class="comment">//计算绘制间隙平均时间，大于等于16（getAverageRenderingTime方法是计算加入mDrawTimes队列的已经绘制过的时间总和除以帧数，得到平均时间，这个下面会讲到）</span></span><br><span class="line">          <span class="comment">//若果距离上次间隙时间过长||上次渲染时间大于第一警戒时间（40 ms）||上一步计算的绘制间隙平均时间大于第一警戒时间</span></span><br><span class="line">          <span class="keyword">if</span> (gapTime &gt; <span class="number">2000</span> || mRenderingState.consumingTime &gt; mCordonTime || averageTime &gt; mCordonTime) &#123;</span><br><span class="line">              d = gapTime;</span><br><span class="line">              gapTime = <span class="number">0</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果是普通情况</span></span><br><span class="line">              d = averageTime + gapTime / mFrameUpdateRate;<span class="comment">//将绘制间隙平均时间赋给d，后面的项值不大，可以忽略</span></span><br><span class="line">              d = Math.max(mFrameUpdateRate, d);<span class="comment">//大于等于固定绘制间隔16</span></span><br><span class="line">              d = Math.min(mCordonTime, d);<span class="comment">//小于第一警戒时间40</span></span><br><span class="line">       </span><br><span class="line">		......</span><br><span class="line">          &#125;</span><br><span class="line">          ......</span><br><span class="line">          timer.add(d);<span class="comment">//更新主定时器时间，加上计算的时间间隔</span></span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">      <span class="keyword">return</span> d;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//计算平均绘制间隔时间</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">getAverageRenderingTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> frames = mDrawTimes.size();</span><br><span class="line">      <span class="keyword">if</span>(frames &lt;= <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">long</span> dtime = mDrawTimes.getLast() - mDrawTimes.getFirst();</span><br><span class="line">      <span class="keyword">return</span> dtime / frames;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;syncTimer主要是计算了一下绘制间隔时间，然后同步一下主定时器。</p>
<p>&#160; &#160; &#160; &#160;然后我们看看通知DanmakuView重绘部分：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DanmakuView的drawDanmakus方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">drawDanmakus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">long</span> stime = SystemClock.uptimeMillis();</span><br><span class="line">       lockCanvas();<span class="comment">//再看看lockCanvas</span></span><br><span class="line">       <span class="keyword">return</span> SystemClock.uptimeMillis() - stime;<span class="comment">//返回等待时间差</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//DanmakuView的lockCanvas方法</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">lockCanvas</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	......</span><br><span class="line">       postInvalidateCompat();<span class="comment">//通知view重绘</span></span><br><span class="line">       <span class="keyword">synchronized</span> (mDrawMonitor) &#123;</span><br><span class="line">           <span class="keyword">while</span> ((!mDrawFinished) &amp;&amp; (handler != <span class="keyword">null</span>)) &#123;<span class="comment">//mDrawFinished标志位为false，所以会进入循环。只有onDraw方法的绘制走完了才会将他置为true，才会跳出循环</span></span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   mDrawMonitor.wait(<span class="number">200</span>);<span class="comment">//onDraw没走完就会一直循环等待</span></span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (mDanmakuVisible == <span class="keyword">false</span> || handler == <span class="keyword">null</span> || handler.isStop()) &#123;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       Thread.currentThread().interrupt();</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           mDrawFinished = <span class="keyword">false</span>;<span class="comment">//绘制结束后，将标志位置为false，一边下次进入方法后再次进入上述等待逻辑</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postInvalidateCompat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       mRequestRender = <span class="keyword">true</span>;<span class="comment">//将mRequestRender 标志位置为true，一遍onDraw方法逻辑执行</span></span><br><span class="line">       <span class="comment">//通知view重绘</span></span><br><span class="line">       <span class="keyword">if</span>(Build.VERSION.SDK_INT &gt;= <span class="number">16</span>) &#123;</span><br><span class="line">           <span class="keyword">this</span>.postInvalidateOnAnimation();</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">this</span>.postInvalidate();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这样就能保证保证每隔一定时间（这个时间通过syncTimer计算），更新主定时器（就是从0开始，往后每次加上（间隔时间 + 绘制时间）），然后执行postInvalidate通知DanmakuView重绘。</p>
<p>&#160; &#160; &#160; &#160;postInvalidate后，View重绘，会重走onDraw方法，所以我们进入DanmakuView的onDraw方法看看：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DanmakuView的onDraw方法</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> ((!mDanmakuVisible) &amp;&amp; (!mRequestRender)) &#123;<span class="comment">//如果没有请求重绘则mRequestRender为false，不会绘制弹幕</span></span><br><span class="line">           <span class="keyword">super</span>.onDraw(canvas);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">	......</span><br><span class="line">           <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">               RenderingState rs = handler.draw(canvas);<span class="comment">//DrawHandler的draw方法</span></span><br><span class="line">			......</span><br><span class="line">           &#125;</span><br><span class="line">      ......</span><br><span class="line">       <span class="comment">//绘制结束后将mRequestRender 标志位重新设为false，</span></span><br><span class="line">       <span class="comment">//以便下一次发绘制消息时进入等待逻辑等候绘制结束，这个上面DanmakuView的drawDanmakus方法提到过</span></span><br><span class="line">       mRequestRender = <span class="keyword">false</span>;</span><br><span class="line">       unlockCanvasAndPost();<span class="comment">//通知UpdateThread绘制完成</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unlockCanvasAndPost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">synchronized</span> (mDrawMonitor) &#123;</span><br><span class="line">           mDrawFinished = <span class="keyword">true</span>;<span class="comment">//将mDrawFinished 置为true，以便DanmakuView的lockCanvas方法跳出循环，这个上面也提到过</span></span><br><span class="line">           mDrawMonitor.notifyAll();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;DanmakuView的onDraw回调逻辑会执行DrawHandler的draw方法，我们继续跟进去：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> RenderingState <span class="title">draw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line">      mDisp.setExtraData(canvas);<span class="comment">//将canvas一些信息设置给AndroidDisplayer</span></span><br><span class="line">      mRenderingState.set(drawTask.draw(mDisp));<span class="comment">//绘制部分是drawTask.draw(mDisp)</span></span><br><span class="line">      recordRenderingTime();<span class="comment">//记录绘制结束时间</span></span><br><span class="line">      <span class="keyword">return</span> mRenderingState;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//还记得上面的DrawHandler的syncTimer方法吗？里面调用了getAverageRenderingTime计算绘制平均间隔时间，</span></span><br><span class="line">  <span class="comment">//其中用到的mDrawTimes变量就是在这里添加元素的</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">recordRenderingTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">long</span> lastTime = SystemClock.uptimeMillis();</span><br><span class="line">      mDrawTimes.addLast(lastTime);<span class="comment">//将绘制结束时间加入到类型为LinkedList的mDrawTimes集合中</span></span><br><span class="line">      <span class="keyword">int</span> frames = mDrawTimes.size();</span><br><span class="line">      <span class="keyword">if</span> (frames &gt; MAX_RECORD_SIZE) &#123;<span class="comment">//最大容量为500个绘制时间，超出了则移除第一个</span></span><br><span class="line">          mDrawTimes.removeFirst();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;上述逻辑中，我的注释部分先分析了记录绘制结束时间部分，填了上边syncTimer时的坑。<br>&#160; &#160; &#160; &#160;然后应该进入主要绘制部分了drawTask.draw(mDisp)，也就是CacheManagingDrawTask的draw方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CacheManagingDrawTask的draw方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> RenderingState <span class="title">draw</span><span class="params">(AbsDisplayer displayer)</span> </span>&#123;</span><br><span class="line">       RenderingState result = <span class="keyword">super</span>.draw(displayer);<span class="comment">//会调用父类的draw方法</span></span><br><span class="line">	......</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//DrawTask的draw方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> RenderingState <span class="title">draw</span><span class="params">(AbsDisplayer displayer)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> drawDanmakus(displayer,mTimer);<span class="comment">//又调用了drawDanmakus方法</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//DrawTask的drawDanmakus方法</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> RenderingState <span class="title">drawDanmakus</span><span class="params">(AbsDisplayer disp, DanmakuTimer timer)</span> </span>&#123;</span><br><span class="line">	......</span><br><span class="line">       <span class="keyword">if</span> (danmakuList != <span class="keyword">null</span>) &#123;</span><br><span class="line">           Canvas canvas = (Canvas) disp.getExtraData();<span class="comment">//取出DanmakuView的canvas</span></span><br><span class="line">		<span class="comment">//当前时间 - 1屏弹幕时间 -100 （多减100是为了下次重新截取弹幕组时让绘制边界做到无缝衔接）</span></span><br><span class="line">           <span class="keyword">long</span> beginMills = timer.currMillisecond - mContext.mDanmakuFactory.MAX_DANMAKU_DURATION - <span class="number">100</span>;</span><br><span class="line">           <span class="comment">//当前时间 + 1屏弹幕时间</span></span><br><span class="line">           <span class="keyword">long</span> endMills = timer.currMillisecond + mContext.mDanmakuFactory.MAX_DANMAKU_DURATION;</span><br><span class="line">           <span class="comment">//每过了一屏的弹幕时间，就会进入如下if逻辑，截取以当前时间为基准的前后两屏弹幕；</span></span><br><span class="line">           <span class="comment">//如果距离上次截取时间不到一屏弹幕时间，则不会进入if的逻辑</span></span><br><span class="line">           <span class="keyword">if</span>(mLastBeginMills &gt; beginMills || timer.currMillisecond &gt; mLastEndMills) &#123;</span><br><span class="line">               IDanmakus subDanmakus = danmakuList.sub(beginMills, endMills);</span><br><span class="line">               <span class="keyword">if</span>(subDanmakus != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   danmakus = subDanmakus;</span><br><span class="line">               &#125;</span><br><span class="line">               mLastBeginMills = beginMills;</span><br><span class="line">               mLastEndMills = endMills;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;<span class="comment">//距离上次截取时间不到一屏时间</span></span><br><span class="line">		......</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (danmakus != <span class="keyword">null</span> &amp;&amp; !danmakus.isEmpty()) &#123;<span class="comment">//开始绘制弹幕</span></span><br><span class="line">               RenderingState renderingState = mRenderingState = mRenderer.draw(mDisp, danmakus, mStartRenderTime);</span><br><span class="line">		......</span><br><span class="line">		&#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;我们可以看到第一次进入会截取以当前时间为基准的前后两屏弹幕。以后每过一屏弹幕时间，会重新截取当时时间为基准的前后两屏弹幕，如果不到一屏时间则不截取，还是以前的弹幕数据。</p>
<p>&#160; &#160; &#160; &#160;截取完弹幕数据后，就是绘制了，继续执行下面逻辑(mRenderer.draw(mDisp, danmakus, mStartRenderTime))，开始绘制工作：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DanmakuRenderer的draw方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> RenderingState <span class="title">draw</span><span class="params">(IDisplayer disp, IDanmakus danmakus, <span class="keyword">long</span> startRenderTime)</span> </span>&#123;</span><br><span class="line">       ......       </span><br><span class="line">       IDanmakuIterator itr = danmakus.iterator();</span><br><span class="line">       ......      </span><br><span class="line"></span><br><span class="line">       BaseDanmaku drawItem = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">while</span> (itr.hasNext()) &#123;</span><br><span class="line"></span><br><span class="line">           drawItem = itr.next();</span><br><span class="line"></span><br><span class="line">		......</span><br><span class="line">		<span class="comment">//如果弹幕还没有到出现时间，则检查它有没有缓存，如果没有则为它建立缓存</span></span><br><span class="line">           <span class="keyword">if</span> (drawItem.isLate()) &#123;</span><br><span class="line">               IDrawingCache&lt;?&gt; cache = drawItem.getDrawingCache();</span><br><span class="line">               <span class="keyword">if</span> (mCacheManager != <span class="keyword">null</span> &amp;&amp; (cache == <span class="keyword">null</span> || cache.get() == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                   mCacheManager.addDanmaku(drawItem);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">		......</span><br><span class="line"></span><br><span class="line">           <span class="comment">// measure 测量，我们之前prepareCache已经为他们在buildCache是测量过了</span></span><br><span class="line">           <span class="keyword">if</span> (!drawItem.isMeasured()) &#123;</span><br><span class="line">               drawItem.measure(disp, <span class="keyword">false</span>);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// layout 布局，计算弹幕在屏幕上应该显示的位置</span></span><br><span class="line">           mDanmakusRetainer.fix(drawItem, disp, mVerifier);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// draw //绘制弹幕</span></span><br><span class="line">           <span class="keyword">if</span> (!drawItem.isOutside() &amp;&amp; drawItem.isShown()) &#123;</span><br><span class="line">               <span class="keyword">if</span> (drawItem.lines == <span class="keyword">null</span> &amp;&amp; drawItem.getBottom() &gt; disp.getHeight()) &#123;</span><br><span class="line">                   <span class="keyword">continue</span>;    <span class="comment">// skip bottom outside danmaku ，忽略超过视图底部的弹幕</span></span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//开始绘制</span></span><br><span class="line">               <span class="keyword">int</span> renderingType = drawItem.draw(disp);</span><br><span class="line">               <span class="keyword">if</span>(renderingType == IRenderer.CACHE_RENDERING) &#123;<span class="comment">//如果是使用缓存bitmap绘制的</span></span><br><span class="line">                   ......</span><br><span class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span>(renderingType == IRenderer.TEXT_RENDERING) &#123;<span class="comment">//如果使用缓存绘制失败，则会使用原声方法Canvas去draw</span></span><br><span class="line">                   ......</span><br><span class="line">                   <span class="keyword">if</span> (mCacheManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       mCacheManager.addDanmaku(drawItem);<span class="comment">//再次为词条弹幕构建缓存，以便下次使用缓存bitmap绘制</span></span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">			......</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;从截取的弹幕中遍历每一个，然后一一绘制。绘制步骤有如下几步：</p>
<ul>
<li>如果弹幕还没有到出现时间，则检查它有没有缓存，如果没有则为它建立缓存；</li>
<li>measure 测量，我们之前prepareCache已经为他们在buildCache时测量过了;</li>
<li>layout 布局，计算弹幕在屏幕上应该显示的位置；</li>
<li>draw 绘制弹幕。</li>
</ul>
<p>&#160; &#160; &#160; &#160;我们一步一步分析：<br>&#160; &#160; &#160; &#160;1）弹幕未到出现时间，检查是否建立缓存：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用CacheManagingDrawTask的addDanmaku方法</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addDanmaku</span><span class="params">(BaseDanmaku danmaku)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (mHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">			......</span><br><span class="line">			<span class="comment">//CacheHandler</span></span><br><span class="line">                  mHandler.obtainMessage(CacheHandler.ADD_DANMAKKU, danmaku).sendToTarget();</span><br><span class="line">            ......</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//CacheHandler</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">case</span> ADD_DANMAKKU:</span><br><span class="line">              BaseDanmaku item = (BaseDanmaku) msg.obj;</span><br><span class="line">              addDanmakuAndBuildCache(item);<span class="comment">//调用了addDanmakuAndBuildCache方法</span></span><br><span class="line">              <span class="keyword">break</span>;        </span><br><span class="line">      &#125;</span><br><span class="line">       <span class="comment">//调用了addDanmakuAndBuildCache方法</span></span><br><span class="line">          <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addDanmakuAndBuildCache</span><span class="params">(BaseDanmaku danmaku)</span> </span>&#123;</span><br><span class="line">           <span class="comment">//过时了 || 并且弹幕时间不在3屏弹幕时间内(因为mCaches只缓存了3屏时间内的所有弹幕，上面说过的),并且它不是直播弹幕。则不建立缓存</span></span><br><span class="line">              <span class="keyword">if</span> (danmaku.isTimeOut() || (danmaku.time &gt; mCacheTimer.currMillisecond + mContext.mDanmakuFactory.MAX_DANMAKU_DURATION &amp;&amp; !danmaku.isLive)) &#123;</span><br><span class="line">                  <span class="keyword">return</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">//优先级为0或者在过滤规则内，不建立缓存</span></span><br><span class="line">              <span class="keyword">if</span> (danmaku.priority == <span class="number">0</span> &amp;&amp; danmaku.isFiltered()) &#123;</span><br><span class="line">                  <span class="keyword">return</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              IDrawingCache&lt;?&gt; cache = danmaku.getDrawingCache();</span><br><span class="line">              <span class="keyword">if</span> (cache == <span class="keyword">null</span> || cache.get() == <span class="keyword">null</span>) &#123;<span class="comment">//如果弹幕没有缓存</span></span><br><span class="line">                  buildCache(danmaku, <span class="keyword">true</span>);<span class="comment">//建立缓存（buildCache方法我们上面分析过，就是用来建立缓存的）</span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;2）测量，这个我们上面再buildCache时分析过了，不再赘述；</p>
<p>&#160; &#160; &#160; &#160;3）布局：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用DanmakusRetainer的fix方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fix</span><span class="params">(BaseDanmaku danmaku, IDisplayer disp, Verifier verifier)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> type = danmaku.getType();</span><br><span class="line">       <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">           <span class="keyword">case</span> BaseDanmaku.TYPE_SCROLL_RL:</span><br><span class="line">               rldrInstance.fix(danmaku, disp, verifier);</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> BaseDanmaku.TYPE_SCROLL_LR:</span><br><span class="line">               lrdrInstance.fix(danmaku, disp, verifier);</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> BaseDanmaku.TYPE_FIX_TOP:</span><br><span class="line">               ftdrInstance.fix(danmaku, disp, verifier);</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> BaseDanmaku.TYPE_FIX_BOTTOM:</span><br><span class="line">               fbdrInstance.fix(danmaku, disp, verifier);</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> BaseDanmaku.TYPE_SPECIAL:</span><br><span class="line">               danmaku.layout(disp, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;类型太多了，我们只分析TYPE_SCROLL_RL类型弹幕其他的就不分析，有兴趣的可以自己分析一下其他的。接着会调用AlignTopRetainer的fix方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//保存需要显示的弹幕容器类（保存的一行只有一条弹幕，下面会说明的），内部持有一个以弹幕的y坐标排序的TreeSet集合，这个需要注意</span></span><br><span class="line"><span class="keyword">protected</span> Danmakus mVisibleDanmakus = <span class="keyword">new</span> Danmakus(Danmakus.ST_BY_YPOS);</span><br><span class="line">      </span><br><span class="line"><span class="comment">//AlignTopRetainer的fix方法</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fix</span><span class="params">(BaseDanmaku drawItem, IDisplayer disp, Verifier verifier)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (drawItem.isOutside())<span class="comment">//如果弹幕已经滚动到视图边界外，则不会为它布局</span></span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          <span class="keyword">float</span> topPos = <span class="number">0</span>;<span class="comment">//弹幕的y坐标</span></span><br><span class="line">          <span class="keyword">int</span> lines = <span class="number">0</span>;<span class="comment">//弹幕在第几行显示</span></span><br><span class="line">          <span class="keyword">boolean</span> shown = drawItem.isShown();<span class="comment">//弹幕是否已经显示</span></span><br><span class="line">          <span class="keyword">boolean</span> willHit = !shown &amp;&amp; !mVisibleDanmakus.isEmpty();<span class="comment">//是否会和其他弹幕碰撞</span></span><br><span class="line">          <span class="keyword">boolean</span> isOutOfVertialEdge = <span class="keyword">false</span>;<span class="comment">//弹幕y值是否超过试图高度</span></span><br><span class="line">          BaseDanmaku removeItem = <span class="keyword">null</span>;<span class="comment">//需要移除的弹幕</span></span><br><span class="line">          <span class="comment">//为即将显示的弹幕确认位置</span></span><br><span class="line">          <span class="keyword">if</span> (!shown) &#123;</span><br><span class="line">              mCancelFixingFlag = <span class="keyword">false</span>;</span><br><span class="line">              <span class="comment">// 确定弹幕位置开始</span></span><br><span class="line">              IDanmakuIterator it = mVisibleDanmakus.iterator();</span><br><span class="line">              <span class="comment">//这四个变量分别为：</span></span><br><span class="line">              <span class="comment">//insertItem ---- 确认目标弹幕插入到哪一行的同行参考弹幕</span></span><br><span class="line">              <span class="comment">//firstItem ---- 已经布局过的弹幕保存容器中的第一项</span></span><br><span class="line">              <span class="comment">//lastItem ---- 已经布局过的弹幕保存容器中最后一项</span></span><br><span class="line">              <span class="comment">//minRightRow ---- 已经布局过弹幕中x值最小的弹幕，即最左边的弹幕</span></span><br><span class="line">              BaseDanmaku insertItem = <span class="keyword">null</span>, firstItem = <span class="keyword">null</span>, lastItem = <span class="keyword">null</span>, minRightRow = <span class="keyword">null</span>;</span><br><span class="line">              <span class="keyword">boolean</span> overwriteInsert = <span class="keyword">false</span>;<span class="comment">//是否超出插入范围</span></span><br><span class="line">              <span class="comment">//遍历已经绘制过的弹幕，因为mVisibleDanmakus 内弹幕以y值排序的，所以按y值从小到大遍历</span></span><br><span class="line">              <span class="keyword">while</span> (!mCancelFixingFlag &amp;&amp; it.hasNext()) &#123;</span><br><span class="line">                  lines++;<span class="comment">//每次循环都会将行号+1</span></span><br><span class="line">                  BaseDanmaku item = it.next();</span><br><span class="line">                  </span><br><span class="line">                  <span class="keyword">if</span>(item == drawItem)&#123;<span class="comment">//如果已经布局过了，说明已经存在自己位置了</span></span><br><span class="line">                      insertItem = item;<span class="comment">//将布局过的弹幕复制给参考弹幕insertItem </span></span><br><span class="line">                      lastItem = <span class="keyword">null</span>;<span class="comment">//置空 lastItem </span></span><br><span class="line">                      shown = <span class="keyword">true</span>;<span class="comment">//shown 置为true，以便末尾不再执行加入mVisibleDanmakus逻辑</span></span><br><span class="line">                      willHit = <span class="keyword">false</span>;<span class="comment">//本身已经存在自己位置了，当然没有碰壁一说</span></span><br><span class="line">                      <span class="keyword">break</span>;<span class="comment">//怕被下面干扰晕的可以跳出去继续看</span></span><br><span class="line">                  &#125;</span><br><span class="line">			</span><br><span class="line">                  <span class="keyword">if</span> (firstItem == <span class="keyword">null</span>)<span class="comment">//找到已经布局过的弹幕第一项</span></span><br><span class="line">                      firstItem = item;</span><br><span class="line">			<span class="comment">//如果插入目标弹幕后，y值超过了视图高度</span></span><br><span class="line">                  <span class="keyword">if</span> (drawItem.paintHeight + item.getTop() &gt; disp.getHeight()) &#123;</span><br><span class="line">                      overwriteInsert = <span class="keyword">true</span>;<span class="comment">//则将超出插入范围标签置为true</span></span><br><span class="line">                      <span class="keyword">break</span>;<span class="comment">//怕晕的跳出循环</span></span><br><span class="line">                  &#125;</span><br><span class="line">			<span class="comment">//找出最左边的弹幕</span></span><br><span class="line">                  <span class="keyword">if</span> (minRightRow == <span class="keyword">null</span>) &#123;</span><br><span class="line">                      minRightRow = item;</span><br><span class="line">                  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                      <span class="keyword">if</span> (minRightRow.getRight() &gt;= item.getRight()) &#123;</span><br><span class="line">                          minRightRow = item;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">// 检查如果插入目标弹幕是否会和正在遍历的已经布局过的参考弹幕碰撞</span></span><br><span class="line">                  willHit = DanmakuUtils.willHitInDuration(disp, item, drawItem,</span><br><span class="line">                          drawItem.getDuration(), drawItem.getTimer().currMillisecond);</span><br><span class="line">                  <span class="keyword">if</span> (!willHit) &#123;<span class="comment">//如果没有碰撞</span></span><br><span class="line">                      insertItem = item;<span class="comment">//则将它复制给参考弹幕insertItem </span></span><br><span class="line">                      <span class="keyword">break</span>;<span class="comment">//然后跳出循环，下去确定位置</span></span><br><span class="line">                  &#125;<span class="comment">/*如果有碰撞，则继续弹幕缩小添加范围，寻找可以添加的条件，最后出while循环，下去布局*/</span></span><br><span class="line">                  </span><br><span class="line">			</span><br><span class="line">                  lastItem = item;<span class="comment">//暂时找到已经布局过的弹幕最后一项，然后继续循环</span></span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">boolean</span> checkEdge = <span class="keyword">true</span>;</span><br><span class="line">              <span class="keyword">if</span> (insertItem != <span class="keyword">null</span>) &#123;<span class="comment">//已经布局过了||目标弹幕不会碰壁可以插入</span></span><br><span class="line">                  <span class="keyword">if</span> (lastItem != <span class="keyword">null</span>)<span class="comment">//目标弹幕插入，y值即为上一次遍历的弹幕的底部</span></span><br><span class="line">                      topPos = lastItem.getBottom();</span><br><span class="line">                  <span class="keyword">else</span><span class="comment">//已经布局过了，则y的位置不变</span></span><br><span class="line">                      topPos = insertItem.getTop();</span><br><span class="line">                      </span><br><span class="line">                  <span class="keyword">if</span> (insertItem != drawItem)&#123;<span class="comment">//如果目标弹幕可以插入</span></span><br><span class="line">                   <span class="comment">//这里需要注意，因为一行可以放n多条弹幕，只要前后不碰撞就行；</span></span><br><span class="line">                   <span class="comment">//所以下次我们在同一行插入弹幕判断碰壁时，当然要和这行最后一条弹幕去判断；</span></span><br><span class="line">                   <span class="comment">//因此我们移除前一条弹幕，放入插入的目标弹幕，下次添加弹幕判断时就和目标弹幕判断，然后这么循环下去</span></span><br><span class="line">                      removeItem = insertItem;</span><br><span class="line">                      </span><br><span class="line">                      shown = <span class="keyword">false</span>;<span class="comment">//置为false，以便mVisibleDanmakus 添加还未布局的新弹幕</span></span><br><span class="line">                  &#125;</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (overwriteInsert &amp;&amp; minRightRow != <span class="keyword">null</span>) &#123;<span class="comment">//没有空行可以插入</span></span><br><span class="line">                  topPos = minRightRow.getTop();<span class="comment">//暂时放到最最左边的弹幕那一行（excuse me ？？？）</span></span><br><span class="line">                  checkEdge = <span class="keyword">false</span>;<span class="comment">//不做范围检查</span></span><br><span class="line">                  shown = <span class="keyword">false</span>;</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lastItem != <span class="keyword">null</span>) &#123;<span class="comment">//找不到插入的位置</span></span><br><span class="line">                  topPos = lastItem.getBottom();<span class="comment">//暂时放到最低位置的弹幕下面，下面检测边界时会酌情河蟹</span></span><br><span class="line">                  willHit = <span class="keyword">false</span>;<span class="comment">//置false碰壁标志</span></span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstItem != <span class="keyword">null</span>) &#123;<span class="comment">////mVisibleDanmakus只有第一条数据，截取弹幕集的第二条弹幕没有和第一条碰壁时</span></span><br><span class="line">                  topPos = firstItem.getTop();<span class="comment">//此时第二条弹幕和第一条在同一行</span></span><br><span class="line">                  removeItem = firstItem;</span><br><span class="line">                  shown = <span class="keyword">false</span>;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;<span class="comment">//mVisibleDanmakus 没有数据，截取弹幕集的第一条弹幕</span></span><br><span class="line">                  topPos = <span class="number">0</span>;<span class="comment">//第一条弹幕当然在最上面</span></span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (checkEdge) &#123;<span class="comment">//如果检查范围</span></span><br><span class="line">               <span class="comment">//检查是否超出布局范围</span></span><br><span class="line">                  isOutOfVertialEdge = isOutVerticalEdge(overwriteInsert, drawItem, disp, topPos, firstItem,</span><br><span class="line">                          lastItem);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (isOutOfVertialEdge) &#123;<span class="comment">//如果超出布局范围，等待河蟹</span></span><br><span class="line">                  topPos = <span class="number">0</span>;</span><br><span class="line">                  willHit = <span class="keyword">true</span>;</span><br><span class="line">                  lines = <span class="number">1</span>;</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (removeItem != <span class="keyword">null</span>) &#123;<span class="comment">//上面可以插入目标弹幕的逻辑用上了</span></span><br><span class="line">                  lines--;<span class="comment">//因为参考弹幕和目标弹幕在同一行，但是每进入while循环一次就将行号+1，所有要减回去和参考弹幕保持相同行号</span></span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (topPos == <span class="number">0</span>) &#123;<span class="comment">//方便加入容器</span></span><br><span class="line">                  shown = <span class="keyword">false</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">	<span class="comment">//这是河蟹规则，都是在设置DanmakuContext时指定的，比如最大行数限制，重复限制等等。</span></span><br><span class="line">	<span class="comment">//这里限于篇幅已经太长了，也实在写不动了，就不再跟下去了。内部逻辑也不难，大家有兴趣可以自己看看。</span></span><br><span class="line">          <span class="keyword">if</span> (verifier != <span class="keyword">null</span> &amp;&amp; verifier.skipLayout(drawItem, topPos, lines, willHit)) &#123;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (isOutOfVertialEdge) &#123;<span class="comment">//mVisibleDanmakus中所有弹幕绘制出来都超出范围了</span></span><br><span class="line">              clear();</span><br><span class="line">          &#125;</span><br><span class="line">	<span class="comment">//这才是真正确认弹幕位置的地方</span></span><br><span class="line">          drawItem.layout(disp, drawItem.getLeft(), topPos);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (!shown) &#123;<span class="comment">//如果还未显示，则加入即将显示的容器中。可以看到，最终会把所有截取的弹幕加入到这个容器里</span></span><br><span class="line">              mVisibleDanmakus.removeItem(removeItem);<span class="comment">//移除同一行之前的参考弹幕，保持保存的一行只有一条弹幕，上面说明过</span></span><br><span class="line">              mVisibleDanmakus.addItem(drawItem);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//清除容器，重新放入新的内容</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          mCancelFixingFlag = <span class="keyword">true</span>;</span><br><span class="line">          mVisibleDanmakus.clear();</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这绝对是我写的注释最多的方法了ToT。。。。。。其实思路挺好理解的，通俗地讲就是这样的过程：</p>
<ul>
<li><strong>先添往最第一行添加一条弹幕，把它存到一个容器里（这个容器会把新添加进来的弹幕按照y值从小到大排序，而且容器只保存每一行的最后一条弹幕）</strong>。</li>
<li><strong>然后添加第二条弹幕，从第一行开始添加，先判断和第一条弹幕会不会碰壁，如果不会碰壁则添加到这一行，然后容器内移除之前第一条的弹幕，保存这一条弹幕；如果会碰壁则添加到下一行，然后容器保存这条弹幕</strong>；</li>
<li><strong>然后添加第三条，继续从第一行开始添加，先判断和第一条……(重复第二条的逻辑)……</strong>；<br>。。。。。。</li>
</ul>
<p>&#160; &#160; &#160; &#160;就是这么个思路，但是写起来真心不是随意就能写出来的。即使先不说写，把这个思路想出来，让我去设计一套规则，估计都相当困难啊。唉，人与人之间的差距始终在思维。。。。。。</p>
<p>&#160; &#160; &#160; &#160;扯远了，我们继续回归正题，上面逻辑完成了弹幕定位规则(内部那个layout接下来再讲)，限于篇幅，我只挑一个检查碰撞的代码贴出来分析，其它的请有兴趣者自行跟踪。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">willHitInDuration</span><span class="params">(IDisplayer disp, BaseDanmaku d1, BaseDanmaku d2,</span><br><span class="line">          <span class="keyword">long</span> duration, <span class="keyword">long</span> currTime)</span> </span>&#123;<span class="comment">//disp, item, drawItem, drawItem.getDuration(), drawItem.getTimer().currMillisecond</span></span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> type1 = d1.getType();</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> type2 = d2.getType();</span><br><span class="line">      <span class="comment">// allow hit if different type 不同类型的弹幕允许碰撞</span></span><br><span class="line">      <span class="keyword">if</span>(type1 != type2)</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span>(d1.isOutside())&#123;<span class="comment">//item已经跑出视图了，不存在碰撞问题</span></span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">long</span> dTime = d2.time - d1.time;</span><br><span class="line">      <span class="keyword">if</span> (dTime &lt;= <span class="number">0</span>)<span class="comment">//drawItem在item前面，已经碰撞了</span></span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      <span class="comment">//两者出现时间已经相差一条弹幕时间了 || item超时跑出去了 || drawItem超时 ，都不会碰撞    </span></span><br><span class="line">      <span class="keyword">if</span> (Math.abs(dTime) &gt;= duration || d1.isTimeOut() || d2.isTimeOut()) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//item和drawItem都是顶部或者底部固定弹幕，因为在同一行，必定碰撞</span></span><br><span class="line">      <span class="keyword">if</span> (type1 == BaseDanmaku.TYPE_FIX_TOP || type1 == BaseDanmaku.TYPE_FIX_BOTTOM) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//调用checkHitAtTime方法</span></span><br><span class="line">      <span class="keyword">return</span> checkHitAtTime(disp, d1, d2, currTime) </span><br><span class="line">              || checkHitAtTime(disp, d1, d2,  d1.time + d1.getDuration());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//调用checkHitAtTime方法</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkHitAtTime</span><span class="params">(IDisplayer disp, BaseDanmaku d1, BaseDanmaku d2, <span class="keyword">long</span> time)</span></span>&#123;<span class="comment">//time = currTime || time = item.time + item.duration</span></span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">float</span>[] rectArr1 = d1.getRectAtTime(disp, time);<span class="comment">//time获得item在视图的（l，t，r，b）</span></span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">float</span>[] rectArr2 = d2.getRectAtTime(disp, time);<span class="comment">//time获得drawItem在视图的（l，t，r，b）</span></span><br><span class="line">      <span class="keyword">if</span> (rectArr1 == <span class="keyword">null</span> || rectArr2 == <span class="keyword">null</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">return</span> checkHit(d1.getType(), d2.getType(), rectArr1, rectArr2);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//调用checkHit方法    </span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkHit</span><span class="params">(<span class="keyword">int</span> type1, <span class="keyword">int</span> type2, <span class="keyword">float</span>[] rectArr1,</span><br><span class="line">          <span class="keyword">float</span>[] rectArr2)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(type1 != type2)</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">if</span> (type1 == BaseDanmaku.TYPE_SCROLL_RL) &#123;<span class="comment">//只要drawItem的left小于item的right就碰撞了</span></span><br><span class="line">          <span class="comment">// hit if left2 &lt; right1</span></span><br><span class="line">          <span class="keyword">return</span> rectArr2[<span class="number">0</span>] &lt; rectArr1[<span class="number">2</span>];</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (type1 == BaseDanmaku.TYPE_SCROLL_LR)&#123;</span><br><span class="line">          <span class="comment">// hit if right2 &gt; left1</span></span><br><span class="line">          <span class="keyword">return</span> rectArr2[<span class="number">2</span>] &gt; rectArr1[<span class="number">0</span>];</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//R2LDanmaku的getRectAtTime方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">float</span>[] getRectAtTime(IDisplayer displayer, <span class="keyword">long</span> time) &#123;<span class="comment">//time = currTime || time = item.time + item.duration</span></span><br><span class="line">      <span class="keyword">if</span> (!isMeasured())</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">float</span> left = getAccurateLeft(displayer, time);<span class="comment">//获得此时弹幕在视图的x坐标</span></span><br><span class="line">      <span class="keyword">if</span> (RECT == <span class="keyword">null</span>) &#123;</span><br><span class="line">          RECT = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">4</span>];</span><br><span class="line">      &#125;</span><br><span class="line">      RECT[<span class="number">0</span>] = left;<span class="comment">//left</span></span><br><span class="line">      RECT[<span class="number">1</span>] = y;<span class="comment">//top</span></span><br><span class="line">      RECT[<span class="number">2</span>] = left + paintWidth;<span class="comment">//right</span></span><br><span class="line">      RECT[<span class="number">3</span>] = y + paintHeight;<span class="comment">//bottom</span></span><br><span class="line">      <span class="keyword">return</span> RECT;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//R2LDanmaku的getAccurateLeft方法</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">float</span> <span class="title">getAccurateLeft</span><span class="params">(IDisplayer displayer, <span class="keyword">long</span> currTime)</span> </span>&#123;<span class="comment">//currTime = timer.currTime || currTime = item.time + item.duration</span></span><br><span class="line">      <span class="keyword">long</span> elapsedTime = currTime - time;<span class="comment">//当前时间 - 弹幕出现时间</span></span><br><span class="line">......</span><br><span class="line"><span class="comment">//因此返回弹幕位于视图的x坐标，即视图宽度 - 弹幕已经显示了多少秒 * 每秒移动步长</span></span><br><span class="line"><span class="keyword">return</span> displayer.getWidth() - elapsedTime * mStepX;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;检查碰撞逻辑比较简单，就是先根据当前时间就算出两条弹幕的位置（l1，t1，r1，b1），看看是否前面弹幕的 r1 小于后面弹幕的 l1；再根据前面弹幕的结束时间，计算出两条弹幕的位置（l2，t2，r2，b2）再次看看是否前面弹幕的 r2小于后面弹幕的 l2。只有两条都满足才不会碰撞。</p>
<p>&#160; &#160; &#160; &#160;好了检测碰撞就先到这里，然后继续回到AlignTopRetainer的fix方法，还有一个drawItem.layout(disp, drawItem.getLeft(), topPos);没讲呢，这才是真正确认弹幕位置的地方，继续查看L2RDanmaku的layout方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">layout</span><span class="params">(IDisplayer displayer, <span class="keyword">float</span> x, <span class="keyword">float</span> y)</span> </span>&#123;<span class="comment">//disp, drawItem.getLeft(), topPos</span></span><br><span class="line">    <span class="keyword">if</span> (mTimer != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">long</span> currMS = mTimer.currMillisecond;</span><br><span class="line">        <span class="keyword">long</span> deltaDuration = currMS - time;<span class="comment">//计算出出现时间和当前时间的时间差</span></span><br><span class="line">        <span class="keyword">if</span> (deltaDuration &gt; <span class="number">0</span> &amp;&amp; deltaDuration &lt; duration.value) &#123;<span class="comment">//如果还没有到出现时间或者超出弹幕时间</span></span><br><span class="line">            <span class="keyword">this</span>.x = getAccurateLeft(displayer, currMS);<span class="comment">//计算出当前时间弹幕的x坐标，上面刚讲过</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.isShown()) &#123;</span><br><span class="line">                <span class="keyword">this</span>.y = y;<span class="comment">//把上面计算好的y值赋过来</span></span><br><span class="line">                <span class="keyword">this</span>.setVisibility(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            mLastTime = currMS;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mLastTime = currMS;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.setVisibility(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这样弹幕的位置也就确定了，layout步骤就走完了。下一步就是draw步骤了。</p>
<p>&#160; &#160; &#160; &#160;4）绘制弹幕：<br>&#160; &#160; &#160; &#160;赶紧回到DanmakuRenderer的draw方法，这个时候千万不要把自己搞晕了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DanmakuRenderer的draw方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RenderingState <span class="title">draw</span><span class="params">(IDisplayer disp, IDanmakus danmakus, <span class="keyword">long</span> startRenderTime)</span> </span>&#123;</span><br><span class="line">        ......       </span><br><span class="line">        IDanmakuIterator itr = danmakus.iterator();</span><br><span class="line">        ......      </span><br><span class="line"></span><br><span class="line">        BaseDanmaku drawItem = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (itr.hasNext()) &#123;</span><br><span class="line"></span><br><span class="line">            drawItem = itr.next();</span><br><span class="line"></span><br><span class="line">			......</span><br><span class="line">			...检查是否建立缓存...            </span><br><span class="line">			......</span><br><span class="line"></span><br><span class="line">            ...是否测量...</span><br><span class="line"></span><br><span class="line">            ...layout布局...</span><br><span class="line"></span><br><span class="line">            <span class="comment">// draw //绘制弹幕</span></span><br><span class="line">            <span class="keyword">if</span> (!drawItem.isOutside() &amp;&amp; drawItem.isShown()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (drawItem.lines == <span class="keyword">null</span> &amp;&amp; drawItem.getBottom() &gt; disp.getHeight()) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;    <span class="comment">// skip bottom outside danmaku ，忽略超过视图底部的弹幕</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//开始绘制</span></span><br><span class="line">                <span class="keyword">int</span> renderingType = drawItem.draw(disp);</span><br><span class="line">                <span class="keyword">if</span>(renderingType == IRenderer.CACHE_RENDERING) &#123;<span class="comment">//如果是使用缓存bitmap绘制的</span></span><br><span class="line">                    ......</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(renderingType == IRenderer.TEXT_RENDERING) &#123;<span class="comment">//如果使用缓存绘制失败，则会使用原声方法Canvas去draw</span></span><br><span class="line">                    ......</span><br><span class="line">                    <span class="keyword">if</span> (mCacheManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        mCacheManager.addDanmaku(drawItem);<span class="comment">//再次为词条弹幕构建缓存，以便下次使用缓存bitmap绘制</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">				......    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;继续跟踪int renderingType = drawItem.draw(disp) 这里：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BaseDanmaku的draw方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">draw</span><span class="params">(IDisplayer displayer)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> displayer.draw(<span class="keyword">this</span>);<span class="comment">//调用AndroidDisplayer的draw方法</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//调用AndroidDisplayer的draw方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">draw</span><span class="params">(BaseDanmaku danmaku)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">float</span> top = danmaku.getTop();<span class="comment">//弹幕在视图的y值</span></span><br><span class="line">       <span class="keyword">float</span> left = danmaku.getLeft();<span class="comment">//弹幕在视图的x值</span></span><br><span class="line">       <span class="keyword">if</span> (canvas != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">		......</span><br><span class="line">			</span><br><span class="line">           <span class="comment">// drawing cache</span></span><br><span class="line">           <span class="keyword">boolean</span> cacheDrawn = <span class="keyword">false</span>;</span><br><span class="line">           <span class="keyword">int</span> result = IRenderer.CACHE_RENDERING;</span><br><span class="line">           IDrawingCache&lt;?&gt; cache = danmaku.getDrawingCache();</span><br><span class="line">           <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;<span class="comment">//如果弹幕有缓存</span></span><br><span class="line">            <span class="comment">//取出缓存</span></span><br><span class="line">               DrawingCacheHolder holder = (DrawingCacheHolder) cache.get();</span><br><span class="line">               <span class="keyword">if</span> (holder != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//DrawingCacheHolder的draw方法，我们在上面的buildCache时分析过了，将每一条弹幕的bitmap绘制到视图的canvas上</span></span><br><span class="line">                   cacheDrawn = holder.draw(canvas, left, top, alphaPaint);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (!cacheDrawn) &#123;<span class="comment">//如果缓存绘制失败</span></span><br><span class="line">			......</span><br><span class="line">			<span class="comment">//则使用Android原生的canvas.drawText等方法绘制，drawDanmaku方法我们上面buildCache时也分析过</span></span><br><span class="line">               drawDanmaku(danmaku, canvas, left, top, <span class="keyword">false</span>);</span><br><span class="line">               result = IRenderer.TEXT_RENDERING;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">return</span> result;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> IRenderer.NOTHING_RENDERING;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;上面逻辑比较简单，先查看弹幕有没有缓存，如果有，就使用缓存绘制。在上面的buildCache时我们知道，缓存绘制的每一条弹幕都是一条bitmap，所以这里用缓存也是将bitmap绘制到视图的Canvas中。如果使用缓存绘制失败，会调用drawDanmaku方法，这个方法我们在上面的buildCache也分析过，则使用Android原生的canvas.drawText等绘制。</p>
<p>&#160; &#160; &#160; &#160;这样弹幕就被绘制到视图界面上了。        </p>
<p>&#160; &#160; &#160; &#160;终于完了，以上就是DanmakuFlameMaster的流程分析过程了，分析的快吐学了ToT。。。。。。</p>
<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><p>&#160; &#160; &#160; &#160;上面刚开始奖CacheManagingDrawTask时曾经说过，也可以不用CacheManagingDrawTask，直接使用DrawTask，只要将<strong>DanmakuView</strong>的<strong>mEnableDanmakuDrwaingCache</strong>变量改为false就可以了。这样改动之后就用不上工程里那些so库了，也就不用建立那么复杂的缓存机制。</p>
<p>&#160; &#160; &#160; &#160;还有一点区别就是使用CacheManagingDrawTask画出来的每一条弹幕都是bitmap，而用DrawTask的弹幕都是Canvas.drawText画出来的。</p>
<p>&#160; &#160; &#160; &#160;限于篇幅，DrawTask就不分析了，逻辑比CacheManagingDrawTask简单多了，大家有兴趣的自己看看。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>&#160; &#160; &#160; &#160;DanmakuFlameMaster到此就分析完全了，简单总结一下流程就是：</p>
<ul>
<li>加载弹幕资源</li>
<li>开启缓存机制，不断建立缓存和回收</li>
<li>开始绘制任务，根据定时器时间确定弹幕位置，绘制弹幕</li>
</ul>
<p>&#160; &#160; &#160; &#160;这篇文章写的过程中也是十分蛋疼的，写的我差点over了。因为DanmakuFlameMaster源码实在太复杂了，坑非常多，所以很多细节都没有顾及。下次我绝对不会再写这么长的文章了，身体和脑力真心伤不起啊。赶紧休息一下<del>~</del>~~~~</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android属性动画流程分析]]></title>
      <url>http://windrunnerlihuan.com/2016/06/24/Android%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<hr>
<blockquote>
<p>&#160; &#160; &#160; &#160;<strong>摘要</strong>：Google在Android3.0之后给我们带来了属性动画，是真正意义上的改变属性。对比以前的Tween动画，只能作用于View，而且Tween动画改变的只是View的绘制效果，View真正的属性并没有改变。比如，一个按钮做平移的动画，虽然按钮的确做了平移，但按钮可点击的区域并没随着平移而改变，还是在原来的位置。而属性动画则可以改变真正的属性，从而实现按钮平移时点击区域也跟着平移。通俗点说，属性动画其实就是在一定时间内，按照一定规律来改变对象的属性，从而使对象展现出动画效果。</p>
</blockquote>
<a id="more"></a>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&#160; &#160; &#160; &#160; Google在Android3.0之后给我们带来了属性动画，是真正意义上的改变属性。对比以前的Tween动画，只能作用于View，而且Tween动画改变的只是View的绘制效果，View真正的属性并没有改变。比如，一个按钮做平移的动画，虽然按钮的确做了平移，但按钮可点击的区域并没随着平移而改变，还是在原来的位置。而属性动画则可以改变真正的属性，从而实现按钮平移时点击区域也跟着平移。通俗点说，属性动画其实就是在一定时间内，按照一定规律来改变对象的属性，从而使对象展现出动画效果。</p>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>&#160; &#160; &#160; &#160;我们要了解属性动画的原理，首先要知道他的用法。先整一个比较大众的吧：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ObjectAnimator  </span><br><span class="line">  .ofInt(target,propName,values[])  </span><br><span class="line">  .setInterpolator(LinearInterpolator)  </span><br><span class="line">  .setEvaluator(IntEvaluator)  </span><br><span class="line">  .setDuration(<span class="number">1000</span>)  </span><br><span class="line">  .start();</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这个应该都会吧，设置目标view，作用的属性，动画时长；设置插值器、估值器，这两个玩意设置最多的应该是插值器，估值器设置的应该比较少。这两个东西我们下面会逐一跟踪其踪迹；（当然还有对动画过程的回调监听，比如addListener，然后监听onAnimationStart、onAnimationEnd等等回调。不过我们这里没设，下面篇幅为讲到此处功能）；最后start,动画开始。</p>
<h2 id="猜想与假设"><a href="#猜想与假设" class="headerlink" title="猜想与假设"></a>猜想与假设</h2><p>&#160; &#160; &#160; &#160; 一般的对象中的某个属性，如果要改变其值，要么是这个属性对外<strong>public</strong>，拿到对象后可以直接修改；要么这个对象的类有自己的<strong>get/set</strong>方法。但这都是理想的情况，如果不满足以上条件，如果想改变对象属性的值，就只能通过<strong>反射</strong>了。我们先这样假设，然后往下逐一验证。</p>
<p>&#160; &#160; &#160; &#160; 再者属性动画，我们断章取义一下，既然有动画这个词在内，就会有在规定时间内按固定规则对象属性的改变，就像函数一样，y=f(x)。属性动画也一样，y好比属性值property，x好比时间time，f关系就是插值器/估值器（Interpolator/TypeEvaluator）的作用。（先这么假设吧，是否合理我们往下深挖就知道了）</p>
<h1 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h1><p>&#160; &#160; &#160; &#160; 我们按着上述猜测，然后进入验证阶段，直接整源码吧。源码文件不难找，并且都在两个固定目录，frameworks\base\core\java\android\animation\ 和 frameworks\base\core\java\android\view\animation\ 下。</p>
<blockquote>
<p>&#160; &#160; &#160; &#160; 阅读源码不一定要把 <a href="http://source.android.com/source/index.html" target="_blank" rel="external">源码</a> 整个下载下来，比如有的在SDK里本来就有的文件，用 AS 或者 Eclipse 都可以直接看。不过我推荐有时间还是把重要的源码都下载下来，用<strong>Source Insight</strong> 或者 <strong>Sublime Text</strong> 来查看。<br>&#160; &#160; &#160; &#160;其次，阅读源码一方面能让我们更清晰的理解Android SDK提供的API的流程原理，有助于开发人员更好的使用这些功能，遇到坑会有更好的解决方案。另一方面，也能够掌握其中的思想，因为一切业务都是思想的实体化，掌握了思想，才能在以后遇到问题或者需求的时候，能很快从脑中勾勒出解决思路，而不至于一脸懵逼无从下手。</p>
</blockquote>
<p>&#160; &#160; &#160; &#160; 根据上述例子，一步一步分析。</p>
<h2 id="主流程源码"><a href="#主流程源码" class="headerlink" title="主流程源码"></a>主流程源码</h2><h3 id="ofInt"><a href="#ofInt" class="headerlink" title="ofInt"></a>ofInt</h3><p>&#160; &#160; &#160; &#160;先从ofInt入手，例如这么用：.ofInt(view, “translationX”, 100)。挑一个简单明了的重载方法，其实其他的也是相同的道理。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ObjectAnimator <span class="title">ofInt</span><span class="params">(Object target, String propertyName, <span class="keyword">int</span>... values)</span> </span>&#123;</span><br><span class="line">    ObjectAnimator anim = <span class="keyword">new</span> ObjectAnimator(target, propertyName);</span><br><span class="line">    anim.setIntValues(values);</span><br><span class="line">    <span class="keyword">return</span> anim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;new了一个ObjectAnimator，构造方法传入target和propName，这么不难。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">ObjectAnimator</span><span class="params">(Object target, String propertyName)</span> </span>&#123;</span><br><span class="line">       setTarget(target);</span><br><span class="line">       setPropertyName(propertyName);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//有两个方法，以此往下</span></span><br><span class="line"><span class="comment">//设置目标对象target赋给属性动画全局变量mTarget </span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTarget</span><span class="params">(@Nullable Object target)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Object oldTarget = getTarget();</span><br><span class="line">       <span class="keyword">if</span> (oldTarget != target) &#123;</span><br><span class="line">           mTarget = target == <span class="keyword">null</span> ? <span class="keyword">null</span> : <span class="keyword">new</span> WeakReference&lt;Object&gt;(target);</span><br><span class="line">           <span class="comment">// New target should cause re-initialization prior to starting</span></span><br><span class="line">           mInitialized = <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//同上，将propertyName赋给mPropertyName </span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPropertyName</span><span class="params">(@NonNull String propertyName)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// mValues could be null if this is being constructed piecemeal. Just record the</span></span><br><span class="line">       <span class="comment">// propertyName to be used later when setValues() is called if so.</span></span><br><span class="line">       <span class="comment">// 此时mValues为空，可以忽略判断逻辑</span></span><br><span class="line">       <span class="keyword">if</span> (mValues != <span class="keyword">null</span>) &#123;</span><br><span class="line">           PropertyValuesHolder valuesHolder = mValues[<span class="number">0</span>];</span><br><span class="line">           String oldName = valuesHolder.getPropertyName();</span><br><span class="line">           valuesHolder.setPropertyName(propertyName);</span><br><span class="line">           mValuesMap.remove(oldName);</span><br><span class="line">           mValuesMap.put(propertyName, valuesHolder);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//赋值给全局变量</span></span><br><span class="line">       mPropertyName = propertyName;</span><br><span class="line">       <span class="comment">// New property/values/target should cause re-initialization prior to starting</span></span><br><span class="line">       mInitialized = <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;记录完target和propName，调用setIntValues。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIntValues</span><span class="params">(<span class="keyword">int</span>... values)</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 此时mValues为空</span></span><br><span class="line">    <span class="keyword">if</span> (mValues == <span class="keyword">null</span> || mValues.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// No values yet - this animator is being constructed piecemeal. Init the values with</span></span><br><span class="line">        <span class="comment">// whatever the current propertyName is</span></span><br><span class="line">        <span class="keyword">if</span> (mProperty != <span class="keyword">null</span>) &#123; <span class="comment">// mProperty 也为空</span></span><br><span class="line">            setValues(PropertyValuesHolder.ofInt(mProperty, values));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//因此会走到这里</span></span><br><span class="line">            setValues(PropertyValuesHolder.ofInt(mPropertyName, values));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.setIntValues(values);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;最后会走到setValues(PropertyValuesHolder.ofInt(mPropertyName, values)); 这里把我们传入的propName和values作为参数，又调用了PropertyValuesHolder的ofInt方法，我们先看里面这个，外面的那个setValues待会儿再看。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PropertyValuesHolder <span class="title">ofInt</span><span class="params">(String propertyName, <span class="keyword">int</span>... values)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> IntPropertyValuesHolder(propertyName, values);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//IntPropertyValuesHolder是PropertyValuesHolder的子类，也是个内部类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">IntPropertyValuesHolder</span><span class="params">(String propertyName, <span class="keyword">int</span>... values)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(propertyName);<span class="comment">//这里会调用父类的构造</span></span><br><span class="line"> setIntValues(values);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//父类一个参数构造方法如下，将propertyName赋给全局变量mPropertyName </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">PropertyValuesHolder</span><span class="params">(String propertyName)</span> </span>&#123;</span><br><span class="line">    mPropertyName = propertyName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIntValues</span><span class="params">(<span class="keyword">int</span>... values)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.setIntValues(values);<span class="comment">//同样会调用父类的setIntValues方法</span></span><br><span class="line">    mIntKeyframes = (Keyframes.IntKeyframes) mKeyframes;<span class="comment">// 将父类方法得到的mKeyframes 再付给mIntKeyframes </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//父类setIntValues方法，为mValueType 赋值，同时为利用参数values调用KeyframeSet.ofInt(values)为mKeyframes赋值 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIntValues</span><span class="params">(<span class="keyword">int</span>... values)</span> </span>&#123;</span><br><span class="line">    mValueType = <span class="keyword">int</span>.class;</span><br><span class="line">    mKeyframes = KeyframeSet.ofInt(values);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160; 我们可以看到，PropertyValuesHolder的ofInt方法让器内部存储了我们的propName，然后存储了我们的mValueType，即 int.class ，并且保存了一个新的变量 <strong>mIntKeyframes</strong>。<br> &#160; &#160; &#160; &#160; 这个<strong>mIntKeyframes</strong>由 KeyframeSet.ofInt(values) 得到，顾名思义，这玩意儿应该是关键帧之类的意思吧。我们联想一下关键帧，视频不就是一帧一帧的画面组成么，其中有参考帧和关键帧，且参考帧解码也依赖于关键帧，因此关键帧是视频图像流畅完整的保证（扯远了，我们先这么理解吧，然后再验证我们的猜测）。<br>  &#160; &#160; &#160; &#160; <strong>mIntKeyframes</strong>类型为Keyframes，是个接口，实现类型为KeyframeSet。看着名字应该是关键帧集合吧，每个关键帧应该保存动画time/value(时间/值)对。那么继续验证，找到KeyframeSet.ofInt(values)方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> KeyframeSet <span class="title">ofInt</span><span class="params">(<span class="keyword">int</span>... values)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> numKeyframes = values.length;</span><br><span class="line">    IntKeyframe keyframes[] = <span class="keyword">new</span> IntKeyframe[Math.max(numKeyframes,<span class="number">2</span>)];<span class="comment">//最少应该有2帧</span></span><br><span class="line">    <span class="keyword">if</span> (numKeyframes == <span class="number">1</span>) &#123;<span class="comment">//如果只传了一个参数，比如我们前面给"translationX"属性的values传入移动300            </span></span><br><span class="line">     keyframes[<span class="number">0</span>] = (IntKeyframe) Keyframe.ofInt(<span class="number">0f</span>);<span class="comment">// 起始帧，属性保持原样</span></span><br><span class="line">        keyframes[<span class="number">1</span>] = (IntKeyframe) Keyframe.ofInt(<span class="number">1f</span>, values[<span class="number">0</span>]);<span class="comment">//结束帧，直接到达结果</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//可以设置某个属性的多个值，比如动态改变view的alpha值，例如1.0，0.8，0.4......</span></span><br><span class="line">        keyframes[<span class="number">0</span>] = (IntKeyframe) Keyframe.ofInt(<span class="number">0f</span>, values[<span class="number">0</span>]);<span class="comment">//起始帧</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; numKeyframes; ++i) &#123;<span class="comment">//后续n帧</span></span><br><span class="line">         <span class="comment">//注意里面有个么一个片段:(float) i / (numKeyframes - 1)，这是按values个数等比例划分的</span></span><br><span class="line">            keyframes[i] =</span><br><span class="line">                    (IntKeyframe) Keyframe.ofInt((<span class="keyword">float</span>) i / (numKeyframes - <span class="number">1</span>), values[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> IntKeyframeSet(keyframes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160; 这里应该看到KeyframeSet.ofInt(values)方法，根据values的长度构造keyframes数组，然后分别通过Keyframe的ofInt方法，去构造keyframe对象。老规矩，继续看Keyframe.ofInt如何构造Keyframe：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> mValue;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Keyframe <span class="title">ofInt</span><span class="params">(<span class="keyword">float</span> fraction)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> IntKeyframe(fraction);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//也就简单存了一下fraction，此时value默认值为0</span></span><br><span class="line">   IntKeyframe(<span class="keyword">float</span> fraction) &#123;</span><br><span class="line">       mFraction = fraction;</span><br><span class="line">       mValueType = <span class="keyword">int</span>.class;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Keyframe <span class="title">ofInt</span><span class="params">(<span class="keyword">float</span> fraction, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> IntKeyframe(fraction, value);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//也就简单存了一下fraction，value等</span></span><br><span class="line">   IntKeyframe(<span class="keyword">float</span> fraction, <span class="keyword">int</span> value) &#123;</span><br><span class="line">       mFraction = fraction;</span><br><span class="line">       mValue = value;</span><br><span class="line">       mValueType = <span class="keyword">int</span>.class;</span><br><span class="line">       mHasValue = <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;也就简单存了一下fraction和value，每个fraction对应相应的value。前面注释我特意写了个注意，这个fraction是按照帧的个数n存的，起始为0，结束为1，也就是个个数为n的等差数列an={0，1/(n-1), 2/(n-1), 3/(n-1)，……, (n-2)/(n-1), 1}。<br>&#160; &#160; &#160; &#160;然后我们看它的 return new IntKeyframeSet(keyframes);<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//IntKeyframeSet构造方法，调其父类KeyframeSet构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">IntKeyframeSet</span><span class="params">(IntKeyframe... keyframes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(keyframes);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//KeyframeSet构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">KeyframeSet</span><span class="params">(Keyframe... keyframes)</span> </span>&#123;</span><br><span class="line">    mNumKeyframes = keyframes.length;</span><br><span class="line">    mKeyframes = <span class="keyword">new</span> ArrayList&lt;Keyframe&gt;();</span><br><span class="line">    mKeyframes.addAll(Arrays.asList(keyframes));</span><br><span class="line">    mFirstKeyframe = mKeyframes.get(<span class="number">0</span>);</span><br><span class="line">    mLastKeyframe = mKeyframes.get(mNumKeyframes - <span class="number">1</span>);</span><br><span class="line">    mInterpolator = mLastKeyframe.getInterpolator();<span class="comment">//这个插值器是null，感觉没什么卵用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;存了有多少关键帧，开始帧，结束帧，以及插值器。</p>
<p>&#160; &#160; &#160; &#160;到这里PropertyValuesHolder.ofInt(mPropertyName, values)走完了，这个过程我们为PropertyValuesHolder对象赋了propName，valueType，keyframeSet，而keyframeSet中又存了Keyframe集合，keyframe中存储了（fraction , valuetype , value , hasValue）。</p>
<p>&#160; &#160; &#160; &#160;上面说过setValues(int… values) 会走setValues(PropertyValuesHolder.ofInt(mPropertyName, values));这一步，这是其父类ValueAnimator的方法，我们进入其父类看看：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValues</span><span class="params">(PropertyValuesHolder... values)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> numValues = values.length;</span><br><span class="line">    mValues = values;<span class="comment">//将刚才得到的PropertyValuesHolder存入</span></span><br><span class="line">    mValuesMap = <span class="keyword">new</span> HashMap&lt;String, PropertyValuesHolder&gt;(numValues);</span><br><span class="line">    <span class="comment">//再包装一层map</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numValues; ++i) &#123;</span><br><span class="line">        PropertyValuesHolder valuesHolder = values[i];</span><br><span class="line">        mValuesMap.put(valuesHolder.getPropertyName(), valuesHolder);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// New property/values/target should cause re-initialization prior to starting</span></span><br><span class="line">    mInitialized = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;首先记录了mValues，注意这里的values是PropertyValuesHolder类型的，然后通过一个mValueMap记录：key为属性的名称，值为PropertyValuesHolder 。</p>
<p>&#160; &#160; &#160; &#160;到此ofInt流程算是走完了，小结一下：<strong>ofInt记录了target,propName,values（是将我们传入的int型values，辗转转化成了PropertyValuesHolder）,以及一个mValueMap，这个map的key是propName，value是PropertyValuesHolder，在PropertyValuesHolder内部又存储了proprName, valueType , keyframeSet等等</strong>。</p>
<h3 id="setInterpolator"><a href="#setInterpolator" class="headerlink" title="setInterpolator"></a>setInterpolator</h3><p>&#160; &#160; &#160; &#160;设置插值器。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInterpolator</span><span class="params">(TimeInterpolator value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mInterpolator = value;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mInterpolator = <span class="keyword">new</span> LinearInterpolator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;也是父类ValueAnimator的方法，可以看到如果没有设置插值器，默认就是线性插值器LinearInterpolator。</p>
<h3 id="setEvaluator"><a href="#setEvaluator" class="headerlink" title="setEvaluator"></a>setEvaluator</h3><p>&#160; &#160; &#160; &#160;设置估值器，这东西用的不多。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEvaluator</span><span class="params">(TypeEvaluator value)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (value != <span class="keyword">null</span> &amp;&amp; mValues != <span class="keyword">null</span> &amp;&amp; mValues.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          mValues[<span class="number">0</span>].setEvaluator(value);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;mValues就是我们刚才ofInt里得到的PropertyValuesHolder对象，然后调用PropertyValuesHolder.setEvalutor：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEvaluator</span><span class="params">(TypeEvaluator evaluator)</span> </span>&#123;</span><br><span class="line">    mEvaluator = evaluator;<span class="comment">// 记录evaluator</span></span><br><span class="line">    mKeyframes.setEvaluator(evaluator);<span class="comment">// KeyframeSet再次记录evaluator</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;KeyframeSet再次记录evaluator：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEvaluator</span><span class="params">(TypeEvaluator evaluator)</span> </span>&#123;</span><br><span class="line">     mEvaluator = evaluator;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;setEvaluator这一步就完了，也就是把估值器evaluator分别交给PropertyValuesHolder和KeyframeSet。</p>
<h3 id="setDuration"><a href="#setDuration" class="headerlink" title="setDuration"></a>setDuration</h3><p>&#160; &#160; &#160; &#160; 设置动画时长。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ObjectAnimator 的方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ObjectAnimator <span class="title">setDuration</span><span class="params">(<span class="keyword">long</span> duration)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>.setDuration(duration); <span class="comment">//父类实现</span></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//VauleAnimator的方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> ValueAnimator <span class="title">setDuration</span><span class="params">(<span class="keyword">long</span> duration)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (duration &lt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Animators cannot have negative duration: "</span> +</span><br><span class="line">                   duration);</span><br><span class="line">       &#125;</span><br><span class="line">       mUnscaledDuration = duration;</span><br><span class="line">       updateScaledDuration();</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">float</span> sDurationScale = <span class="number">1.0f</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> mDuration = (<span class="keyword">long</span>)(<span class="number">300</span> * sDurationScale);</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">long</span> mUnscaledDuration = <span class="number">300</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateScaledDuration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       mDuration = (<span class="keyword">long</span>)(mUnscaledDuration * sDurationScale);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160; 就是简单在mDuration中记录了一下动画的持续时间，这个sDurationScale默认为1，貌似是用于调整，观察动画的，比如你可以调整为10，动画就会慢10倍的播放。</p>
<h3 id="start"><a href="#start" class="headerlink" title="start"></a>start</h3><p>&#160; &#160; &#160; &#160; 以上的都比较简单，那么我们猜测start方法一定是巨复杂的。休息一下~<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/meizi.jpg" alt="妹子图"><br>&#160; &#160; &#160; &#160;OK，我们继续，走start()方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	<span class="comment">//省略干扰代码</span></span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">    <span class="keyword">super</span>.start(); <span class="comment">//最终会调用父类的方法</span></span><br><span class="line">&#125;</span><br><span class="line">   <span class="comment">//ValueAnimator的start方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       start(<span class="keyword">false</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">boolean</span> playBackwards)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (Looper.myLooper() == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> AndroidRuntimeException(<span class="string">"Animators may only be run on Looper threads"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       mPlayingBackwards = playBackwards; <span class="comment">//动画是否reverse</span></span><br><span class="line">       mCurrentIteration = <span class="number">0</span>;<span class="comment">//记录当前的动画的执行次数（与setRepeatCount有关）</span></span><br><span class="line">       mPlayingState = STOPPED;<span class="comment">//动画的状态为STOPPED</span></span><br><span class="line">       mStarted = <span class="keyword">true</span>;<span class="comment">//标志位</span></span><br><span class="line">       mStartedDelay = <span class="keyword">false</span>;</span><br><span class="line">       mPaused = <span class="keyword">false</span>;<span class="comment">//标志位</span></span><br><span class="line">       updateScaledDuration(); <span class="comment">// in case the scale factor has changed since creation time</span></span><br><span class="line">       AnimationHandler animationHandler = getOrCreateAnimationHandler();<span class="comment">//生成一个AnimationHandler对象，getOrCreateAnimationHandler就是在当前线程变量ThreadLocal中取出来，没有的话，则创建一个，然后set进去。</span></span><br><span class="line">       animationHandler.mPendingAnimations.add(<span class="keyword">this</span>);<span class="comment">//AnimationHandler中包含一些List集合用于存储各种状态的ValueAnimator，将当前ValueAnimator对象，加入  animationHandler.mPendingAnimations 集合</span></span><br><span class="line">       <span class="keyword">if</span> (mStartDelay == <span class="number">0</span>) &#123; <span class="comment">//mStartDelay 默认为0，进入</span></span><br><span class="line">           <span class="comment">// This sets the initial value of the animation, prior to actually starting it running</span></span><br><span class="line">           setCurrentPlayTime(<span class="number">0</span>); <span class="comment">//这个接下来会说明</span></span><br><span class="line">           mPlayingState = STOPPED;<span class="comment">//动画的状态为STOPPED</span></span><br><span class="line">           mRunning = <span class="keyword">true</span>;<span class="comment">//标志位</span></span><br><span class="line">           notifyStartListeners();<span class="comment">//回调监听动画的接口AnimatorListener的onAnimationStart方法，如果你设置了回调监听，此时就会进行回调。</span></span><br><span class="line">       &#125;</span><br><span class="line">       animationHandler.start();<span class="comment">//最后调用，这个会细说</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">static</span> ThreadLocal&lt;AnimationHandler&gt; sAnimationHandler =</span><br><span class="line">           <span class="keyword">new</span> ThreadLocal&lt;AnimationHandler&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> AnimationHandler <span class="title">getOrCreateAnimationHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       AnimationHandler handler = sAnimationHandler.get();</span><br><span class="line">       <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">           handler = <span class="keyword">new</span> AnimationHandler();</span><br><span class="line">           sAnimationHandler.set(handler);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> handler;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifyStartListeners</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (mListeners != <span class="keyword">null</span> &amp;&amp; !mStartListenersCalled) &#123;</span><br><span class="line">           ArrayList&lt;AnimatorListener&gt; tmpListeners =</span><br><span class="line">                   (ArrayList&lt;AnimatorListener&gt;) mListeners.clone();</span><br><span class="line">           <span class="keyword">int</span> numListeners = tmpListeners.size();</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numListeners; ++i) &#123;</span><br><span class="line">               tmpListeners.get(i).onAnimationStart(<span class="keyword">this</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       mStartListenersCalled = <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;start方法做了一些状态和变量初始化，其他的都很好理解，有两处方法要细说：setCurrentPlayTime(0)和animationHandler.start()，我们先看setCurrentPlayTime(0)。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCurrentPlayTime</span><span class="params">(<span class="keyword">long</span> playTime)</span> </span>&#123;</span><br><span class="line">    initAnimation();<span class="comment">//初始化动画，接下来看</span></span><br><span class="line">    <span class="keyword">long</span> currentTime = AnimationUtils.currentAnimationTimeMillis();<span class="comment">//得到当前时间</span></span><br><span class="line">    <span class="keyword">if</span> (mPlayingState != RUNNING) &#123; <span class="comment">//之前将mPlayingState设为了STOPPED</span></span><br><span class="line">        mSeekTime = playTime;<span class="comment">//为0</span></span><br><span class="line">        mPlayingState = SEEKED; <span class="comment">//将mPlayingState 改为SEEKED</span></span><br><span class="line">    &#125;</span><br><span class="line">    mStartTime = currentTime - playTime;<span class="comment">//起始时间为当前时间</span></span><br><span class="line">    doAnimationFrame(currentTime);<span class="comment">//接下来也会看</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160; 先看initAnimation()：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initAnimation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mInitialized) &#123;</span><br><span class="line">        <span class="keyword">int</span> numValues = mValues.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numValues; ++i) &#123;</span><br><span class="line">            mValues[i].init(); <span class="comment">//mValues也就是之前ofInt方法得到的IntPropertyValueHolder对象</span></span><br><span class="line">        &#125;</span><br><span class="line">        mInitialized = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160; 接着找IntPropertyValueHolder的init方法，在其父类发现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mEvaluator == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// We already handle int and float automatically, but not their Object</span></span><br><span class="line">        <span class="comment">// equivalents</span></span><br><span class="line">        mEvaluator = (mValueType == Integer.class) ? sIntEvaluator :</span><br><span class="line">                (mValueType == Float.class) ? sFloatEvaluator :</span><br><span class="line">                <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mEvaluator != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// KeyframeSet knows how to evaluate the common types - only give it a custom</span></span><br><span class="line">        <span class="comment">// evaluator if one has been set on this class</span></span><br><span class="line">        mKeyframes.setEvaluator(mEvaluator);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160; 其实就是遍历设置PropertyValuesHolder中的mEvaluator属性，默认根据valueType进行判断，IntEvaluator或者FloatEvaluator。</p>
<p>&#160; &#160; &#160; &#160;initAnimation()完了，然后看doAnimationFrame(currentTime)：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">doAnimationFrame</span><span class="params">(<span class="keyword">long</span> frameTime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mPlayingState == STOPPED) &#123; <span class="comment">//上面已赋为SEEKED，所以不进入下面逻辑</span></span><br><span class="line">        mPlayingState = RUNNING;</span><br><span class="line">        <span class="keyword">if</span> (mSeekTime &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            mStartTime = frameTime;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mStartTime = frameTime - mSeekTime;</span><br><span class="line">            <span class="comment">// Now that we're playing, reset the seek time</span></span><br><span class="line">            mSeekTime = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mPaused) &#123;<span class="comment">//mPaused上面已赋为false</span></span><br><span class="line">        <span class="keyword">if</span> (mPauseTime &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            mPauseTime = frameTime;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mResumed) &#123;<span class="comment">//默认是false</span></span><br><span class="line">        mResumed = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (mPauseTime &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Offset by the duration that the animation was paused</span></span><br><span class="line">            mStartTime += (frameTime - mPauseTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// The frame time might be before the start time during the first frame of</span></span><br><span class="line">    <span class="comment">// an animation.  The "current time" must always be on or after the start</span></span><br><span class="line">    <span class="comment">// time to avoid animating frames at negative time intervals.  In practice, this</span></span><br><span class="line">    <span class="comment">// is very rare and only happens when seeking backwards.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> currentTime = Math.max(frameTime, mStartTime);</span><br><span class="line">    <span class="keyword">return</span> animationFrame(currentTime);<span class="comment">//最后只走了这个</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160; 继续跟animationFrame(currentTime)：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">animationFrame</span><span class="params">(<span class="keyword">long</span> currentTime)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">boolean</span> done = <span class="keyword">false</span>;</span><br><span class="line">     <span class="keyword">switch</span> (mPlayingState) &#123;<span class="comment">//上面已赋为SEEKED</span></span><br><span class="line">     <span class="keyword">case</span> RUNNING:</span><br><span class="line">     <span class="keyword">case</span> SEEKED:</span><br><span class="line">         <span class="keyword">float</span> fraction = mDuration &gt; <span class="number">0</span> ? (<span class="keyword">float</span>)(currentTime - mStartTime) / mDuration : <span class="number">1f</span>;<span class="comment">//此时currentTime和mStartTime相等，fraction为0，刚开始嘛</span></span><br><span class="line">         <span class="keyword">if</span> (fraction &gt;= <span class="number">1f</span>) &#123;<span class="comment">//刚开始不会走这段逻辑</span></span><br><span class="line">             <span class="keyword">if</span> (mCurrentIteration &lt; mRepeatCount || mRepeatCount == INFINITE) &#123;</span><br><span class="line">                 <span class="comment">// Time to repeat</span></span><br><span class="line">                 <span class="keyword">if</span> (mListeners != <span class="keyword">null</span>) &#123;</span><br><span class="line">                     <span class="keyword">int</span> numListeners = mListeners.size();</span><br><span class="line">                     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numListeners; ++i) &#123;</span><br><span class="line">                         mListeners.get(i).onAnimationRepeat(<span class="keyword">this</span>);</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="keyword">if</span> (mRepeatMode == REVERSE) &#123;</span><br><span class="line">                     mPlayingBackwards = !mPlayingBackwards;</span><br><span class="line">                 &#125;</span><br><span class="line">                 mCurrentIteration += (<span class="keyword">int</span>)fraction;</span><br><span class="line">                 fraction = fraction % <span class="number">1f</span>;</span><br><span class="line">                 mStartTime += mDuration;</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 done = <span class="keyword">true</span>;</span><br><span class="line">                 fraction = Math.min(fraction, <span class="number">1.0f</span>);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (mPlayingBackwards) &#123;<span class="comment">//这个是false，因为没有设置reverse</span></span><br><span class="line">             fraction = <span class="number">1f</span> - fraction;</span><br><span class="line">         &#125;</span><br><span class="line">         animateValue(fraction);<span class="comment">//最后只会走这个，继续往下看</span></span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> done;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160; 然后又到了这一步animateValue(fraction)，此时fraction是0，刚开始嘛。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里会调用子类ObjectAnimator的animateValue方法</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">animateValue</span><span class="params">(<span class="keyword">float</span> fraction)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Object target = getTarget();</span><br><span class="line">       <span class="keyword">if</span> (mTarget != <span class="keyword">null</span> &amp;&amp; target == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">// We lost the target reference, cancel and clean up.</span></span><br><span class="line">           cancel();</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">super</span>.animateValue(fraction);<span class="comment">//这里调用父类的方法</span></span><br><span class="line">       <span class="keyword">int</span> numValues = mValues.length;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numValues; ++i) &#123;</span><br><span class="line">           mValues[i].setAnimatedValue(target);<span class="comment">//设置属性，下面会分析</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//ValueAnimator的方法</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">animateValue</span><span class="params">(<span class="keyword">float</span> fraction)</span> </span>&#123;</span><br><span class="line">       fraction = mInterpolator.getInterpolation(fraction);<span class="comment">//插值器处理一下fraction</span></span><br><span class="line">       mCurrentFraction = fraction;</span><br><span class="line">       <span class="keyword">int</span> numValues = mValues.length;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numValues; ++i) &#123;</span><br><span class="line">           mValues[i].calculateValue(fraction);<span class="comment">//之前ofInt得到的IntPropertyValueHolder对象的calculateValue方法</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//UpdateListener监听接口开始回调，比较简单</span></span><br><span class="line">       <span class="keyword">if</span> (mUpdateListeners != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">int</span> numListeners = mUpdateListeners.size();</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numListeners; ++i) &#123;</span><br><span class="line">               mUpdateListeners.get(i).onAnimationUpdate(<span class="keyword">this</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160; 我们跟一下IntPropertyValueHolder的calculateValue方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calculateValue</span><span class="params">(<span class="keyword">float</span> fraction)</span> </span>&#123;<span class="comment">//这个fraction是经过插值器处理过的fraction</span></span><br><span class="line">    mIntAnimatedValue = mIntKeyframes.getIntValue(fraction);<span class="comment">//这里注意是IntKeyFrameSet，千万不要看错方法了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;go on，IntKeyFrameSet的getIntValue方法，fraction是经过插值器处理过的fraction ：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIntValue</span><span class="params">(<span class="keyword">float</span> fraction)</span> </span>&#123;<span class="comment">//raction是经过插值器处理过的fraction</span></span><br><span class="line">    <span class="keyword">if</span> (mNumKeyframes == <span class="number">2</span>) &#123;<span class="comment">//在ofInt里只设置了一个value，则只有两个关键帧，上面分析过</span></span><br><span class="line">        <span class="keyword">if</span> (firstTime) &#123;<span class="comment">//默认是true</span></span><br><span class="line">            firstTime = <span class="keyword">false</span>;</span><br><span class="line">            firstValue = ((IntKeyframe) mKeyframes.get(<span class="number">0</span>)).getIntValue();<span class="comment">//取起始帧的value，为0</span></span><br><span class="line">            lastValue = ((IntKeyframe) mKeyframes.get(<span class="number">1</span>)).getIntValue();<span class="comment">//结束帧的value，即我们设进去的值</span></span><br><span class="line">            deltaValue = lastValue - firstValue;<span class="comment">//计算delta值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mInterpolator != <span class="keyword">null</span>) &#123;<span class="comment">//这玩意儿是null，他是IntKeyFrameSet的，不是ObjectAnimator的</span></span><br><span class="line">            fraction = mInterpolator.getInterpolation(fraction);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mEvaluator == <span class="keyword">null</span>) &#123;<span class="comment">//估值器，其实此处设与不设一样，实现都是firstValue + (int)(fraction * deltaValue)；这个很好看懂，想想函数y=f(X)之类，return的就是y</span></span><br><span class="line">            <span class="keyword">return</span> firstValue + (<span class="keyword">int</span>)(fraction * deltaValue);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//扒一下IntEvaluator和上面那个一样</span></span><br><span class="line">            <span class="keyword">return</span> ((Number)mEvaluator.evaluate(fraction, firstValue, lastValue)).intValue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//下面逻辑是ofInt设置了多个value的</span></span><br><span class="line">    <span class="keyword">if</span> (fraction &lt;= <span class="number">0f</span>) &#123;<span class="comment">//小于区间范围，将第0和第1帧作为参考</span></span><br><span class="line">        <span class="keyword">final</span> IntKeyframe prevKeyframe = (IntKeyframe) mKeyframes.get(<span class="number">0</span>);<span class="comment">//第1帧</span></span><br><span class="line">        <span class="keyword">final</span> IntKeyframe nextKeyframe = (IntKeyframe) mKeyframes.get(<span class="number">1</span>);<span class="comment">//第2帧</span></span><br><span class="line">        <span class="keyword">int</span> prevValue = prevKeyframe.getIntValue();<span class="comment">//第1帧的属性值y1</span></span><br><span class="line">        <span class="keyword">int</span> nextValue = nextKeyframe.getIntValue();<span class="comment">//第2帧属性值y2</span></span><br><span class="line">        <span class="keyword">float</span> prevFraction = prevKeyframe.getFraction();<span class="comment">//第1帧的关系因子，x1</span></span><br><span class="line">        <span class="keyword">float</span> nextFraction = nextKeyframe.getFraction();<span class="comment">//第2帧的关系因子，x2</span></span><br><span class="line">        <span class="keyword">final</span> TimeInterpolator interpolator = nextKeyframe.getInterpolator();</span><br><span class="line">        <span class="keyword">if</span> (interpolator != <span class="keyword">null</span>) &#123;<span class="comment">//null</span></span><br><span class="line">            fraction = interpolator.getInterpolation(fraction);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//(x-x1)/(x2-x1)</span></span><br><span class="line">        <span class="keyword">float</span> intervalFraction = (fraction - prevFraction) / (nextFraction - prevFraction);</span><br><span class="line">        <span class="comment">//y=y1 + (x-x1)/(x2-x1)*(y2-y1),怎么样，直线方程既视感</span></span><br><span class="line">        <span class="keyword">return</span> mEvaluator == <span class="keyword">null</span> ?</span><br><span class="line">                prevValue + (<span class="keyword">int</span>)(intervalFraction * (nextValue - prevValue)) :</span><br><span class="line">                ((Number)mEvaluator.evaluate(intervalFraction, prevValue, nextValue)).</span><br><span class="line">                        intValue();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fraction &gt;= <span class="number">1f</span>) &#123;<span class="comment">//大于区间范围，将倒1和倒2帧作为参考，一下逻辑同上</span></span><br><span class="line">        <span class="keyword">final</span> IntKeyframe prevKeyframe = (IntKeyframe) mKeyframes.get(mNumKeyframes - <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">final</span> IntKeyframe nextKeyframe = (IntKeyframe) mKeyframes.get(mNumKeyframes - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> prevValue = prevKeyframe.getIntValue();</span><br><span class="line">        <span class="keyword">int</span> nextValue = nextKeyframe.getIntValue();</span><br><span class="line">        <span class="keyword">float</span> prevFraction = prevKeyframe.getFraction();</span><br><span class="line">        <span class="keyword">float</span> nextFraction = nextKeyframe.getFraction();</span><br><span class="line">        <span class="keyword">final</span> TimeInterpolator interpolator = nextKeyframe.getInterpolator();</span><br><span class="line">        <span class="keyword">if</span> (interpolator != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fraction = interpolator.getInterpolation(fraction);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">float</span> intervalFraction = (fraction - prevFraction) / (nextFraction - prevFraction);</span><br><span class="line">        <span class="keyword">return</span> mEvaluator == <span class="keyword">null</span> ?</span><br><span class="line">                prevValue + (<span class="keyword">int</span>)(intervalFraction * (nextValue - prevValue)) :</span><br><span class="line">                ((Number)mEvaluator.evaluate(intervalFraction, prevValue, nextValue)).intValue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//正常范围</span></span><br><span class="line">    IntKeyframe prevKeyframe = (IntKeyframe) mKeyframes.get(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; mNumKeyframes; ++i) &#123;<span class="comment">//循环遍历</span></span><br><span class="line">        IntKeyframe nextKeyframe = (IntKeyframe) mKeyframes.get(i);</span><br><span class="line">        <span class="keyword">if</span> (fraction &lt; nextKeyframe.getFraction()) &#123;<span class="comment">//这就比较好理解了，就进参考，往下逻辑同上</span></span><br><span class="line">            <span class="keyword">final</span> TimeInterpolator interpolator = nextKeyframe.getInterpolator();</span><br><span class="line">            <span class="keyword">if</span> (interpolator != <span class="keyword">null</span>) &#123;</span><br><span class="line">                fraction = interpolator.getInterpolation(fraction);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">float</span> intervalFraction = (fraction - prevKeyframe.getFraction()) /</span><br><span class="line">                (nextKeyframe.getFraction() - prevKeyframe.getFraction());</span><br><span class="line">            <span class="keyword">int</span> prevValue = prevKeyframe.getIntValue();</span><br><span class="line">            <span class="keyword">int</span> nextValue = nextKeyframe.getIntValue();</span><br><span class="line">            <span class="keyword">return</span> mEvaluator == <span class="keyword">null</span> ?</span><br><span class="line">                    prevValue + (<span class="keyword">int</span>)(intervalFraction * (nextValue - prevValue)) :</span><br><span class="line">                    ((Number)mEvaluator.evaluate(intervalFraction, prevValue, nextValue)).</span><br><span class="line">                            intValue();</span><br><span class="line">        &#125;</span><br><span class="line">        prevKeyframe = nextKeyframe;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// shouldn't get here</span></span><br><span class="line">    <span class="comment">//确实不该到这儿，google注释都这么说了</span></span><br><span class="line">    <span class="keyword">return</span> ((Number)mKeyframes.get(mNumKeyframes - <span class="number">1</span>).getValue()).intValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;看注释是不是有种学霸附体的感觉^  。^至于第一种在ofInt里只设置了一个value，则只有两个关键帧，这个很好理解。可以比喻为：已知x和y成线性关系，公式为y=kx+b，告知其中一点x值为x1，求y1。一次函数的直视感。</p>
<p>&#160; &#160; &#160; &#160;第二种设置多个value也很好理解，因为动画是连续的，这是个连续函数，所以函数曲线是一条连续的线。每个关键帧都是连续函数上的固定点。虽然函数图像是连续的，但是他确是个分段函数，这些关键帧就是分段函数的拐点，而两个拐点之间的规则是一样的，就是我们定义的插值器interpolator 。<br>&#160; &#160; &#160; &#160;动画之间都是连续的，如果要求出某个时间段对象的属性值，一定要参考距离它最近两帧。所以问题就转为已知两点坐标（x1，y1），（x2，y2），和另一点的x值，求其y值。果断高一数学的直线方程整起：<br>$$    \dfrac{x-x1 }{x2-x1} = \dfrac{y-y1}{y2-y1} $$</p>
<p>$$    y=\dfrac{(x-x1) * (y2-y1) }{x2-x1} +y1 $$</p>
<p>&#160; &#160; &#160; &#160;IntKeyFrameSet的getIntValue方法就分析玩了，然后找到之前的逻辑。这样就求出属性值了，并把它赋给了ObjectAnimator的IntPropertyValueHolder类对象mValues的mIntAnimatedValue中。回到上面的子类animateValue(fraction)方法，还有一步mValues[i].setAnimatedValue(target)：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setAnimatedValue</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mIntProperty != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mIntProperty.setValue(target, mIntAnimatedValue);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mProperty != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mProperty.set(target, mIntAnimatedValue);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mJniSetter != <span class="number">0</span>) &#123;</span><br><span class="line">        nCallIntMethod(target, mJniSetter, mIntAnimatedValue);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mSetter != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mTmpValueArray[<span class="number">0</span>] = mIntAnimatedValue;</span><br><span class="line">            mSetter.invoke(target, mTmpValueArray);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            Log.e(<span class="string">"PropertyValuesHolder"</span>, e.toString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            Log.e(<span class="string">"PropertyValuesHolder"</span>, e.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;果然有反射，看来我们的猜测八九不离十。这样就把刚才计算的属性值设置给目标对象了。</p>
<p>&#160; &#160; &#160; &#160;确实有点晕了。。。。。回一下神，赶紧回到ObjectAnimator父类ValueAnimator的start方法里，还要继续分析第二个重要地方animationHandler.start()。animationHandler我们上面已经介绍了，存储在当前线程的ThreadLocal里面，里面放了一些集合用于存储各种状态的ObjectAnimator，我们当前的ObjectAnimator对象也存储在其mPendingAnimations的集合中（上面提到过~~）。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    scheduleAnimation();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleAnimation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mAnimationScheduled) &#123;<span class="comment">//mAnimationScheduled默认false</span></span><br><span class="line">        mChoreographer.postCallback(Choreographer.CALLBACK_ANIMATION, <span class="keyword">this</span>, <span class="keyword">null</span>);<span class="comment">//Choreographer.CALLBACK_ANIMATION为1</span></span><br><span class="line">        mAnimationScheduled = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;要用到mChoreographer这个对象的postCallback方法，其中有一个参数是this；至于什么是Choreographer，暂时不用管；但是你需要知道一件事，其实我们的animationHandler是Runnable的子类，而 mChoreographer.postCallback(Choreographer.CALLBACK_ANIMATION, this, null);类似与handler发送消息，最终执行这个Runnable的run方法。<br>&#160; &#160; &#160; &#160;Choreographer这个类里面障眼法太多了，就不贴了。绕来绕去，其实就是一句话，这里调用了animationHandler的 run方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mAnimationScheduled = <span class="keyword">false</span>;</span><br><span class="line">        doAnimationFrame(mChoreographer.getFrameTime());</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAnimationFrame</span><span class="params">(<span class="keyword">long</span> frameTime)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// mPendingAnimations holds any animations that have requested to be started</span></span><br><span class="line">        <span class="comment">// We're going to clear mPendingAnimations, but starting animation may</span></span><br><span class="line">        <span class="comment">// cause more to be added to the pending list (for example, if one animation</span></span><br><span class="line">        <span class="comment">// starting triggers another starting). So we loop until mPendingAnimations</span></span><br><span class="line">        <span class="comment">// is empty.</span></span><br><span class="line">        <span class="keyword">while</span> (mPendingAnimations.size() &gt; <span class="number">0</span>) &#123;<span class="comment">//while循环，遍历所有在mPendingAnimations中的ObjectAnimator，依次调用anim.startAnimation(this);</span></span><br><span class="line">            ArrayList&lt;ValueAnimator&gt; pendingCopy =</span><br><span class="line">                    (ArrayList&lt;ValueAnimator&gt;) mPendingAnimations.clone();</span><br><span class="line">            mPendingAnimations.clear();</span><br><span class="line">            <span class="keyword">int</span> count = pendingCopy.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">                ValueAnimator anim = pendingCopy.get(i);</span><br><span class="line">                <span class="comment">// If the animation has a startDelay, place it on the delayed list</span></span><br><span class="line">                <span class="keyword">if</span> (anim.mStartDelay == <span class="number">0</span>) &#123;<span class="comment">//不延时的直接start</span></span><br><span class="line">                    anim.startAnimation(<span class="keyword">this</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;<span class="comment">//延时的先加入mDelayedAnims队列</span></span><br><span class="line">                    mDelayedAnims.add(anim);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Next, process animations currently sitting on the delayed queue, adding</span></span><br><span class="line">        <span class="comment">// them to the active animations if they are ready</span></span><br><span class="line">        <span class="comment">//看有多少延时的，如果延时的时间到了就加入到准备队列mReadyAnims</span></span><br><span class="line">        <span class="keyword">int</span> numDelayedAnims = mDelayedAnims.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numDelayedAnims; ++i) &#123;</span><br><span class="line">            ValueAnimator anim = mDelayedAnims.get(i);</span><br><span class="line">            <span class="keyword">if</span> (anim.delayedAnimationFrame(frameTime)) &#123;<span class="comment">//看方法注释就是说如果延时到了就该加入动画准备集合</span></span><br><span class="line">                mReadyAnims.add(anim);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//准备队列的开始start</span></span><br><span class="line">        <span class="keyword">int</span> numReadyAnims = mReadyAnims.size();</span><br><span class="line">        <span class="keyword">if</span> (numReadyAnims &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numReadyAnims; ++i) &#123;</span><br><span class="line">                ValueAnimator anim = mReadyAnims.get(i);</span><br><span class="line">                anim.startAnimation(<span class="keyword">this</span>);</span><br><span class="line">                anim.mRunning = <span class="keyword">true</span>;</span><br><span class="line">                mDelayedAnims.remove(anim);</span><br><span class="line">            &#125;</span><br><span class="line">            mReadyAnims.clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Now process all active animations. The return value from animationFrame()</span></span><br><span class="line">        <span class="comment">// tells the handler whether it should now be ended</span></span><br><span class="line">        <span class="comment">//将animationHandler的mAnimations集合中的每个anim，加入到mTmpAnimations中；</span></span><br><span class="line">        <span class="keyword">int</span> numAnims = mAnimations.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numAnims; ++i) &#123;</span><br><span class="line">            mTmpAnimations.add(mAnimations.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//依次调用mTmpAnimations中的anim，anim.doAnimationFrame(frameTime)。doAnimationFrame（frameTime）上面已经分析过了，如果返回true，即doAnimationFrame的done为true，则将该动画加入到结束动画集合。 </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numAnims; ++i) &#123;</span><br><span class="line">            ValueAnimator anim = mTmpAnimations.get(i);</span><br><span class="line">            <span class="keyword">if</span> (mAnimations.contains(anim) &amp;&amp; anim.doAnimationFrame(frameTime)) &#123;</span><br><span class="line">                mEndingAnims.add(anim);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mTmpAnimations.clear();</span><br><span class="line">        <span class="comment">//循环调用mEndingAnims， mEndingAnims.get(i).endAnimation(this);内部，会将动画移除mAnimations，回调动画监听接口onAnimationEnd；以及重置各种标志变量。</span></span><br><span class="line">        <span class="keyword">if</span> (mEndingAnims.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mEndingAnims.size(); ++i) &#123;</span><br><span class="line">                mEndingAnims.get(i).endAnimation(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            mEndingAnims.clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If there are still active or delayed animations, schedule a future call to</span></span><br><span class="line">        <span class="comment">// onAnimate to process the next frame of the animations.</span></span><br><span class="line">        <span class="comment">//如果mAnimations不为null，则再次调用scheduleAnimation();</span></span><br><span class="line">        <span class="keyword">if</span> (!mAnimations.isEmpty() || !mDelayedAnims.isEmpty()) &#123;</span><br><span class="line">            scheduleAnimation();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">/**</span><br><span class="line"> * Internal function called to process an animation frame on an animation that is currently</span><br><span class="line"> * sleeping through its &lt;code&gt;startDelay&lt;/code&gt; phase. The return value indicates whether it</span><br><span class="line"> * should be woken up and put on the active animations queue.</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> currentTime The current animation time, used to calculate whether the animation</span><br><span class="line"> * has exceeded its &lt;code&gt;startDelay&lt;/code&gt; and should be started.</span><br><span class="line"> * <span class="doctag">@return</span> True if the animation's &lt;code&gt;startDelay&lt;/code&gt; has been exceeded and the animation</span><br><span class="line"> * should be added to the set of active animations.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">delayedAnimationFrame</span><span class="params">(<span class="keyword">long</span> currentTime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mStartedDelay) &#123;<span class="comment">//默认false</span></span><br><span class="line">        mStartedDelay = <span class="keyword">true</span>;</span><br><span class="line">        mDelayStartTime = currentTime;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mPaused) &#123;<span class="comment">//默认false</span></span><br><span class="line">        <span class="keyword">if</span> (mPauseTime &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            mPauseTime = currentTime;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mResumed) &#123;<span class="comment">//默认false</span></span><br><span class="line">        mResumed = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (mPauseTime &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Offset by the duration that the animation was paused</span></span><br><span class="line">            mDelayStartTime += (currentTime - mPauseTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> deltaTime = currentTime - mDelayStartTime;<span class="comment">//延时间隔</span></span><br><span class="line">    <span class="keyword">if</span> (deltaTime &gt; mStartDelay) &#123;<span class="comment">//延时超了规定延时时间，应该执行了</span></span><br><span class="line">        <span class="comment">// startDelay ended - start the anim and record the</span></span><br><span class="line">        <span class="comment">// mStartTime appropriately</span></span><br><span class="line">        mStartTime = currentTime - (deltaTime - mStartDelay);</span><br><span class="line">        mPlayingState = RUNNING;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startAnimation</span><span class="params">(AnimationHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Trace.isTagEnabled(Trace.TRACE_TAG_VIEW)) &#123;</span><br><span class="line">        Trace.asyncTraceBegin(Trace.TRACE_TAG_VIEW, getNameForTrace(),</span><br><span class="line">                System.identityHashCode(<span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    initAnimation();</span><br><span class="line">    handler.mAnimations.add(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (mStartDelay &gt; <span class="number">0</span> &amp;&amp; mListeners != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Listeners were already notified in start() if startDelay is 0; this is</span></span><br><span class="line">        <span class="comment">// just for delayed animations</span></span><br><span class="line">        notifyStartListeners();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;scheduleAnimation()一旦调用，就像Handler不停发消息一样，AnimationHandler的run方法就会一直调用，mChoreographer.getFrameTime()控制动画时间段，然后一直调用AnimationHandler的doAnimationFrame方法，这个方法里面又调用了ValueAnimator的doAnimationFrame方法，这个方法上面分析过了，就是计算属性应该的值，然后反射设置；再startAnimation通知回调。这样动画就一帧一帧的执行了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&#160; &#160; &#160; &#160;ofInt中实例化了一个ObjectAnimator对象，然后设置了target，propName，values(PropertyValuesHolder) ；然后分别在setInterpolator，setDuration设置了Interpolator和duration。其中setEvaluator是给PropertyValuesHolder，以及keyframeSet设置估值算法。</p>
<p>&#160; &#160; &#160; &#160;PropertyValueHolder实际上是IntPropertyValueHolder类型对象，包含propName,valueType,keyframeSet .</p>
<p>&#160; &#160; &#160; &#160;keyframeset中存了Keyframe集合，keyframe中存储了（fraction , valuetype , value , hasValue）。</p>
<p>&#160; &#160; &#160; &#160;start()中：<br>&#160; &#160; &#160; &#160;首先更新动画各种状态，然后初步计算fraction为(currentTime - mStartTime) / mDuration；然后将这个fraction交给我们的插值器计算后得到新的fraction，再将新的fraction交给我们的估值算法，估值算法根据开始、结束、fraction得到当前属性（动画作用的属性）应该的值，最大调用反射进行设置；<br>&#160; &#160; &#160; &#160;start中还会根据动画的状态，如果没有结束，不断的调用AnimationHanlder的run方法;该方法内部利用mChoreographer不断的去重复第一步。</p>
<p>&#160; &#160; &#160; &#160;至此属性动画流程分析完了，也算马马虎虎，至少和我们的猜想八九不离十。看源码看的也快吐血了，这么长代码也只能了解个大概，以后有时间再好好整理一下思路。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android跨进程通信机制Binder简要分析]]></title>
      <url>http://windrunnerlihuan.com/2016/06/12/Binder%E7%AE%80%E8%A6%81%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<hr>
<p>&#160; &#160; &#160; &#160; 在Android系统中，每个应用都是由四大组件中之几组成，我们经常要去写一些Activity或者Service，这些Activity或者Service有时候会运行在不同的进程中，如果我们要让这些不同的Activity或者Service之间通信，就要用到Android提供的Binder机制了。</p>
<blockquote>
<p>&#160;&#160;&#160;&#160;Binder其实也不是Android提出来的一套新的进程间通信机制，它是基于<a href="http://www.angryredplanet.com/~hackbod/openbinder/docs/html/BinderIPCMechanism.html" target="_blank" rel="external">OpenBinder</a>来实现的。OpenBinder最先是由<a href="https://en.wikipedia.org/wiki/Be_Inc." target="_blank" rel="external">Be Inc.</a>开发的，接着<a href="https://en.wikipedia.org/wiki/Palm,_Inc." target="_blank" rel="external">Palm Inc.</a>也着使用。现在OpenBinder的作者<a href="http://www.angryredplanet.com/~hackbod/" target="_blank" rel="external">Dianne Hackborn</a>就是在Google工作，负责Android平台的开发工作。</p>
</blockquote>
<p>&#160; &#160; &#160; &#160; Android系统是基于Linux内核的，Linux已经拥有管道，system V IPC，socket等IPC手段，比如pipe管道（有血缘关系的进程），fifo有名管道（无血缘关系的进程），mmap/munmap内存共享映射，Unix Domain Socket等等。但是Android却采用了Binder这种不同上述几种类型的特有机制，至于原因肯定有很多，比如安全，实现方式合理性，内存优化，性能等等。（这一块儿坑的很多，需要积累很多linux系统相关内容，我也是恶补了许多知识。并且Binder远远不是三言两语能够概括清楚的，所以很多底层细节无法为大家展现，比如内核部分代码细节。既然不幸入坑了，我们就一步一步往下挖吧=。=）<br><a id="more"></a></p>
<hr>
<h1 id="Binder通信模型"><a href="#Binder通信模型" class="headerlink" title="Binder通信模型"></a>Binder通信模型</h1><h2 id="Binder的优势"><a href="#Binder的优势" class="headerlink" title="Binder的优势"></a>Binder的优势</h2><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>&#160; &#160; &#160; &#160; Binder使用Client-Server通信方式：一个进程作为Server提供诸如视频/音频解码，视频捕获，地址本查询，网络连接等服务；多个进程作为Client向Server发起服务请求，获得所需要的服务。要想实现Client-Server通信据必须实现以下两点：一是server必须有确定的访问接入点或者说地址来接受Client的请求，并且Client可以通过某种途径获知Server的地址；二是制定Command-Reply协议来传输数据。例如在网络通信中Server的访问接入点就是Server主机的IP地址+端口号，传输协议为TCP协议。对Binder而言，Binder可以看成Server提供的实现某个特定服务的访问接入点， Client通过这个‘地址’向Server发送请求来使用该服务；对Client而言，Binder可以看成是通向Server的管道入口，要想和某个Server通信首先必须建立这个管道并获得管道入口。</p>
<h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><p>&#160; &#160; &#160; &#160; 如果是传统的Linux IPC方式中，socket作为一款通用接口，其传输效率低，开销大，主要用在跨网络的进程间通信和本机上进程间的低速通信。消息队列和管道采用存储-转发方式，即数据先从发送方缓存区拷贝到内核开辟的缓存区中，然后再从内核缓存区拷贝到接收方缓存区，至少有两次拷贝过程。共享内存虽然无需拷贝，但控制复杂，难以使用。</p>
<p>&#160; &#160; &#160; &#160; 举个例子如，Client要将一块内存数据传递给Server，一般的做法是，Client将这块数据从它的进程空间拷贝到内核空间中，然后内核再将这个数据从内核空间拷贝到Server的进程空间，这样，Server就可以访问这个数据了。但是在这种方法中，执行了两次内存拷贝操作。所以Binder设计时采用了折衷的方式，只需要把Client进程空间的数据拷贝一次到内核空间，然后Server与内核共享这个数据就可以了，整个过程只需要执行一次内存拷贝，提高了效率。同时这样更有C/S架构的模型，方便管理。</p>
<h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>&#160; &#160; &#160; &#160; Android作为一个开放式，拥有众多开发者的的平台，应用程序的来源广泛，确保智能终端的安全是非常重要的。终端用户不希望从网上下载的程序在不知情的情况下偷窥隐私数据，连接无线网络，长期操作底层设备导致电池很快耗尽等等。传统IPC没有任何安全措施，完全依赖上层协议来确保。首先传统IPC的接收方无法获得对方进程可靠的UID/PID（用户ID/进程ID），从而无法鉴别对方身份。Android为每个安装好的应用程序分配了自己的UID，故进程的UID是鉴别进程身份的重要标志。使用传统IPC只能由用户在数据包里填入UID/PID，但这样不可靠，容易被恶意程序利用。可靠的身份标记只有由IPC机制本身在内核中添加。其次传统IPC访问接入点是开放的，无法建立私有通道。比如命名管道的名称，system V的键值，socket的ip地址或文件名都是开放的，只要知道这些接入点的程序都可以和对端建立连接，不管怎样都无法阻止恶意程序通过猜测接收方地址获得连接。</p>
<p>&#160; &#160; &#160; &#160; 基于以上原因，Android需要建立一套新的IPC机制来满足系统对通信方式的安全性，这就是Binder。Binder为发送发添加UID/PID身份，既支持实名Binder也支持匿名Binder，安全性高。</p>
<h2 id="通信方式和引用"><a href="#通信方式和引用" class="headerlink" title="通信方式和引用"></a>通信方式和引用</h2><p>&#160; &#160; &#160; &#160; 与其它IPC不同，Binder使用了面向对象的思想来描述作为访问接入点的Binder及其在Client中的入口：Binder是一个实体位于Server中的对象，该对象提供了一套方法用以实现对服务的请求，就象类的成员函数。遍布于client中的入口可以看成指向这个binder对象的‘指针’，一旦获得了这个‘指针’就可以调用该对象的方法访问server。在Client看来，通过Binder‘指针’调用其提供的方法和通过指针调用其它任何本地对象的方法并无区别，尽管前者的实体位于远端Server中，而后者实体位于本地内存中。‘指针’是C/C++的术语，换成java的说法是引用，即Client通过Binder的引用访问Server。如果借用Windows系统开发的一个术语‘句柄’也可以用来表述Binder在Client中的存在方式。从通信的角度看，Client中的Binder也可以看作是Server Binder的<code>‘代理’</code>，在本地代表远端Server为Client提供服务。本文中会使用‘引用’或‘句柄’这个两广泛使用的术语。</p>
<blockquote>
<p>&#160; &#160; &#160; &#160; 面向对象思想的引入将进程间通信转化为通过对某个Binder对象的引用调用该对象的方法，而其独特之处在于Binder对象是一个可以跨进程引用的对象，它的实体位于一个进程中，而它的引用却遍布于系统的各个进程之中。最诱人的是，这个引用和Java里引用一样既可以是强类型，也可以是弱类型，而且可以从一个进程传给其它进程，让大家都能访问同一Server，就象将一个对象或引用赋值给另一个引用一样。Binder模糊了进程边界，淡化了进程间通信过程，整个系统仿佛运行于同一个面向对象的程序之中。形形色色的Binder对象以及星罗棋布的引用仿佛粘接各个应用程序的胶水，这也是Binder在英文里的原意。</p>
</blockquote>
<p>&#160; &#160; &#160; &#160; 当然面向对象只是针对应用程序而言，对于Binder驱动和内核其它模块一样使用C语言实现，没有类和对象的概念。Binder驱动为面向对象的进程间通信提供底层支持。</p>
<h2 id="Binder-通信模型"><a href="#Binder-通信模型" class="headerlink" title="Binder 通信模型"></a>Binder 通信模型</h2><p>&#160; &#160; &#160; &#160; 从英文字面上意思看，Binder具有粘结剂的意思，那么它把什么东西粘结在一起呢？在Android系统的Binder机制中，由一系统组件组成，分别是Client、Server、Service Manager和Binder驱动程序，其中Client、Server和Service Manager运行在用户空间，Binder驱动程序运行内核空间。Binder就是一种把这四个组件粘合在一起的粘结剂了，其中，核心组件便是Binder驱动程序了，Service Manager提供了辅助管理的功能，Client和Server正是在Binder驱动和Service Manager提供的基础设施上，进行Client-Server之间的通信。这四个角色的关系和互联网类似：Server是服务器，Client是客户终端，Service Manager是域名服务器（DNS），Binder驱动是路由器。</p>
<h3 id="Binder驱动"><a href="#Binder驱动" class="headerlink" title="Binder驱动"></a>Binder驱动</h3><p>&#160; &#160; &#160; &#160; 和路由器一样，Binder驱动虽然默默无闻，却是通信的核心。尽管名叫‘驱动’，实际上和硬件设备没有任何关系，只是实现方式和设备驱动程序是一样的：它工作于内核态，提供open()，mmap()，poll()，ioctl()等标准文件操作，以字符驱动设备中的misc设备注册在设备目录/dev下，用户通过/dev/binder访问该它。驱动负责进程之间Binder通信的建立，Binder在进程之间的传递，Binder引用计数管理，数据包在进程之间的传递和交互等一系列底层支持。驱动和应用程序之间定义了一套接口协议，主要功能由ioctl()接口实现，不提供read()，write()接口，因为ioctl()灵活方便，且能够一次调用实现先写后读以满足同步交互，而不必分别调用write()和read()。Binder驱动的代码每个分支位置不一样，再加上我也没有下内核的代码，<a href="https://android.googlesource.com/kernel/common/+/android-4.4/drivers/android/binder.c" target="_blank" rel="external">这里</a>先给个4.4的<code>Binder.c</code>的地址,有兴趣的可以自己研究。</p>
<h3 id="ServiceManager-与实名Binder"><a href="#ServiceManager-与实名Binder" class="headerlink" title="ServiceManager 与实名Binder"></a>ServiceManager 与实名Binder</h3><p>&#160; &#160; &#160; &#160; 和DNS类似，ServiceManager的作用是将字符形式的Binder名字转化成Client中对该Binder的引用，使得Client能够通过Binder名字获得对Server中Binder实体的引用。注册了名字的Binder叫实名Binder，就象每个网站除了有IP地址外还有自己的网址。Server创建了Binder实体，为其取一个字符形式，可读易记的名字，将这个Binder连同名字以数据包的形式通过Binder驱动发送给ServiceManager，通知ServiceManager注册一个名叫张三的Binder，它位于某个Server中。驱动为这个穿过进程边界的Binder创建位于内核中的实体节点以及ServiceManager对实体的引用，将名字及新建的引用打包传递给ServiceManager。ServiceManager收数据包后，从中取出名字和引用填入一张查找表中。</p>
<p>&#160; &#160; &#160; &#160; 细心的读者可能会发现其中的蹊跷：ServiceManager是一个进程，Server是另一个进程，Server向ServiceManager注册Binder必然会涉及进程间通信。当前实现的是进程间通信却又要用到进程间通信，这就好象蛋可以孵出鸡前提却是要找只鸡来孵蛋。Binder的实现比较巧妙：预先创造一只鸡来孵蛋：ServiceManager和其它进程同样采用Binder通信，ServiceManager是Server端，有自己的Binder对象（实体），其它进程都是Client，需要通过这个Binder的引用来实现Binder的注册，查询和获取。ServiceManager提供的Binder比较特殊，它没有名字也不需要注册，当一个进程使用BINDER_SET_CONTEXT_MGR命令将自己注册成ServiceManager（会用到ioctl(fd, cmd, arg)函数，cmd为BINDER_SET_CONTEXT_MGR）时Binder驱动会自动为它创建Binder实体（这就是那只预先造好的鸡）。其次这个Binder的引用在所有Client中都固定为0而无须通过其它手段获得。也就是说，一个Server若要向ServiceManager注册自己Binder就必需通过0（即NULL指针）这个引用号和ServiceManager的Binder通信。类比网络通信，0号引用就好比域名服务器的地址，你必须预先手工或动态配置好。要注意这里说的Client是相对ServiceManager而言的，一个应用程序可能是个提供服务的Server，但对ServiceManager来说它仍然是个Client。</p>
<h3 id="Client-获得实名Binder的引用"><a href="#Client-获得实名Binder的引用" class="headerlink" title="Client 获得实名Binder的引用"></a>Client 获得实名Binder的引用</h3><p>&#160; &#160; &#160; &#160; Server向ServiceManager注册了Binder实体及其名字后，Client就可以通过名字获得该Binder的引用了。Client也利用保留的0号引用向ServiceManager请求访问某个Binder：我申请获得名字叫张三的Binder的引用。ServiceManager收到这个连接请求，从请求数据包里获得Binder的名字，在查找表里找到该名字对应的条目，从条目中取出Binder的引用，将该引用作为回复发送给发起请求的Client。从面向对象的角度，这个Binder对象现在有了两个引用：一个位于ServiceManager中，一个位于发起请求的Client中。如果接下来有更多的Client请求该Binder，系统中就会有更多的引用指向该Binder，就象java里一个对象存在多个引用一样。而且类似的这些指向Binder的引用是强类型，从而确保只要有引用Binder实体就不会被释放掉。通过以上过程可以看出，ServiceManager象个火车票代售点，收集了所有火车的车票，可以通过它购买到乘坐各趟火车的票-得到某个Binder的引用。</p>
<h3 id="匿名-Binder"><a href="#匿名-Binder" class="headerlink" title="匿名 Binder"></a>匿名 Binder</h3><p>&#160; &#160; &#160; &#160; 并不是所有Binder都需要注册给ServiceManager广而告之的。Server端可以通过已经建立的Binder连接将创建的Binder实体传给Client，当然这条已经建立的Binder连接必须是通过实名Binder实现。如果我们是从事application开发，跨进程的自己手写AIDL文件，或者相同进程的bindService自己添加一个继承Binder的子类，那么这个Binder没有向ServiceManager注册名字，所以是个匿名Binder。Client将会收到这个匿名Binder的引用，通过这个引用向位于Server中的实体发送请求。匿名Binder为通信双方建立一条私密通道，只要Server没有把匿名Binder发给别的进程，别的进程就无法通过穷举或猜测等任何方式获得该Binder的引用，向该Binder发送请求。</p>
<hr>
<p>好了，理论性的科普先到这里，再继续下去估计要扑（pu）街（gai）了 =。=，先来美图放松放松。<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%E8%B7%A8%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6Binder%E7%AE%80%E8%A6%81%E5%88%86%E6%9E%90/meizi.jpg" alt="妹子图"></p>
<h1 id="Binder机制跨进程原理"><a href="#Binder机制跨进程原理" class="headerlink" title="Binder机制跨进程原理"></a>Binder机制跨进程原理</h1><p>&#160; &#160; &#160; &#160; 上文给出了Binder的通信模型，指出了通信过程的四个角色: Client, Server, ServiceManager, driver; 但是我们仍然不清楚<code>Client到底是如何与Server完成通信的</code>,因为实现细节我们还没讲。</p>
<p>&#160; &#160; &#160; &#160; 虽然Binder用到了面向对象的思想，但并不限制应用程序一定要使用面向对象的语言，无论是C语言还是C++语言都可以很容易的使用Binder来通信。例如尽管Android主要使用java/C++，象ServiceManager这么重要的进程就是用C语言实现的。</p>
<p>&#160; &#160; &#160; &#160; Binder本质上只是一种底层通信方式，和具体服务没有关系。为了提供具体服务，Server必须提供一套接口函数以便Client通过远程访问使用各种服务。这时通常采用Proxy设计模式：将接口函数定义在一个抽象类中，Server和Client都会以该抽象类为基类实现所有接口函数，所不同的是Server端是真正的功能实现，而Client端是对这些函数远程调用请求的包装。如何将Binder和Proxy设计模式结合起来是应用程序实现面向对象Binder通信的根本问题。</p>
<h2 id="Binder-在Server端的表述-–-Binder实体"><a href="#Binder-在Server端的表述-–-Binder实体" class="headerlink" title="Binder 在Server端的表述 – Binder实体"></a>Binder 在Server端的表述 – Binder实体</h2><p>&#160; &#160; &#160; &#160; 做为Proxy设计模式的基础，首先定义一个抽象接口类封装Server所有功能，其中包含一系列纯虚函数留待Server和Proxy各自实现（如果是java层则为接口方法，或者是AIDL文件，编译后大同小异）。由于这些函数需要跨进程调用，须为其一一编号，从而Server可以根据收到的编号决定调用哪个函数。其次就要引入Binder了。Server端定义另一个Binder抽象类处理来自Client的Binder请求数据包，其中最重要的成员是虚函数onTransact()。该函数分析收到的数据包，调用相应的接口函数处理请求。</p>
<p>&#160; &#160; &#160; &#160; 接下来采用继承方式以接口类和Binder抽象类为基类构建Binder在Server中的实体，实现基类里所有的虚函数，包括公共接口函数以及数据包处理函数：onTransact()。这个函数的输入是来自Client的binder_transaction_data结构的数据包（java层为Parcel对象，对应native层还是这个结构体某一部分）。前面提到，该结构里有个成员code，包含这次请求的接口函数编号。onTransact()将case-by-case地解析code值，从数据包里取出函数参数，调用接口类中相应的，已经实现的公共接口函数。函数执行完毕，如果需要返回数据就再构建一个binder_transaction_data包将返回数据包填入其中。</p>
<p>&#160; &#160; &#160; &#160; 那么各个Binder实体的onTransact()又是什么时候调用呢？这就需要驱动参与了。前面说过，Binder实体须要以Binde传输结构flat_binder_object形式发送给其它进程才能建立Binder通信，而Binder实体指针就存放在该结构的handle域中。驱动根据Binder位置数组从传输数据中获取该Binder的传输结构，为它创建位于内核中的Binder节点，将Binder实体指针记录在该节点中。如果接下来有其它进程向该Binder发送数据，驱动会根据节点中记录的信息将Binder实体指针填入binder_transaction_data的target.ptr中返回给接收线程。接收线程从数据包中取出该指针，reinterpret_cast成Binder抽象类并调用onTransact()函数。由于这是个虚函数，不同的Binder实体中有各自的实现，从而可以调用到不同Binder实体提供的onTransact()。</p>
<h2 id="Binder-在Client端的表述-–-Binder引用"><a href="#Binder-在Client端的表述-–-Binder引用" class="headerlink" title="Binder 在Client端的表述 – Binder引用"></a>Binder 在Client端的表述 – Binder引用</h2><p>&#160; &#160; &#160; &#160; 做为Proxy设计模式的一部分，Client端的Binder同样要继承Server提供的公共接口类并实现公共函数。但这不是真正的实现，而是对远程函数调用的包装：将函数参数打包，通过Binder向Server发送申请并等待返回值。为此Client端的Binder还要知道Binder实体的相关信息，即对Binder实体的引用。该引用或是由ServiceManager转发过来的，对实名Binder的引用或是由另一个进程直接发送过来的，对匿名Binder的引用。</p>
<p>&#160; &#160; &#160; &#160; 由于继承了同样的公共接口类，Client Binder提供了与Server Binder一样的函数原型，使用户感觉不出Server是运行在本地还是远端。Client Binder中，公共接口函数的包装方式是：创建一个binder_transaction_data数据包，将其对应的编码填入code域，将调用该函数所需的参数填入data.buffer指向的缓存中，并指明数据包的目的地，那就是已经获得的对Binder实体的引用，填入数据包的target.handle中。注意这里和Server的区别：实际上target域是个联合体，包括ptr和handle两个成员，前者用于接收数据包的Server，指向 Binder实体对应的内存空间；后者用于作为请求方的Client，存放Binder实体的引用，告知驱动数据包将路由给哪个实体。数据包准备好后，通过驱动接口发送出去。经过BC_TRANSACTION/BC_REPLY回合完成函数的远程调用并得到返回值。</p>
<hr>
<p>&#160; &#160; &#160; &#160; 以上主要是C++层实现步骤，java层也相同原理，只不过最终还会通过JNI调用C++层实现方法。<br>&#160; &#160; &#160; &#160; 我们举个栗子来描述会更通俗易懂一些：</p>
<p>&#160; &#160; &#160; &#160; 假设Client进程想要调用Server进程的<code>object</code>对象的一个方法<code>add</code>;<br>&#160; &#160; &#160; &#160; 首先，Server进程要向ServiceManager注册；告诉自己是谁，自己有什么能力；在这个场景就是Server告诉ServiceManager，它叫<code>zhangsan</code>，它有一个<code>object</code>对象，可以执行<code>add</code> 操作；于是ServiceManager建立了一张表：<code>zhangsan</code>这个名字对应进程Server; </p>
<p>&#160; &#160; &#160; &#160; 然后Client向ServiceManager查询：我需要联系一个名字叫做<code>zhangsan</code>的进程里面的<code>object</code>对象；这时候关键来了：进程之间通信的数据都会经过运行在内核空间里面的驱动，驱动在数据流过的时候做了一点手脚，它并不会给Client进程返回一个真正的<code>object</code>对象，而是返回一个看起来跟<code>object</code>一模一样的代理对象<code>objectProxy</code>，这个<code>objectProxy</code>也有一个<code>add</code>方法，但是这个<code>add</code>方法没有Server进程里面<code>object</code>对象的<code>add</code>方法那个能力；<code>objectProxy</code>的<code>add</code>只是一个傀儡，它唯一做的事情就是把参数包装然后交给驱动。(这里我们简化了ServiceManager的流程)</p>
<p>&#160; &#160; &#160; &#160; 但是Client进程并不知道驱动返回给它的对象动过手脚，毕竟伪装的太像了，如假包换。Client开开心心地拿着<code>objectProxy</code>对象然后调用<code>add</code>方法；我们说过，这个<code>add</code>什么也不做，直接把参数做一些包装然后直接转发给Binder驱动。</p>
<p>&#160; &#160; &#160; &#160; 驱动收到这个消息，发现是这个<code>objectProxy</code>；一查表就明白了：我之前用<code>objectProxy</code>替换了<code>object</code>发送给Client了，它真正应该要访问的是<code>object</code>对象的<code>add</code>方法；于是Binder驱动通知Server进程，调用你的<code>object</code>对象的<code>add</code>方法，然后把结果发给我，Sever进程收到这个消息，照做之后将结果返回驱动，驱动然后把结果返回给Client进程；于是整个过程就完成了。</p>
<p>&#160; &#160; &#160; &#160; 由于驱动返回的<code>objectProxy</code>与Server进程里面原始的<code>object</code>是如此相似，给人感觉好像是<strong>直接把Server进程里面的对象<code>object</code>传递到了Client进程</strong> ；因此，我们可以说<strong>Binder对象是可以进行跨进程传递的对象</strong>。</p>
<p>&#160; &#160; &#160; &#160; 但事实上我们知道，Binder跨进程传输并不是真的把一个对象传输到了另外一个进程；传输过程好像是Binder跨进程穿越的时候，它在一个进程留下了一个真身，在另外一个进程幻化出一个影子（这个影子可以很多个）；Client进程的操作其实是对于影子的操作，影子利用Binder驱动最终让真身完成操作。</p>
<p>&#160; &#160; &#160; &#160; 理解这一点非常重要；务必仔细体会。另外，Android系统实现这种机制使用的是代理模式, 对于Binder的访问，如果是在同一个进程（不需要跨进程），那么直接返回原始的Binder实体；如果在不同进程，那么就给他一个代理对象（影子）；我们在系统源码以及AIDL的生成代码里面可以看到很多这种实现。</p>
<p>&#160; &#160; &#160; &#160; 另外我们为了简化整个流程，隐藏了ServiceManager这一部分驱动进行的操作；实际上，由于ServiceManager与Server通常不在一个进程，Server进程向ServiceManager注册的过程也是跨进程通信，驱动也会对这个过程进行暗箱操作：ServiceManager中存在的Server端的对象实际上也是代理对象，后面Client向ServiceManager查询的时候，驱动会给Client返回另外一个代理对象。Sever进程的本地对象仅有一个，其他进程所拥有的全部都是它的代理。</p>
<p>&#160; &#160; &#160; &#160; 一句话总结就是：<strong>Client进程只不过是持有了Server端的代理；代理对象协助驱动完成了跨进程通信</strong>。</p>
<h1 id="分析Java层的Binder"><a href="#分析Java层的Binder" class="headerlink" title="分析Java层的Binder"></a>分析Java层的Binder</h1><p>&#160; &#160; &#160; &#160;  Android系统的很多服务都是由C++层的Binder实现，过程复杂先不说，主要是代码量巨多，分析起来篇幅远远不够，即使不分析完全，估计粘一半代码都快吐血了，所以就选了java层的Binder，会重点分析AIDL过程。</p>
<p>&#160; &#160; &#160; &#160;  我们使用AIDL接口的时候，经常会接触到这些类：<strong>IBinder/IInterface/Binder/BinderProxy/Stub</strong>，相关功能如下：</p>
<ul>
<li>IBinder是一个接口，它代表了<strong>一种跨进程传输的能力</strong>；只要实现了这个接口，就能将这个对象进行跨进程传递；这是驱动底层支持的；在跨进程数据流经驱动的时候，驱动会识别IBinder类型的数据，从而自动完成不同进程Binder本地对象以及Binder代理对象的转换。</li>
<li>IBinder负责数据传输，那么client与server端的调用契约（这里不用接口避免混淆）呢？这里的IInterface代表的就是远程server对象具有什么能力。具体来说，就是aidl里面的接口。</li>
<li>Java层的Binder类，代表的其实就是<strong>Binder本地对象</strong>。BinderProxy类是Binder类的一个内部类，它代表远程进程的Binder对象的本地代理；这两个类都继承自IBinder, 因而都具有跨进程传输的能力；实际上，在跨越进程的时候，Binder驱动会自动完成这两个对象的转换。</li>
<li>在使用AIDL的时候，编译工具会给我们生成一个Stub的静态内部类；这个类继承了Binder, 说明它是一个Binder本地对象，它实现了IInterface接口，表明它具有远程Server承诺给Client的能力；Stub是一个抽象类，具体的IInterface的相关实现需要我们手动完成，这里使用了策略模式。</li>
</ul>
<h2 id="AIDL过程分析"><a href="#AIDL过程分析" class="headerlink" title="AIDL过程分析"></a>AIDL过程分析</h2><p>&#160; &#160; &#160; &#160; 现在我们通过一个AIDL的使用，分析一下整个通信过程中，各个角色到底做了什么，AIDL到底是如何完成通信的。<br>&#160; &#160; &#160; &#160; 首先定一个一个简单的aidl接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ITest.aidl</span></span><br><span class="line"><span class="keyword">package</span> com.windrunnerlihuan;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ITest</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后用编译工具编译之后，可以得到对应的ITest.java类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.windrunnerlihuan;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ITest</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">IInterface</span> </span>&#123;</span><br><span class="line">	<span class="comment">/** Local-side IPC implementation stub class. */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Stub</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">Binder</span> <span class="keyword">implements</span></span><br><span class="line">			<span class="title">com</span>.<span class="title">windrunnerlihuan</span>.<span class="title">ITest</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> java.lang.String DESCRIPTOR = <span class="string">"com.windrunnerlihuan.ITest"</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/** Construct the stub at attach it to the interface. */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Stub</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.attachInterface(<span class="keyword">this</span>, DESCRIPTOR);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span><br><span class="line">		 * Cast an IBinder object into an com.windrunnerlihuan.ITest interface,</span><br><span class="line">		 * generating a proxy if needed.</span><br><span class="line">		 */</span></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">static</span> com.windrunnerlihuan.<span class="function">ITest <span class="title">asInterface</span><span class="params">(</span><br><span class="line">				android.os.IBinder obj)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> ((obj == <span class="keyword">null</span>)) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">			<span class="keyword">if</span> (((iin != <span class="keyword">null</span>) &amp;&amp; (iin <span class="keyword">instanceof</span> com.windrunnerlihuan.ITest))) &#123;</span><br><span class="line">				<span class="keyword">return</span> ((com.windrunnerlihuan.ITest) iin);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> com.windrunnerlihuan.ITest.Stub.Proxy(obj);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, android.os.Parcel data,</span><br><span class="line">				android.os.Parcel reply, <span class="keyword">int</span> flags)</span></span><br><span class="line">				<span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">			<span class="keyword">switch</span> (code) &#123;</span><br><span class="line">			<span class="keyword">case</span> INTERFACE_TRANSACTION: &#123;</span><br><span class="line">				reply.writeString(DESCRIPTOR);</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">case</span> TRANSACTION_add: &#123;</span><br><span class="line">				data.enforceInterface(DESCRIPTOR);</span><br><span class="line">				<span class="keyword">int</span> _arg0;</span><br><span class="line">				_arg0 = data.readInt();</span><br><span class="line">				<span class="keyword">int</span> _arg1;</span><br><span class="line">				_arg1 = data.readInt();</span><br><span class="line">				<span class="keyword">int</span> _result = <span class="keyword">this</span>.add(_arg0, _arg1);</span><br><span class="line">				reply.writeNoException();</span><br><span class="line">				reply.writeInt(_result);</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">windrunnerlihuan</span>.<span class="title">ITest</span> </span>&#123;</span><br><span class="line">			<span class="keyword">private</span> android.os.IBinder mRemote;</span><br><span class="line"></span><br><span class="line">			Proxy(android.os.IBinder remote) &#123;</span><br><span class="line">				mRemote = remote;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> mRemote;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">public</span> java.lang.<span class="function">String <span class="title">getInterfaceDescriptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> DESCRIPTOR;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">				android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">				android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">				<span class="keyword">int</span> _result;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					_data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">					_data.writeInt(a);</span><br><span class="line">					_data.writeInt(b);</span><br><span class="line">					mRemote.transact(Stub.TRANSACTION_add, _data, _reply, <span class="number">0</span>);</span><br><span class="line">					_reply.readException();</span><br><span class="line">					_result = _reply.readInt();</span><br><span class="line">				&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">					_reply.recycle();</span><br><span class="line">					_data.recycle();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> _result;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSACTION_add = (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> <span class="keyword">throws</span> android.os.RemoteException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160; 系统帮我们生成了这个文件之后，我们只需要继承ITest.Stub这个抽象类，实现它的方法，然后在Service 的onBind方法里面返回就实现了AIDL。这个Stub类非常重要，具体看看它做了什么。</p>
<p>&#160; &#160; &#160; &#160; Stub类继承自Binder，意味着这个Stub其实自己是一个Binder本地对象，然后实现了ITest接口，ITest本身是一个IInterface，因此他携带某种客户端需要的能力（这里是方法<code>add</code>)。此类有一个内部类Proxy，也就是Binder代理对象；</p>
<p>&#160; &#160; &#160; &#160; 然后看看<code>asInterface</code>方法，我们在bind一个Service之后，在onServiceConnecttion的回调里面，就是通过这个方法拿到一个远程的service的，这个方法做了什么呢？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Cast an IBinder object into an com.windrunnerlihuan.ITest interface,</span><br><span class="line"> * generating a proxy if needed.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> com.windrunnerlihuan.<span class="function">ITest <span class="title">asInterface</span><span class="params">(</span><br><span class="line">		android.os.IBinder obj)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> ((obj == <span class="keyword">null</span>)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">	<span class="keyword">if</span> (((iin != <span class="keyword">null</span>) &amp;&amp; (iin <span class="keyword">instanceof</span> com.windrunnerlihuan.ITest))) &#123;</span><br><span class="line">		<span class="keyword">return</span> ((com.windrunnerlihuan.ITest) iin);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> com.windrunnerlihuan.ITest.Stub.Proxy(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160; 首先看函数的参数<code>IBinder</code>类型的obj，这个对象是驱动给我们的，如果是Binder本地对象，那么它就是Binder类型，如果是Binder代理对象，那就是<code>BinderProxy</code>类型；然后，正如上面自动生成的文档所说，它会试着查找Binder本地对象，如果找到，说明Client和Server都在同一个进程，这个参数直接就是本地对象，直接强制类型转换然后返回，如果找不到，说明是远程对象（处于另外一个进程）那么就需要创建一个Binde代理对象，让这个Binder代理实现对于远程对象的访问。一般来说，如果是与一个远程Service对象进行通信，那么这里返回的一定是一个Binder代理对象，这个IBinder参数的实际上是BinderProxy;</p>
<p>&#160; &#160; &#160; &#160; 再看看我们对于aidl的<code>add</code> 方法的实现；在<code>Stub</code>类里面，add是一个抽象方法，我们需要继承这个类并实现它；如果Client和Server在同一个进程，那么直接就是调用这个方法；那么，如果是远程调用，这中间发生了什么呢？Client是如何调用到Server的方法的？</p>
<p>&#160; &#160; &#160; &#160; 我们知道，对于远程方法的调用，是通过Binder代理完成的，在这个例子里面就是<code>Proxy</code>类；<code>Proxy</code>对于<code>add</code>方法的实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">	android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">	android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">	<span class="keyword">int</span> _result;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		_data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">		_data.writeInt(a);</span><br><span class="line">		_data.writeInt(b);</span><br><span class="line">		mRemote.transact(Stub.TRANSACTION_add, _data, _reply, <span class="number">0</span>);</span><br><span class="line">		_reply.readException();</span><br><span class="line">		_result = _reply.readInt();</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		_reply.recycle();</span><br><span class="line">		_data.recycle();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> _result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160; 它首先用<code>Parcel</code>把数据序列化了，然后调用了<code>transact</code>方法；这个<code>transact</code>到底做了什么呢？这个<code>Proxy</code>类在<code>asInterface</code>方法里面被创建，前面提到过，如果是Binder代理那么说明驱动返回的IBinder实际是<code>BinderProxy</code>, 因此我们的<code>Proxy</code>类里面的<code>mRemote</code>实际类型应该是<code>BinderProxy</code>；我们看看<code>BinderProxy</code>的<code>transact</code>方法：(Binder.java的内部类)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">transact</span><span class="params">(<span class="keyword">int</span> code, Parcel data, Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        Binder.checkParcel(<span class="keyword">this</span>, code, data, <span class="string">"Unreasonably large binder buffer"</span>);</span><br><span class="line">        <span class="keyword">return</span> transactNative(code, data, reply, flags);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">transactNative</span><span class="params">(<span class="keyword">int</span> code, Parcel data, Parcel reply,</span><br><span class="line">            <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br></pre></td></tr></table></figure></p>
<p>这是一个本地方法；它的实现在native层，具体来说在frameworks/base/core/jni/android_util_Binder.cpp文件:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jboolean <span class="title">android_os_BinderProxy_transact</span><span class="params">(JNIEnv* env, jobject obj,</span><br><span class="line">        jint code, jobject dataObj, jobject replyObj, jint flags)</span> <span class="comment">// throws RemoteException</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">//这段不用看</span></span><br><span class="line">    <span class="keyword">if</span> (dataObj == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        jniThrowNullPointerException(env, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//把java对象解析为C++对象</span></span><br><span class="line">    Parcel* data = parcelForJavaObject(env, dataObj);</span><br><span class="line">    <span class="keyword">if</span> (data == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把java对象解析为C++对象</span></span><br><span class="line">    Parcel* reply = parcelForJavaObject(env, replyObj);</span><br><span class="line">    <span class="keyword">if</span> (reply == <span class="literal">NULL</span> &amp;&amp; replyObj != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/*这部分得说明一下，这是个坑，有兴趣的可以挖：在获取Service Manager远程接口时，在JNI层中，创建了一个BpBinder对象，它的句柄值为0，它的地址保存在gBinderProxyOffsets.mObject中，因此，这里通过下面语句得到这个BpBinder对象的IBinder接口：*/</span></span><br><span class="line">    IBinder* target = (IBinder*)</span><br><span class="line">        env-&gt;GetLongField(obj, gBinderProxyOffsets.mObject);</span><br><span class="line">    <span class="keyword">if</span> (target == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        jniThrowException(env, <span class="string">"java/lang/IllegalStateException"</span>, <span class="string">"Binder has been finalized!"</span>);</span><br><span class="line">        <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//打印LOG，忽略</span></span><br><span class="line">    ALOGV(<span class="string">"Java code calling transact on %p in Java object %p with code %"</span> PRId32 <span class="string">"\n"</span>,</span><br><span class="line">            target, obj, code);</span><br><span class="line"><span class="comment">//干扰视线的宏，忽略</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> ENABLE_BINDER_SAMPLE</span></span><br><span class="line">    <span class="comment">// Only log the binder call duration for things on the Java-level main thread.</span></span><br><span class="line">    <span class="comment">// But if we don't</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> time_binder_calls = should_time_binder_calls();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int64_t</span> start_millis;</span><br><span class="line">    <span class="keyword">if</span> (time_binder_calls) &#123;</span><br><span class="line">        start_millis = uptimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="comment">//这段才是重点</span></span><br><span class="line">    <span class="comment">//printf("Transact from Java code to %p sending: ", target); data-&gt;print();</span></span><br><span class="line">    <span class="keyword">status_t</span> err = target-&gt;transact(code, *data, reply, flags);</span><br><span class="line">    <span class="comment">//if (reply) printf("Transact from Java code to %p received: ", target); reply-&gt;print();</span></span><br><span class="line"><span class="comment">//下面都可以忽略了    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> ENABLE_BINDER_SAMPLE</span></span><br><span class="line">    <span class="keyword">if</span> (time_binder_calls) &#123;</span><br><span class="line">        conditionally_log_binder_call(start_millis, target, code);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">return</span> JNI_TRUE;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (err == UNKNOWN_TRANSACTION) &#123;</span><br><span class="line">        <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    signalExceptionForError(env, obj, err, <span class="literal">true</span> <span class="comment">/*canThrowRemoteException*/</span>);</span><br><span class="line">    <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160; 我在注释中说这儿有个坑，有兴趣的就去挖吧，就是在获取Service Manager远程接口时，在JNI层中，创建了一个<code>BpBinder</code>对象，它的句柄值为0，它的地址保存在<code>gBinderProxyOffsets.mObject</code>中，因此，还得去找<code>BpBinder</code>的<code>transact</code>方法，<code>BpBinder</code>的位置在framework\native\libs\binder\BpBinder.cpp:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> BpBinder::transact(</span><br><span class="line">    <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, Parcel* reply, <span class="keyword">uint32_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Once a binder has died, it will never come back to life.</span></span><br><span class="line">    <span class="keyword">if</span> (mAlive) &#123;</span><br><span class="line">	    <span class="comment">//唉，又是个坑，继续挖IPCThreadState</span></span><br><span class="line">        <span class="keyword">status_t</span> status = IPCThreadState::self()-&gt;transact(</span><br><span class="line">            mHandle, code, data, reply, flags);</span><br><span class="line">        <span class="keyword">if</span> (status == DEAD_OBJECT) mAlive = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> DEAD_OBJECT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160; 继续挖IPCThreadState，位于framework\native\libs\binder\IPCThreadState.cpp(这个self函数就不贴了，就是个单例写法):<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> IPCThreadState::transact(<span class="keyword">int32_t</span> handle,</span><br><span class="line">                                  <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data,</span><br><span class="line">                                  Parcel* reply, <span class="keyword">uint32_t</span> flags)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">status_t</span> err = data.errorCheck();</span><br><span class="line"> </span><br><span class="line">    flags |= TF_ACCEPT_FDS;    </span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">        <span class="comment">//调用writeTransactionData 发送数据</span></span><br><span class="line">		err = writeTransactionData(BC_TRANSACTION, flags, handle, code, data, <span class="literal">NULL</span>);</span><br><span class="line">    &#125; </span><br><span class="line">      <span class="keyword">if</span> ((flags &amp; TF_ONE_WAY) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">            err = waitForResponse(reply);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Parcel fakeReply;</span><br><span class="line">            err = waitForResponse(&amp;fakeReply);</span><br><span class="line">        &#125;</span><br><span class="line">      ....等回复</span><br><span class="line"></span><br><span class="line">        err = waitForResponse(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">   ....    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">再进一步，瞧瞧这个...</span><br><span class="line"></span><br><span class="line"><span class="keyword">status_t</span> IPCThreadState::writeTransactionData(<span class="keyword">int32_t</span> cmd, <span class="keyword">uint32_t</span> binderFlags,</span><br><span class="line">    <span class="keyword">int32_t</span> handle, <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, <span class="keyword">status_t</span>* statusBuffer)</span><br><span class="line">&#123;</span><br><span class="line">    binder_transaction_data tr;</span><br><span class="line">    tr.target.handle = handle;</span><br><span class="line">    tr.code = code;</span><br><span class="line">    tr.flags = binderFlags;    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">status_t</span> err = data.errorCheck();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">        tr.data_size = data.ipcDataSize();</span><br><span class="line">        tr.data.ptr.buffer = data.ipcData();</span><br><span class="line">        tr.offsets_size = data.ipcObjectsCount()*<span class="keyword">sizeof</span>(<span class="keyword">size_t</span>);</span><br><span class="line">        tr.data.ptr.offsets = data.ipcObjects();</span><br><span class="line">    &#125; </span><br><span class="line">....</span><br><span class="line"></span><br><span class="line"><span class="comment">//上面把命令数据封装成binder_transaction_data，然后写到mOut中，mOut是命令的缓冲区，也是一个Parcel</span></span><br><span class="line">    mOut.writeInt32(cmd);</span><br><span class="line">    mOut.write(&amp;tr, <span class="keyword">sizeof</span>(tr));</span><br><span class="line"><span class="comment">//仅仅写到了Parcel中，Parcel好像没和/dev/binder设备有什么关联啊？</span></span><br><span class="line"><span class="comment">//恩，那只能在另外一个地方写到binder设备中去了。难道是在？</span></span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//说对了，就是在waitForResponse中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">status_t</span> IPCThreadState::waitForResponse(Parcel *reply, <span class="keyword">status_t</span> *acquireResult)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> cmd;</span><br><span class="line">    <span class="keyword">int32_t</span> err;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">//talkWithDriver，哈哈，应该是这里了</span></span><br><span class="line">        <span class="keyword">if</span> ((err=talkWithDriver()) &lt; NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line">        err = mIn.errorCheck();</span><br><span class="line">        <span class="keyword">if</span> (err &lt; NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (mIn.dataAvail() == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//看见没？这里开始操作mIn了，看来talkWithDriver中</span></span><br><span class="line"><span class="comment">//把mOut发出去，然后从driver中读到数据放到mIn中了。</span></span><br><span class="line">        cmd = mIn.readInt32(); </span><br><span class="line">        <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">        <span class="keyword">case</span> BR_TRANSACTION_COMPLETE:</span><br><span class="line">            <span class="keyword">if</span> (!reply &amp;&amp; !acquireResult) <span class="keyword">goto</span> finish;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">   .....</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">status_t</span> IPCThreadState::talkWithDriver(<span class="keyword">bool</span> doReceive)</span><br><span class="line">&#123;</span><br><span class="line">binder_write_read bwr;</span><br><span class="line">   <span class="comment">//中间东西太复杂了，不就是把mOut数据和mIn接收数据的处理后赋值给bwr吗？</span></span><br><span class="line">    <span class="keyword">status_t</span> err;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line"><span class="comment">//用ioctl来读写</span></span><br><span class="line">        <span class="keyword">if</span> (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= <span class="number">0</span>)</span><br><span class="line">            err = NO_ERROR;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            err = -errno;</span><br><span class="line">  &#125; <span class="keyword">while</span> (err == -EINTR);</span><br><span class="line"><span class="comment">//到这里，回复数据就在bwr中了，bmr接收回复数据的buffer就是mIn提供的</span></span><br><span class="line">        <span class="keyword">if</span> (bwr.read_consumed &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            mIn.setDataSize(bwr.read_consumed);</span><br><span class="line">            mIn.setDataPosition(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160; 里面进行了一系列的函数调用，确实是个巨恶心的过程；要知道的是它最终调用到了talkWithDriver函数；看这个函数的名字就知道，通信过程要交给驱动完成了（驱动调用是个更恶心的过程，感觉真不是人看的。。。。。）；<br>&#160; &#160; &#160; &#160; （以下过程限于篇幅和巨恶心的过程，所以简要概括，有兴趣的可以自己去挖坑=。=）<br>&#160; &#160; &#160; &#160; 这个函数最后通过ioctl系统调用，Client进程陷入内核态，Client调用add方法的线程挂起等待返回；驱动完成一系列的操作之后唤醒Server进程，调用了Server进程本地对象的onTransact函数（实际上由Server端线程池完成）。我们再看Binder本地对象的onTransact方法（这里就是Stub类里面的此方法）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, android.os.Parcel data,</span><br><span class="line">		android.os.Parcel reply, <span class="keyword">int</span> flags)</span></span><br><span class="line">		<span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">	<span class="keyword">switch</span> (code) &#123;</span><br><span class="line">	<span class="keyword">case</span> INTERFACE_TRANSACTION: &#123;</span><br><span class="line">		reply.writeString(DESCRIPTOR);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">case</span> TRANSACTION_add: &#123;</span><br><span class="line">		data.enforceInterface(DESCRIPTOR);</span><br><span class="line">		<span class="keyword">int</span> _arg0;</span><br><span class="line">		_arg0 = data.readInt();</span><br><span class="line">		<span class="keyword">int</span> _arg1;</span><br><span class="line">		_arg1 = data.readInt();</span><br><span class="line">		<span class="keyword">int</span> _result = <span class="keyword">this</span>.add(_arg0, _arg1);</span><br><span class="line">		reply.writeNoException();</span><br><span class="line">		reply.writeInt(_result);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160; 在Server进程里面，<code>onTransact</code>根据调用号（每个AIDL函数都有一个编号，在跨进程的时候，不会传递函数，而是传递编号指明调用哪个函数）调用相关函数；在这个例子里面，调用了Binder本地对象的<code>add</code>方法；这个方法将结果返回给驱动，驱动唤醒挂起的Client进程里面的线程并将结果返回。于是一次跨进程调用就完成了。</p>
<p>&#160; &#160; &#160; &#160; 至此，你应该对AIDL这种通信方式里面的各个类以及各个角色有了一定的了解；它总是那么一种固定的模式：一个需要跨进程传递的对象一定继承自IBinder，如果是Binder本地对象，那么一定继承Binder实现IInterface，如果是代理对象，那么就实现了IInterface并持有了IBinder引用；</p>
<p>&#160; &#160; &#160; &#160; Proxy与Stub不一样，虽然他们都既是Binder又是IInterface，不同的是Stub采用的是继承（is 关系），Proxy采用的是组合（has 关系）。他们均实现了所有的IInterface函数，不同的是，Stub又使用策略模式调用的是虚函数（待子类实现），而Proxy则使用组合模式。为什么Stub采用继承而Proxy采用组合？事实上，Stub本身is一个IBinder（Binder），它本身就是一个能跨越进程边界传输的对象，所以它得继承IBinder实现transact这个函数从而得到跨越进程的能力（这个能力由驱动赋予）。Proxy类使用组合，是因为他不关心自己是什么，它也不需要跨越进程传输，它只需要拥有这个能力即可，要拥有这个能力，只需要保留一个对IBinder的引用。如果把这个过程做一个类比，在封建社会，Stub好比皇帝，可以号令天下，他生而具有这个权利（不要说宣扬封建迷信。。）如果一个人也想号令天下，可以，“挟天子以令诸侯”。为什么不自己去当皇帝，其一，一般情况没必要，当了皇帝其实限制也蛮多的是不是？我现在既能掌管天下，又能不受约束（Java单继承）；其二，名不正言不顺啊，我本来特么就不是（Binder），你非要我是说不过去，搞不好还会造反。最后呢，如果想当皇帝也可以，那就是asBinder了。在Stub类里面，asBinder返回this，在Proxy里面返回的是持有的组合类IBinder的引用。</p>
<p>&#160; &#160; &#160; &#160; 再去翻阅系统的ActivityManagerServer的源码，就知道哪一个类是什么角色了：IActivityManager是一个IInterface，它代表远程Service具有什么能力，ActivityManagerNative指的是Binder本地对象（类似AIDL工具生成的Stub类），这个类是抽象类，它的实现是ActivityManagerService；因此对于AMS的最终操作都会进入ActivityManagerService这个真正实现；同时如果仔细观察，ActivityManagerNative.java里面有一个非公开类ActivityManagerProxy, 它代表的就是Binder代理对象；是不是跟AIDL模型一模一样呢？那么ActivityManager是什么？他不过是一个管理类而已，可以看到真正的操作都是转发给ActivityManagerNative进而交给他的实现ActivityManagerService 完成的。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>&#160; &#160; &#160; &#160; 至此分析Binder就告一段落了，也是一个越往下挖越恶心的东西。等以后有机会系统学一下Linux内核的知识。虽然兴趣是最好的老师，但是学习也是个循序渐进的过程，不可能一口吃成大胖子。知识的积累也是需要脚踏实地，一步一个脚印。量变引起质变，见多识广之后才能厚积薄发，逐渐形成自己的思维，使自己成长的更强大。同时，积累过程最忌浮躁，不可因外界环境干扰心境，要始终勿忘初心，心态保持平静，不随波逐流，上善若水。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[移动直播技术秒开优化经验]]></title>
      <url>http://windrunnerlihuan.com/2016/06/06/%E7%A7%BB%E5%8A%A8%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C/</url>
      <content type="html"><![CDATA[<p>&#160; &#160; &#160; &#160;以下内容来自<code>@高可用架构</code>，这次当一回技术的搬运工，为大家分享七牛创始人之一————徐立的<code>移动直播技术秒开优化经验</code>。<br><a id="more"></a></p>
<hr>
<blockquote>
<p><div align="center"><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E7%A7%BB%E5%8A%A8%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C/head.jpg" title="徐立"></div><br>&#160; &#160; &#160; &#160;徐立，七牛创始合伙人兼产品副总裁，负责七牛直播云的整体研发，是国内 Go / Docker / Container 技术早期布道者，&gt;Go / Containers / Distributed Systems 技术的忠实爱好者和实践者。曾合著国内第一本 Go 语言图书《Go 语言编程》，翻译《Go 语言程序设计》。</p>
</blockquote>
<p>&#160; &#160; &#160; &#160;现今移动直播技术上的挑战要远远难于传统设备或电脑直播，其完整的处理环节包括但不限于：音视频采集、美颜/滤镜/特效处理、编码、封包、推流、转码、分发、解码/渲染/播放等。</p>
<p>直播常见的问题包括：</p>
<ul>
<li>主播在不稳定的网络环境下如何稳定推流？</li>
<li>偏远地区的观众如何高清流畅观看直播？</li>
<li>直播卡顿时如何智能切换线路？</li>
<li>如何精确度量直播质量指标并实时调整？</li>
<li>移动设备上不同的芯片平台如何高性能编码和渲染视频？</li>
<li>美颜等滤镜特效处理怎么做？</li>
<li>如何实现播放秒开？</li>
<li>如何保障直播持续播放流畅不卡顿？</li>
</ul>
<p>本次分享将为大家揭开移动直播核心技术的神秘面纱。</p>
<h1 id="视频、直播等基础知识"><a href="#视频、直播等基础知识" class="headerlink" title="视频、直播等基础知识"></a>视频、直播等基础知识</h1><h2 id="什么是视频？"><a href="#什么是视频？" class="headerlink" title="什么是视频？"></a>什么是视频？</h2><p>&#160; &#160; &#160; &#160;首先我们需要理解一个最基本的概念：视频。从感性的角度来看，视频就是一部充满趣味的影片，可以是电影，可以是短片，是一连贯的视觉冲击力表现丰富的画面和音频。但从理性的角度来看，视频是一种有结构的数据，用工程的语言解释，我们可以把视频剖析成如下结构：<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E7%A7%BB%E5%8A%A8%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C/whatisav.jpg" alt=""><br>内容元素 ( Content )</p>
<ul>
<li>图像 ( Image )</li>
<li>音频 ( Audio )</li>
<li>元信息 ( Metadata )</li>
</ul>
<p>编码格式 ( Codec )</p>
<ul>
<li>Video : H.264，H.265, …</li>
<li>Audio : AAC， HE-AAC, …</li>
</ul>
<p>容器封装 (Container)</p>
<ul>
<li>MP4，MOV，FLV，RM，RMVB，AVI，…</li>
</ul>
<p>任何一个视频 Video 文件，从结构上讲，都是这样一种组成方式：</p>
<ul>
<li>由图像和音频构成最基本的内容元素；</li>
<li>图像经过视频编码压缩格式处理（通常是 H.264）；</li>
<li>音频经过音频编码压缩格式处理（例如 AAC）；</li>
<li>注明相应的元信息（Metadata）；</li>
</ul>
<p>最后经过一遍容器（Container）封装打包（例如 MP4），构成一个完整的视频文件。</p>
<p>&#160; &#160; &#160; &#160;如果觉得难以理解，可以想象成一瓶番茄酱。最外层的瓶子好比这个容器封装（Container），瓶子上注明的原材料和加工厂地等信息好比元信息（Metadata），瓶盖打开（解封装）后，番茄酱本身好比经过压缩处理过后的编码内容，番茄和调料加工成番茄酱的过程就好比编码（Codec），而原材料番茄和调料则好比最原本的内容元素（Content）。</p>
<h2 id="视频的实时传输"><a href="#视频的实时传输" class="headerlink" title="视频的实时传输"></a>视频的实时传输</h2><p>&#160; &#160; &#160; &#160;简而言之，理性的认知视频的结构后，有助于我们理解视频直播。如果视频是一种“有结构的数据”，那么视频直播无疑是<strong>实时传输</strong>这种“有结构的数据”（视频）的方式。</p>
<p>&#160; &#160; &#160; &#160;那么一个显而易见的问题是：如何实时（Real-Time）传输这种“有结构的数据”（视频）呢？</p>
<p>&#160; &#160; &#160; &#160;这里边一个悖论是：一个经过容器（Container）封装后的视频，一定是不可变的 ( Immutable ) 视频文件，不可变的 ( Immutable ) 的视频文件已经是一个生产结果，根据“相对论”，而这个生产结果显然不可能精确到实时的程度，它已经是一段时空的记忆。</p>
<p>&#160; &#160; &#160; &#160;因此视频直播，一定是一个 “边生产，边传输，边消费” 的过程。这意味着，我们需要更近一步了解视频从原始的内容元素 ( 图像和音频 ) 到成品 ( 视频文件 ) 之前的中间过程 ( 编码 )。</p>
<h2 id="视频编码压缩"><a href="#视频编码压缩" class="headerlink" title="视频编码压缩"></a>视频编码压缩</h2><p>&#160; &#160; &#160; &#160;不妨让我们来深入浅出理解视频编码压缩技术。</p>
<p>&#160; &#160; &#160; &#160;为了便于视频内容的存储和传输，通常需要减少视频内容的体积，也就是需要将原始的内容元素(图像和音频)经过压缩，压缩算法也简称编码格式。例如视频里边的原始图像数据会采用 H.264 编码格式进行压缩，音频采样数据会采用 AAC 编码格式进行压缩。</p>
<p>&#160; &#160; &#160; &#160;视频内容经过编码压缩后，确实有利于存储和传输; 不过当要观看播放时，相应地也需要解码过程。因此编码和解码之间，显然需要约定一种编码器和解码器都可以理解的约定。就视频图像编码和解码而言，这种约定很简单：</p>
<p><strong>编码器将多张图像进行编码后生产成一段一段的 GOP ( Group of Pictures ) ， 解码器在播放时则是读取一段一段的 GOP 进行解码后读取画面再渲染显示。</strong><br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E7%A7%BB%E5%8A%A8%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C/whathappend1.jpg" alt=""><br>&#160; &#160; &#160; &#160;GOP ( Group of Pictures ) 是一组连续的画面，由一张 I 帧和数张 B / P 帧组成，是视频图像编码器和解码器存取的基本单位，它的排列顺序将会一直重复到影像结束。<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E7%A7%BB%E5%8A%A8%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C/whathappend2.jpg" alt=""><br>&#160; &#160; &#160; &#160;I 帧是内部编码帧（也称为关键帧），P 帧是前向预测帧（前向参考帧），B 帧是双向内插帧（双向参考帧）。简单地讲，I 帧是一个完整的画面，而 P 帧和 B 帧记录的是相对于 I 帧的变化。</p>
<p><strong>如果没有 I 帧，P 帧和 B 帧就无法解码。</strong><br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E7%A7%BB%E5%8A%A8%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C/mainvsref.jpg" alt=""><br>&#160; &#160; &#160; &#160;小结一下，一个视频 ( Video ) ，其图像部分的数据是一组 GOP 的集合, 而单个 GOP 则是一组 I / P / B 帧图像的集合。</p>
<p>&#160; &#160; &#160; &#160;在这样的一种几何关系中，Video 好比一个 “物体”，GOP 好比 “分子”，I / P / B 帧的图像则好比 “原子”。</p>
<p>&#160; &#160; &#160; &#160;想象一下，如果我们把传输一个 “物体”，改成传输一个一个的 “原子”，将最小颗粒以光速传送，那么以人的生物肉眼来感知，将是一种怎样的体验？</p>
<h2 id="什么是视频直播？"><a href="#什么是视频直播？" class="headerlink" title="什么是视频直播？"></a>什么是视频直播？</h2><p>&#160; &#160; &#160; &#160;不难脑洞大开一下，直播就是这样的一种体验。视频直播技术，就是将视频内容的最小颗粒 ( I / P / B 帧，…)，基于时间序列，以光速进行传送的一种技术。</p>
<p>&#160; &#160; &#160; &#160;简而言之，直播就是将每一帧数据 ( Video / Audio / Data Frame )，打上时序标签 ( Timestamp ) 后进行流式传输的过程。发送端源源不断的采集音视频数据，经过编码、封包、推流，再经过中继分发网络进行扩散传播，播放端再源源不断地下载数据并按时序进行解码播放。如此就实现了 “边生产、边传输、边消费” 的直播过程。</p>
<p>&#160; &#160; &#160; &#160;理解以上两个关于<code>视频</code>和<code>直播</code>两个基础概念后，接下来我们就可以一窥直播的业务逻辑了。</p>
<h2 id="直播的业务逻辑"><a href="#直播的业务逻辑" class="headerlink" title="直播的业务逻辑"></a>直播的业务逻辑</h2><p>如下是一个最精简的一对多直播业务模型，以及各个层级之间的协议。<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E7%A7%BB%E5%8A%A8%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C/liveprotocol.jpg" alt=""><br>各协议差异对比如下：<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E7%A7%BB%E5%8A%A8%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C/protocoldiff1.jpg" alt=""><br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E7%A7%BB%E5%8A%A8%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C/protocoldiff2.jpg" alt=""><br>以上就是关于直播技术的一些基础概念。下面我们进一步了解下影响人们视觉体验的直播性能指标。</p>
<h1 id="影响视觉体验的直播性能指标"><a href="#影响视觉体验的直播性能指标" class="headerlink" title="影响视觉体验的直播性能指标"></a>影响视觉体验的直播性能指标</h1><p>&#160; &#160; &#160; &#160;<strong>直播第一个性能指标是延迟</strong>，延迟是数据从信息源发送到目的地所需的时间。<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E7%A7%BB%E5%8A%A8%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C/delay1.jpg" alt=""><br>根据爱因斯坦的狭义相对论，光速是所有能量、物质和信息运动所能达到的最高速度，这个结论给传播速度设定了上限。因此，即便我们肉眼感觉到的实时，实际上也是有一定的延迟。<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E7%A7%BB%E5%8A%A8%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C/delay2.jpg" alt=""><br>由于 RTMP/HLS 是基于 TCP 之上的应用层协议，TCP 三次握手，四次挥手，慢启动过程中的每一次往返来回，都会加上一次往返耗时 ( RTT )，这些交互过程都会增加延迟。<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E7%A7%BB%E5%8A%A8%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C/delay3.jpg" alt=""><br>其次根据 TCP 丢包重传特性，网络抖动可能导致丢包重传，也会间接导致延迟加大。<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E7%A7%BB%E5%8A%A8%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C/jitter.jpg" alt=""><br>&#160; &#160; &#160; &#160;一个完整的直播过程，包括但不限于以下环节：<strong>采集、处理、编码、封包、推流、传输、转码、分发、拉流、解码、播放</strong>。从推流到播放，再经过中间转发环节，延迟越低，则用户体验越好。</p>
<p>&#160; &#160; &#160; &#160;<strong>第二个直播性能指标卡顿</strong>，是指视频播放过程中出现画面滞帧，让人们明显感觉到“卡”。单位时间内的播放卡顿次数统计称之为卡顿率。</p>
<p>&#160; &#160; &#160; &#160;造成卡顿的因素有可能是推流端发送数据中断，也有可能是公网传输拥塞或网络抖动异常，也有可能是终端设备的解码性能太差。卡顿频次越少或没有，则说明用户体验越好。</p>
<p>&#160; &#160; &#160; &#160;<strong>第三个直播性能指标首屏耗时</strong>，指第一次点击播放后，肉眼看到画面所等待的时间。技术上指播放器解码第一帧渲染显示画面所花的耗时。通常说的 “秒开”，指点击播放后，一秒内即可看到播放画面。首屏打开越快，说明用户体验越好。</p>
<p>&#160; &#160; &#160; &#160;如上三个直播性能指标，分别对应一个低延迟、高清流畅、极速秒开 的用户体验诉求。了解这三个性能指标，对优化移动直播 APP 的用户体验至关重要。</p>
<p>&#160; &#160; &#160; &#160;那么移动直播场景下具体而言有哪些常见的坑呢？</p>
<p>&#160; &#160; &#160; &#160;根据实践总结下来的经验，移动平台上视频直播的坑主要可以总结为两方面：设备差异，以及网络环境这些场景下带来的技术考验。</p>
<h1 id="移动直播场景的坑与规避措施"><a href="#移动直播场景的坑与规避措施" class="headerlink" title="移动直播场景的坑与规避措施"></a>移动直播场景的坑与规避措施</h1><h2 id="不同芯片平台上的编码差异"><a href="#不同芯片平台上的编码差异" class="headerlink" title="不同芯片平台上的编码差异"></a>不同芯片平台上的编码差异</h2><p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E7%A7%BB%E5%8A%A8%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C/delay2.jpg" alt=""><br><strong>iOS 平台上无论硬编还是软编，由于是 Apple 一家公司出厂，几乎不存在因为芯片平台不同而导致的编码差异</strong>。</p>
<p>&#160; &#160; &#160; &#160;然而，在 Android 平台上，Android Framework SDK 提供的 MediaCodec 编码器，在不同的芯片平台上，差异表现很大， 不同的厂家使用不同的芯片，而不同的芯片平台上 Android MediaCodec 表现略有差异，通常实现全平台兼容的成本不低。</p>
<p>&#160; &#160; &#160; &#160;另外就是 Android MediaCodec 硬编层面的 H.264 编码画质参数是固定的 baseline，所以画质通常也一般。因此，在 Android 平台下，<strong>推荐是用软编，好处是画质可调控，兼容性也更好</strong>。</p>
<h2 id="低端设备如何上高性能地采集和编码？"><a href="#低端设备如何上高性能地采集和编码？" class="headerlink" title="低端设备如何上高性能地采集和编码？"></a>低端设备如何上高性能地采集和编码？</h2><p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E7%A7%BB%E5%8A%A8%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C/gether.jpg" alt=""><br>&#160; &#160; &#160; &#160;例如 Camera 采集输出的可能是图片，一张图的体积并不会小，如果采集的频次很高，编码的帧率很高，每张图都经过编码器，那么编码器又可能会出现过载。</p>
<p>&#160; &#160; &#160; &#160;这个时候，可以考虑在编码前，不影响画质的前提下（前面我们讲过帧率的微观意义），进行<strong>选择性丢帧</strong>，以此降低编码环节的功耗开销。</p>
<h2 id="弱网下如何保障高清流畅推流"><a href="#弱网下如何保障高清流畅推流" class="headerlink" title="弱网下如何保障高清流畅推流"></a>弱网下如何保障高清流畅推流</h2><p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E7%A7%BB%E5%8A%A8%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C/resource.jpg" alt=""><br>&#160; &#160; &#160; &#160;移动网络下，通常容易遇到网络不稳定，连接被重置，断线重连，一方面频繁重连，建立连接需要开销。另一方面尤其是发生 GPRS / 2G / 3G / 4G 切换时，带宽可能出现瓶颈。当带宽不够，帧率较高/码率较高的内容较难发送出去，这个时候就需要可变码率支持。</p>
<p>&#160; &#160; &#160; &#160;即在推流端，可检测网络状态和简单测速，动态来切换码率，以保障网络切换时的推流流畅。</p>
<p>&#160; &#160; &#160; &#160;其次编码、封包、推流 这一部分的逻辑也可以做微调，可以尝试选择性丢帧，比如优先丢视频参考帧（不丢 I 帧和音频帧 )，这样也可以减少要传输的数据内容，但同时又达到了不影响画质和版视听流畅的目的。</p>
<h2 id="需要区分直播流的状态和业务状态"><a href="#需要区分直播流的状态和业务状态" class="headerlink" title="需要区分直播流的状态和业务状态"></a>需要区分直播流的状态和业务状态</h2><p>&#160; &#160; &#160; &#160;直播是媒体流、APP 的交互是 API 信令流，两者的状态不能混为一谈。尤其是不能基于 APP 的交互的 API 状态来判断直播流的状态。<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E7%A7%BB%E5%8A%A8%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C/seeproduct.jpg" alt=""><br>以上是移动直播场景下常见的几个坑和规避措施。</p>
<h1 id="移动直播场景其他优化措施"><a href="#移动直播场景其他优化措施" class="headerlink" title="移动直播场景其他优化措施"></a>移动直播场景其他优化措施</h1><h2 id="一、怎么优化打开速度，达到传说中的-“秒开”？"><a href="#一、怎么优化打开速度，达到传说中的-“秒开”？" class="headerlink" title="一、怎么优化打开速度，达到传说中的 “秒开”？"></a>一、怎么优化打开速度，达到传说中的 “秒开”？</h2><p>一、怎么优化打开速度，达到传说中的 “秒开”？</p>
<p>&#160; &#160; &#160; &#160;大家可能会看到，市面上某些手机直播 APP 的打开速度非常快，一点就开。而某些手机直播 APP，点击播放后要等好几秒以后才能播放。是什么原因导致如此的天壤之别呢？</p>
<p>&#160; &#160; &#160; &#160;大部分播放器都是拿到一个完成的 GOP 后才能解码播放，基于 FFmpeg 移植的播放器甚至需要等待音画时间戳同步后才能播放（如果一个直播里边没有音频只有视频相当于要等待音频超时后才能播放画面）。</p>
<p>“秒开”可以从以下几个方面考虑：</p>
<h3 id="1-改写播放器逻辑让播放器拿到第一个关键帧后就给予显示。"><a href="#1-改写播放器逻辑让播放器拿到第一个关键帧后就给予显示。" class="headerlink" title="1. 改写播放器逻辑让播放器拿到第一个关键帧后就给予显示。"></a>1. 改写播放器逻辑让播放器拿到第一个关键帧后就给予显示。</h3><p>&#160; &#160; &#160; &#160;GOP 的第一帧通常都是关键帧，由于加载的数据较少，可以达到 “首帧秒开”。</p>
<p>&#160; &#160; &#160; &#160;如果直播服务器支持 GOP 缓存，意味着播放器在和服务器建立连接后可立即拿到数据，从而省却跨地域和跨运营商的回源传输时间。</p>
<p>&#160; &#160; &#160; &#160;GOP 体现了关键帧的周期，也就是两个关键帧之间的距离，即一个帧组的最大帧数。假设一个视频的恒定帧率是 24fps（即1秒24帧图像），关键帧周期为 2s，那么一个 GOP 就是 48 张图像。一般而言，每一秒视频至少需要使用一个关键帧。</p>
<p>&#160; &#160; &#160; &#160;<strong>增加关键帧个数可改善画质（GOP 通常为 FPS 的倍数），但是同时增加了带宽和网络负载</strong>。这意味着，客户端播放器下载一个 GOP，毕竟该 GOP 存在一定的数据体积，如果播放端网络不佳，有可能不是能够快速在秒级以内下载完该 GOP，进而影响观感体验。</p>
<p>&#160; &#160; &#160; &#160;如果不能更改播放器行为逻辑为首帧秒开，直播服务器也可以做一些取巧处理，比如<strong>从缓存 GOP 改成缓存双关键帧</strong>（减少图像数量），这样可以极大程度地减少播放器加载 GOP 要传输的内容体积。</p>
<h3 id="2-在-APP-业务逻辑层面方面优化。"><a href="#2-在-APP-业务逻辑层面方面优化。" class="headerlink" title="2. 在 APP 业务逻辑层面方面优化。"></a>2. 在 APP 业务逻辑层面方面优化。</h3><p>&#160; &#160; &#160; &#160;比如提前做好 DNS 解析（省却几十毫秒），和提前做好测速选线（择取最优线路）。经过这样的预处理后，在点击播放按钮时，将极大提高下载性能。</p>
<p>&#160; &#160; &#160; &#160;一方面，可以围绕传输层面做性能优化；另一方面，可以围绕客户播放行为做业务逻辑优化。两者可以有效的互为补充，作为秒开的优化空间。</p>
<h2 id="二、美颜等滤镜如何处理？"><a href="#二、美颜等滤镜如何处理？" class="headerlink" title="二、美颜等滤镜如何处理？"></a>二、美颜等滤镜如何处理？</h2><p>&#160; &#160; &#160; &#160;在手机直播场景下，这就是一个刚需。没有美颜功能的手机直播 APP，主播基本不爱用。可以在采集画面后，将数据送给编码器之前，将数据源回调给滤镜处理程序，原始数据经过滤镜处理完后，再送回给编码器进行编码即可。</p>
<p>&#160; &#160; &#160; &#160;除了移动端可以做体验优化之外，直播流媒体服务端架构也可以降低延迟。例如收流服务器主动推送 GOP 至边缘节点，边缘节点缓存 GOP，播放端则可以快速加载，减少回源延迟。<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E7%A7%BB%E5%8A%A8%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C/push.jpg" alt=""><br>其次，可以贴近终端就近处理和分发<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E7%A7%BB%E5%8A%A8%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C/deliver.jpg" alt=""></p>
<h2 id="三、如何保障直播持续播放流畅不卡顿？"><a href="#三、如何保障直播持续播放流畅不卡顿？" class="headerlink" title="三、如何保障直播持续播放流畅不卡顿？"></a>三、如何保障直播持续播放流畅不卡顿？</h2><p>&#160; &#160; &#160; &#160;“秒开”解决的是直播首次加载的播放体验，如何保障直播持续播放过程中的画面和声音视听流畅呢？因为，一个直播毕竟不是一个 HTTP 一样的一次性请求，而是一个 Socket 层面的长连接维持，直到直到主播主动终止推流。</p>
<p>&#160; &#160; &#160; &#160;上述我们讲过卡顿的定义：即播放时画面滞帧，触发了人们的视觉感受。在不考虑终端设备性能差异的情况下，针对网络传输层面的原因，我们看看如何保障一个持续的直播不卡顿。</p>
<p>&#160; &#160; &#160; &#160;这其实是一个直播过程中传输网络不可靠时的容错问题。例如，播放端临时断网了，但又快速恢复了，针对这种场景，播放端如果不做容错处理，很难不出现黑屏或是重新加载播放的现象。</p>
<p>&#160; &#160; &#160; &#160;为了容忍这种网络错误，并达到让终端用户无感知，<strong>客户端播放器可以考虑构建一个FIFO（先进先出）的缓冲队列</strong>，解码器从播放缓存队列读取数据，缓存队列从直播服务器源源不断的下载数据。通常，缓存队列的容量是以时间为单位（比如3s），在播放端网络不可靠时，客户端缓存区可以起到“断网无感”的过渡作用。</p>
<p>&#160; &#160; &#160; &#160;显然，这只是一个“缓兵之计”，如果直播服务器边缘节点出现故障，而此时客户端播放器又是长连接，在无法收到对端的连接断开信号，客户端的缓冲区容量再大也不管用了，这个时候就需要结合客户端业务逻辑来做调度。</p>
<p>&#160; &#160; &#160; &#160;重要的是客户端结合服务端，可以做精准调度。在初始化直播推流之前，例如基于 IP 地理位置和运营商的精确调度，分配线路质量最优的边缘接入节点。在直播推流的过程中，可以实时监测帧率反馈等质量数据，基于直播流的质量动态调整线路。</p>
<h1 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h1><p><strong>1. 关键帧设置频率一般是多少？有没有根据接入动态设置？过长首屏秒会很难做到。</strong></p>
<p>徐立：关键帧间隔越长，也就是 GOP 越长，理论上画面越高清。但是生成 HLS 直播时，最小切割粒度也是一个 GOP，所以针对交互直播，通常不建议 GOP 设置太长。直播一般 2 个关键帧间隔即可。比如帧率是 24fps， 那么 2 个关键帧的间隔就是 48fps ，这个 GOP 就是2s。</p>
<p><strong>2. 七牛这个直播是用的网宿加速？有遇到什么坑没？</strong></p>
<p>徐立：七牛在直播方面主要是自建节点，也支持融合众多第三方 CDN 服务商，多样化的线路组合为客户提供更优质的服务。在和第三方 CDN 合作的过程中遇到的问题等有机会再做更细粒度的交流和分享。</p>
<p><strong>3. RTMP 直播流除了优化线路外，还有什么加速手段吗？</strong></p>
<p>徐立：物理上优化线路，逻辑上优化策略，比如选择性丢帧，不影响编码画质的前提下减轻传输体积。</p>
<p><strong>4. OBS 推流，播放端 HLS 出现视/音频不同步是哪个环节的问题？怎么优化？</strong></p>
<p>徐立：有可能是采集端的问题，如果是采集端编码环节就出现音画不同步，可以在收流服务器上做音画时间戳同步，这样是全局的校对。如果是播放端解码性能问题，那么需要调节播放逻辑，比如保证音画时间戳强一致性的前提下，选择性丢一部帧。</p>
<p><strong>5. PPT 前几页中一个概念好像错了，I 帧不是关键帧，IDR 帧才是。IDR 帧是 I 帧，但是 I 帧不一定是 IDR 帧。只有 IDR 帧才是可重入的。</strong></p>
<p>徐立：中文都把 I 帧翻译成关键帧了，不过既然提到了 IDR 帧，可以展开说明一下。所有的 IDR 帧都是 I 帧，但是并不是所有 I 帧都是 IDR 帧，IDR 帧是 I 帧的子集。I 帧严格定义是帧内编码帧，由于是一个全帧压缩编码帧，通常用 I 帧表示 “关键帧”。IDR 是基于 I 帧的一个 “扩展”，带了控制逻辑，IDR 图像都是 I 帧图像，当解码器解码到 IDR 图像时，会立即将参考帧队列清空，将已解码的数据全部输出或抛弃。重新查找参数集，开始一个新的序列。这样如果前一个序列出现重大错误，在这里可以获得重新同步的机会。IDR 图像之后的图像永远不会使用 IDR 之前的图像的数据来解码。</p>
<p><strong>6. 有没有调研过 nginx rtmp module，为什么没有用，对它有什么评价？</strong></p>
<p>徐立：有调研过，nginx_rtmp_module 是单进程多线程，非 go 这种轻量级线程/协程用并发自然语义的方式编写流业务。nginx 原本的代码量较大（约 16 万行，但和直播业务相关的功能并不是很多）。且主要靠写 nginx.conf 做配置租户，通常单租户可以，但业务可扩展性方面不是很灵活，可满足基本需求，不满足高级功能。</p>
<p><strong>7. 用到了那些开源软件？编码用的是 x264 吗？直播服务器你们自己开发还是开源的？</strong></p>
<p>徐立：直播服务器用 go 开发的，移动端编码优先硬编，软编用 x264</p>
<p><strong>8. 请教一下用 OBS 推流到 nginx_rtmp_module 的时候是已经做了视频压缩了还是需要基于 OBS 再开发？</strong></p>
<p>徐立：OBS 把编码压缩都做了，不需要再开发。</p>
<p><strong>9. 视频直播想在 HLS 流中无缝插入一段广告的 ts 文件，有问题想请教一下：1、这段 ts 的分辨率是否一定要和之前的视频流一致？2、pts 时间戳是否要和上一个 ts 递增？</strong></p>
<p>徐立：<br>1、可以不一致。这种情况两段视频完全是独立状态，可以没有任何关系，只需要插入 discontinue 标记，播放器在识别到这个标记之后重置解码器参数就可以无缝播放，画面会很平滑的切换。<br>2、不需要递增。举个例子，视频 A 正在直播，播放到 pts 在 5s 的时候，插入一个视频 B，需要先插入一个 discontinue，再插入 B，等 B 播放完之后，再插入一个 discontinue，再插入 A，这个时候 A 的 pts 可以和之前递增，也可以按照中间插入的 B 的时长做偏移，一般做点播和时移的时候 pts 会连续递增，直播的话会算上 B 的时长。</p>
<p>由于移动直播在实践上还有非常多细节，本文未能全部覆盖，感兴趣的朋友欢迎在文章最后留言讨论。</p>
<h1 id="PPT-下载地址"><a href="#PPT-下载地址" class="headerlink" title="PPT 下载地址"></a>PPT 下载地址</h1><p>我备份了一分pdf，下载点<a href="http://o7xxrho8u.bkt.clouddn.com/file/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E7%A7%BB%E5%8A%A8%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C/pili_technology_sharing.pdf" target="_blank" rel="external">这里</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[博客搭建历程————————Github和Hexo]]></title>
      <url>http://windrunnerlihuan.com/2016/05/27/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%8E%86%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>我的博客搭建历程，使用github pages + hexo，域名解析，配置插件<br><a id="more"></a></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&#160; &#160; &#160; &#160;其实从去年开始我就想搭建一个自己的个人网站了，主要用于记录自己的技术积累和重点知识。但由于自己太懒，能力也太渣，所以就一直没有行动。直到今年，突然发现随着知识积累的增加，有好多重要的内容脑袋都记不下了，有的网页就直接存个标签，但是标签越存越多，但却很少再次去浏览，最后知识还是会淡忘，所以今天痛下决心，还是自己搭个博客吧，以挽回知识的流失，同时也可以向外部分享自己的一些见解。<br>&#160; &#160; &#160; &#160;博客搭建过程也是一波三折，遇到各种坑爹问题，还好我没那么轻易放弃，最终在无数次失败之后终于成功了。</p>
<hr>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="1-github配置"><a href="#1-github配置" class="headerlink" title="1. github配置"></a>1. github配置</h2><p>1）首先需要有一个github账号，没有的话就得申请一个。<br>然后新建一个代码仓库，注意，仓库名一定要是：<strong>你的github账号名字.github.io</strong>，比如我的是windrunnerlihuan.github.io。<br>2）clone到本地，比如我的就是如下命令：<br>git clone <a href="https://github.com/windrunnerlihuan/windrunnerlihuan.github.io.git" target="_blank" rel="external">https://github.com/windrunnerlihuan/windrunnerlihuan.github.io.git</a><br>cd 进文件夹，我们先建个index.html用于测试：<br>cd windrunnerlihuan.github.io<br>vi index.html<br>然后编辑：<br><figure class="highlight vbscript-html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;github pages测试&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>然后按esc，再输入“:wq”回车保存。然后提交上去：<br>git add .<br>git commit -m “测试github pages”<br>git push<br>此时需要输入你的github账号和密码，输入就是了，成功后我们验证一下。<br>然后打开浏览器，输入地址，比如我的就是：<a href="http://windrunnerlihuan.github.io" target="_blank" rel="external">http://windrunnerlihuan.github.io</a><br>如果能正确显示“<strong>github pages测试</strong>”字样，说明我们成功了。</p>
<hr>
<h2 id="2-hexo安装"><a href="#2-hexo安装" class="headerlink" title="2. hexo安装"></a>2. hexo安装</h2><p>&#160; &#160; &#160; &#160;Hexo 是一个简单地、轻量地、基于Node的一个静态博客框架。通过Hexo我们可以快速创建自己的博客，仅需要几条命令就可以完成。</p>
<p>Hexo的官方网站：<a href="http://hexo.io/" target="_blank" rel="external">http://hexo.io/</a> ，也是基于Github构建的网站。</p>
<p>&#160; &#160; &#160; &#160;不过要使用hexo必须装node.js，这个easy，直接在官网<a href="https://nodejs.org/en/" target="_blank" rel="external">https://nodejs.org/en/</a> 上下一个，首页就是下载页面，选一个你自己电脑平台对应的，比如我的是windows x64。如果不想看英文呢，还有个中文网站<a href="http://nodejs.cn/" target="_blank" rel="external">http://nodejs.cn/</a> ，几乎是把英文网站翻译了一遍，套路都一样。下载下来之后文件名叫<strong>node-v4.4.4-x64.msi</strong>，双击，一路next，傻瓜式安装。</p>
<p>接着安装hexo：<br>1）打开控制台（按下win + r，输入cmd，回车）或者直接在git bash界面。<br>输入 npm install -g hexo，然后开始安装hexo。<br>成功后再输入 npm install hexo-deployer-git –save，安装发布工具。</p>
<p>2）接着进入我们从github上克隆下来的windrunnerlihuan.github.io文件，再次git bash here。<br>输入 hexo init，初始化hexo。<br>完成后我们测试一下：<br>输入hexo server<br>bash控制台会打印出 “[info] Hexo is running at <a href="http://localhost:4000/" target="_blank" rel="external">http://localhost:4000/</a>. Press Ctrl+C to stop.”<br>这时端口4000被打开了，我们能过浏览器打开地址，<a href="http://localhost:4000/" target="_blank" rel="external">http://localhost:4000/</a> 。</p>
<p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%8E%86%E7%A8%8B/home.png" alt="hexo首页默认图片"></p>
<p>出现了默认的网页界面，是不是很容易呢！！</p>
<hr>
<h2 id="3-hexo配置"><a href="#3-hexo配置" class="headerlink" title="3. hexo配置"></a>3. hexo配置</h2><p>我们先看一下文件结构</p>
<p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%8E%86%E7%A8%8B/file.png" alt="hexo文件结构图图片"></p>
<ul>
<li>scaffolds 脚手架，也就是一个工具模板</li>
<li>scripts 写文件的js，扩展hexo的功能</li>
<li>source 存放博客正文内容</li>
<li>source/_drafts 草稿箱</li>
<li>source/_posts 文件箱</li>
<li>themes 存放皮肤的目录</li>
<li>themes/landscape 默认的皮肤</li>
<li>_config.yml 全局的配置文件</li>
<li>db.json 静态常量</li>
</ul>
<p>在这里，我们每次用到的就是_posts目录里的文件，而_config.yml文件和themes目录是第一次配置好就行了。</p>
<p>_posts目录：Hexo是一个静态博客框架，因此没有数据库。文章内容都是以文本文件方式进行存储的，直接存储在_posts的目录。Hexo天生集成了markdown，我们可以直接使用markdown语法格式写博客，例如:hello-world.md。新增加一篇文章，就在_posts目录，新建一个xxx.md的文件。</p>
<p>themes目录：是存放皮肤的，包括一套Javascript+CSS样式和基于EJS的模板设置。通过在themes目录下，新建一个子目录，就可以创建一套新的皮肤，当然我们也可以直接在landscape上面修改。</p>
<p>我们主要改的就是_config.yml全局配置文件，以及新建文章时要增加或者修改文章在source/-posts/目录下的md文件。</p>
<p>1）修改_config.yml全局配置文件</p>
<p>_config.yml是全局的配置文件：很多的网站配置都在这个文件中定义。</p>
<ul>
<li>站点信息: 定义标题，作者，语言</li>
<li>URL: URL访问路径</li>
<li>文件目录: 正文的存储目录</li>
<li>写博客配置：文章标题，文章类型，外部链接等</li>
<li>目录和标签：默认分类，分类图，标签图</li>
<li>归档设置：归档的类型</li>
<li>服务器设置：IP，访问端口，日志输出</li>
<li>时间和日期格式： 时间显示格式，日期显示格式</li>
<li>分页设置：每页显示数量</li>
<li>评论：外挂的Disqus评论系统</li>
<li>插件和皮肤：换皮肤，安装插件</li>
<li>Markdown语言：markdown的标准</li>
<li>CSS的stylus格式：是否允许压缩</li>
<li>部署配置：github发布</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># Hexo Configuration</span></span><br><span class="line"><span class="section">## Docs: https://hexo.io/docs/configuration.html</span></span><br><span class="line"><span class="section">## Source: https://github.com/hexojs/hexo/</span></span><br><span class="line"></span><br><span class="line"><span class="section"># Site 站点信息</span></span><br><span class="line">title: this way, little boy</span><br><span class="line">subtitle: 無限大な夢のあとの 何もない世の中じゃ</span><br><span class="line">description:</span><br><span class="line">author: Huan Li</span><br><span class="line">language:</span><br><span class="line">timezone:</span><br><span class="line"></span><br><span class="line"><span class="section"># URL</span></span><br><span class="line"><span class="section">## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'</span></span><br><span class="line">url: http://windrunnerlihuan.com</span><br><span class="line">root: /</span><br><span class="line">permalink: :year/:month/:day/:title/</span><br><span class="line">permalink_defaults:</span><br><span class="line"></span><br><span class="line"><span class="section"># Directory 文件目录</span></span><br><span class="line">source_dir: source</span><br><span class="line">public_dir: public</span><br><span class="line">tag_dir: tags</span><br><span class="line">archive_dir: archives</span><br><span class="line">category_dir: categories</span><br><span class="line">code_dir: downloads/code</span><br><span class="line">i18n_dir: :lang</span><br><span class="line">skip_render:</span><br><span class="line"></span><br><span class="line"><span class="section"># Writing 写博客配置</span></span><br><span class="line">new<span class="emphasis">_post_</span>name: :title.md # File name of new posts</span><br><span class="line">default_layout: post</span><br><span class="line">titlecase: false # Transform title into titlecase</span><br><span class="line">external_link: true # Open external links in new tab</span><br><span class="line">filename_case: 0</span><br><span class="line">render_drafts: false</span><br><span class="line">post<span class="emphasis">_asset_</span>folder: false</span><br><span class="line">relative_link: false</span><br><span class="line">future: true</span><br><span class="line">highlight:</span><br><span class="line">  enable: true</span><br><span class="line">  line_number: true</span><br><span class="line">  auto_detect: false</span><br><span class="line">  tab_replace:</span><br><span class="line"></span><br><span class="line"><span class="section"># Category &amp; Tag 目录和标签</span></span><br><span class="line">default_category: uncategorized</span><br><span class="line">category_map:</span><br><span class="line">tag_map:</span><br><span class="line"></span><br><span class="line"><span class="section"># Date / Time format 时间和日期</span></span><br><span class="line"><span class="section">## Hexo uses Moment.js to parse and display date</span></span><br><span class="line"><span class="section">## You can customize the date format as defined in</span></span><br><span class="line"><span class="section">## http://momentjs.com/docs/#/displaying/format/</span></span><br><span class="line">date_format: YYYY-MM-DD</span><br><span class="line">time_format: HH:mm:ss</span><br><span class="line"></span><br><span class="line"><span class="section"># Pagination 分页设置</span></span><br><span class="line"><span class="section">## Set per_page to 0 to disable pagination</span></span><br><span class="line">per_page: 10</span><br><span class="line">pagination_dir: page</span><br><span class="line"></span><br><span class="line"><span class="section"># Markdown Markdown语法</span></span><br><span class="line"><span class="section">## https://github.com/chjj/marked</span></span><br><span class="line">markdown:</span><br><span class="line">  gfm: true</span><br><span class="line">  pedantic: false</span><br><span class="line">  sanitize: false</span><br><span class="line">  tables: true</span><br><span class="line">  breaks: true</span><br><span class="line">  smartLists: true</span><br><span class="line">  smartypants: true</span><br><span class="line"></span><br><span class="line"><span class="section"># Deployment 部署配置</span></span><br><span class="line"><span class="section">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/windrunnerlihuan/windrunnerlihuan.github.io.git</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;其他没啥改动的，就改个<strong>Site 站点信息</strong>，<strong>URL</strong>，还有<strong>Deployment 部署配置</strong>，前两个没啥难度，这个<strong>Deployment 部署配置</strong>很重要：</p>
<ul>
<li>其中<strong>type</strong>一定要填git，因为以前低版本的hexo是github，不过现在早就废弃了。</li>
<li>其次<strong>repo</strong>填你github项目的clone地址，http/https/ssh类型都行，我的是<br><a href="https://github.com/windrunnerlihuan/windrunnerlihuan.github.io.git" target="_blank" rel="external">https://github.com/windrunnerlihuan/windrunnerlihuan.github.io.git</a> 和git@github.com:windrunnerlihuan/windrunnerlihuan.github.io.git ，我填的是第一个，因为填第二个后期发布时会验证公钥，需要用git bash生成公钥，然后贴到项目的Deploy keys里，比较麻烦，所以为了省事，我填了第一个。</li>
</ul>
<p>2） 新建博客</p>
<p>接下来，我们开始新博客了，创建第一篇博客文章。Hexo建议通过命令行操作，当然你也可以直接在_posts目录下创建文件。</p>
<p>通过命令创建新文章，在bash 里输入 hexo new “新的开始”<br>在source/_posts目录下就会生成文件：”新的开始.md”。</p>
<p>然后我们编辑 <strong>新的开始.md</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 新的开始</span><br><span class="line">date: 2016-05-27 18:44:12</span><br><span class="line">tags:</span><br><span class="line">- 开始</span><br><span class="line">categories: 日志</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">这是**新的开始**，我用hexo创建了第一篇文章。</span><br><span class="line"></span><br><span class="line">## 引用</span><br><span class="line"># Swig语法</span><br><span class="line">&#123;% blockquote Seth Godin http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html Welcome to Island Marketing %&#125;</span><br><span class="line">Every interaction is both precious and an opportunity to delight.</span><br><span class="line">&#123;% endblockquote %&#125;</span><br><span class="line"># Markdown语法</span><br><span class="line">&gt; Every interaction is both precious and an opportunity to delight.</span><br><span class="line"></span><br><span class="line">## 链接</span><br><span class="line"># Swig语法</span><br><span class="line">&#123;% link gank日志 http://gank.io/ true 粉丝日志 %&#125;</span><br><span class="line"># Markdown语法</span><br><span class="line">[gank日志](http://gank.io/)</span><br><span class="line"></span><br><span class="line">## 图片</span><br><span class="line"># Swig语法</span><br><span class="line">&#123;% img /images/新的开始/meizi.jpg 400 600 这是一张图片 %&#125;</span><br><span class="line"># Markdown语法</span><br><span class="line">![这是一张图片](http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B/meizi.jpg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 公式</span><br><span class="line">$$J\_\alpha(x)=\sum _&#123;m=0&#125;^\infty \frac&#123;(-1)^ m&#125;&#123;m! \, \Gamma (m + \alpha + 1)&#125;&#123;\left(&#123;\frac&#123;x&#125;&#123;2&#125;&#125;\right)&#125;^&#123;2 m + \alpha &#125;$$</span><br><span class="line">感觉非常好。</span><br></pre></td></tr></table></figure>
<p>文章使用markedonw语法写的，还有很多普通或者高级的语法，这个可以问度娘或者谷歌，找找别人的帖子学学。</p>
<p>用命令行启动本地server：hexo server<br>通过浏览器打开， <a href="http://localhost:4000/" target="_blank" rel="external">http://localhost:4000/</a> ，就出现了我们新写的文章。</p>
<p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%8E%86%E7%A8%8B/newstart.png" alt="新的开始文章预览图"></p>
<hr>
<h2 id="4-发布到Github"><a href="#4-发布到Github" class="headerlink" title="4. 发布到Github"></a>4. 发布到Github</h2><p>1)  静态化处理<br>&#160; &#160; &#160; &#160;写完了文章，我们就可以发布了。要说明的一点是hexo的静态博客框架，那什么是静态博客呢？静态博客，是只包含html, javascript, css文件的网站，没有动态的脚本。虽然我们是用Node进行的开发，但博客的发布后就与Node无关了。在发布之前，我们要通过一条命令，把所有的文章都做静态化处理，就是生成对应的html, javascript, css，使得所有的文章都是由静态文件组成的。</p>
<p>输入静态化命令 ：hexo generate<br>在本地目录下，会生成一个public的目录，里面包括了所有静态化的文件。</p>
<p>2) 发布到github<br>接下来，我们把这个博客发布到github。<br>现在检查我们上次填好的_config.yml文件，找到deploy的部分，设置github的项目地址。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/windrunnerlihuan/windrunnerlihuan.github.io.git</span><br></pre></td></tr></table></figure></p>
<p>然后执行部署命令：hexo deploy<br>中间过程会让你再次输入github账号和密码，输入就行了<br>成功后验证，浏览器里输入上次的地址：<a href="http://windrunnerlihuan.github.io" target="_blank" rel="external">http://windrunnerlihuan.github.io</a></p>
<p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%8E%86%E7%A8%8B/newstart.png" alt="新的开始文章预览图"><br>说明我们成功了</p>
<hr>
<h2 id="5-独立购买域名与绑定"><a href="#5-独立购买域名与绑定" class="headerlink" title="5. 独立购买域名与绑定"></a>5. 独立购买域名与绑定</h2><p>&#160; &#160; &#160; &#160;有时候我们想做个人博客，想让自己的博客拥有自己的域名，那就得去买个域名了。这里我们可以通过万网申请购买：<a href="https://wanwang.aliyun.com/" target="_blank" rel="external">https://wanwang.aliyun.com/</a>  。流程很简单，基本上一路next。<br>我也斥资45块买了个.com结尾的域名 <strong>windrunnerlihuan.com</strong> 。</p>
<p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%8E%86%E7%A8%8B/yulist.png" alt="域名列表图片"></p>
<p>然后就是解析域名了，不过解析之前你得知道你的gihub pages个人主页的ip：<br>首先ping 一下个人主页地址 ，控制台里输入 ping www.windrunnerlihuan.github.io，然后会返回一个ip，然后用这个ip设置我们刚才买的域名解析，也是轻车熟路</p>
<p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%8E%86%E7%A8%8B/yudecode.png" alt="域名解析图片"></p>
<p>最后最重要的是：<br>1）在github项目中，新建一个文件CNAME，文件中写出你要绑定的域名windrunnerlihuan.com。通过浏览器，访问<a href="http://windrunnerlihuan.com，就打开了我们建好的博客站点。" target="_blank" rel="external">http://windrunnerlihuan.com，就打开了我们建好的博客站点。</a><br>2）由于每次执行deploy的时候，github代码仓库所有的文件都会被覆盖，所以我们最好在source目录下创建这个CNAME文件，这样每次部署就不用动手创建了。</p>
<hr>
<h2 id="6-个性化功能配置"><a href="#6-个性化功能配置" class="headerlink" title="6. 个性化功能配置"></a>6. 个性化功能配置</h2><p>1） 替换皮肤<br>博客系统流行的原因，是因为他的个人性，而皮肤正式个性化的一种体现。<br>利用hexo替换皮肤，还是比较简单的，3步完成。</p>
<p><strong>No.1</strong>  找到一个皮肤或者自己开发一个皮肤<br>打开hexo的皮肤列表页面，你可以找到很多的皮肤，网页地址： <a href="https://github.com/tommy351/hexo/wiki/Themes" target="_blank" rel="external">https://github.com/tommy351/hexo/wiki/Themes</a> 。 </p>
<p><strong>No.2</strong>放到themes目录下<br>比如，我觉得pacman( <a href="https://github.com/A-limon/pacman" target="_blank" rel="external">https://github.com/A-limon/pacman</a> )这个皮肤还不错，我就可以下载皮肤到themes目录下面。<br>通过git命令下载皮肤<br>git clone <a href="https://github.com/A-limon/pacman.git" target="_blank" rel="external">https://github.com/A-limon/pacman.git</a> themes/pacman</p>
<p><strong>No.3</strong>在_config.yml指定皮肤<br>编辑文件_config.yml，找到theme一行，改成 theme: pacman<br>本地启动hexo服务器，打开浏览器 <a href="http://localhost:4000" target="_blank" rel="external">http://localhost:4000</a></p>
<p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%8E%86%E7%A8%8B/pifu.png" alt="替换了皮肤的博客"></p>
<p>新皮肤的效果还不错吧，然后静态化处理，再发布到github，就完成了站点的改版。</p>
<p>这里只介绍换皮肤，当然还有其他很多功能，不过对于我来说暂时没多大卵用，如果其他人有需求可以再google或者baidu搜，也都不难，很easy。</p>
<hr>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>&#160; &#160; &#160; &#160;因为这是我第一次搭建个人博客，水平实在比较差，流程写的很粗燥，很多细节都没有涉及，望大家体谅，以后我会努力完善的，将后续文章做的更好。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[新的开始]]></title>
      <url>http://windrunnerlihuan.com/2016/05/27/%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B/</url>
      <content type="html"><![CDATA[<p>这是<strong>新的开始</strong>，我用hexo创建了第一篇文章。</p>
<p>通过下面的命令，就可以创建新文章<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D:\workspace\javascript\nodejs-hexo&gt;hexo new 新的开始</span><br><span class="line">[info] File created at D:\workspace\javascript\nodejs-hexo\source\_posts\新的开始.md</span><br></pre></td></tr></table></figure></p>
<p>感觉非常好。</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><h1 id="Swig语法"><a href="#Swig语法" class="headerlink" title="Swig语法"></a>Swig语法</h1><blockquote><p>Every interaction is both precious and an opportunity to delight.</p>
<footer><strong>Seth Godin</strong><cite><a href="http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html" target="_blank" rel="external">Welcome to Island Marketing</a></cite></footer></blockquote>
<h1 id="Markdown语法"><a href="#Markdown语法" class="headerlink" title="Markdown语法"></a>Markdown语法</h1><blockquote>
<p>Every interaction is both precious and an opportunity to delight.</p>
</blockquote>
<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><h1 id="Swig语法-1"><a href="#Swig语法-1" class="headerlink" title="Swig语法"></a>Swig语法</h1><figure class="highlight plain"><figcaption><span>.compact</span><a href="http://underscorejs.org/#compact" target="_blank" rel="external">Underscore.js</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.compact([0, 1, false, 2, ‘’, 3]);</span><br><span class="line">=&gt; [1, 2, 3]</span><br></pre></td></tr></table></figure>
<h1 id="Markdown语法-1"><a href="#Markdown语法-1" class="headerlink" title="Markdown语法"></a>Markdown语法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.compact([0, 1, false, 2, ‘’, 3]);</span><br><span class="line">=&gt; [1, 2, 3]</span><br></pre></td></tr></table></figure>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><h1 id="Swig语法-2"><a href="#Swig语法-2" class="headerlink" title="Swig语法"></a>Swig语法</h1><a href="http://gank.io/" title="粉丝日志" target="_blank">gank日志</a>
<h1 id="Markdown语法-2"><a href="#Markdown语法-2" class="headerlink" title="Markdown语法"></a>Markdown语法</h1><p><a href="http://gank.io/" target="_blank" rel="external">gank日志</a><br><a href="404html">测试404页面</a></p>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><h1 id="Swig语法-3"><a href="#Swig语法-3" class="headerlink" title="Swig语法"></a>Swig语法</h1><img src="http://static.hdslb.com/images/favicon.ico" width="100" height="100" title="这是一张图片">
<h1 id="Markdown语法-3"><a href="#Markdown语法-3" class="headerlink" title="Markdown语法"></a>Markdown语法</h1><p><img src="http://static.hdslb.com/images/favicon.ico" alt="这是一张图片"></p>
<h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><p>$$J_\alpha(x)=\sum _{m=0}^\infty \frac{(-1)^ m}{m! \, \Gamma (m + \alpha + 1)}{\left({\frac{x}{2}}\right)}^{2 m + \alpha }$$</p>
<hr>
]]></content>
    </entry>
    
  
  
</search>
